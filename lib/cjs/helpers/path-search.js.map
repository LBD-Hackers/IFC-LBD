{"version":3,"sources":["../../../src/helpers/path-search.ts"],"names":["Input","buildRelOneToOne","d","includeInterface","undefined","graph","ifcAPI","properties","getAllItemsOfType","modelID","ifcRelationship","rels","i","length","relID","getItemProperties","relProps","ifcSubjectRel","ifcTargetRel","Promise","all","value","subject","target","GlobalId","console","log","subjectURI","targetURI","interfaceURI","push","rdfRelationship","oppoiteRelationship","expressID","buildRelOneToMany","ifcSubjectClassIn","ifcTargetClassIn","includes","type","targetPromises","targets","targetObjects","filter","t","map"],"mappings":"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","sourcesContent":["import * as WebIFC from \"web-ifc/web-ifc-api.js\";\r\nimport { defaultURIBuilder } from \"./uri-builder\";\r\n\r\nexport class Input{\r\n    ifcAPI: WebIFC.IfcAPI;\r\n    modelID: number;\r\n    ifcRelationship: number;        // Eg. IFCRELCONNECTSPORTS\r\n    ifcSubjectRel: string;          // Eg. RelatedPort\r\n    ifcTargetRel: string;           // Eg. RelatingPort\r\n    rdfRelationship: string;        // Eg. fso:connectedPort\r\n    oppoiteRelationship?: string;   // Optional - used to establish a relationship in the other direction. For bidirectional relationships, use the same value as for rdfRelationship\r\n    ifcSubjectClassIn?: number[];   // Optional - used to limit bindings to cases where the subject is included in this list\r\n    ifcTargetClassIn?: number[];    // Optional - used to limit bindings to cases where the target is included in this list\r\n    includeInterface?: boolean;     // Used to also include the ifcRelationship as a bot:Interface\r\n}\r\n\r\n// ifcAPI: WebIFC.IfcAPI, modelID: number = 0, relationshipType: number, subjectRef: string, targetRef: string, rdfRelationship: string, includeInterface: boolean = false, biderectional: boolean = false\r\nexport async function buildRelOneToOne(d: Input): Promise<any>{\r\n\r\n    if(d.includeInterface == undefined) d.includeInterface = false;\r\n\r\n    const graph = [];\r\n\r\n    const rels = await d.ifcAPI.properties.getAllItemsOfType(d.modelID, d.ifcRelationship, false);\r\n\r\n    for (let i = 0; i < rels.length; i++) {\r\n\r\n        const relID = rels[i];\r\n\r\n        const relProps = await d.ifcAPI.properties.getItemProperties(d.modelID, relID);\r\n\r\n        // Only continue if the interface is between an element and a space\r\n        if(!relProps[d.ifcSubjectRel] || !relProps[d.ifcTargetRel]) { continue; }\r\n\r\n        // Get properties of related and relating\r\n        const [subject, target] = await Promise.all([\r\n            d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcSubjectRel].value),\r\n            d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcTargetRel].value)\r\n        ]);\r\n\r\n        if(subject.GlobalId.value == \"0dG4XB8Mj2QhLcDnrkJh$F\"){\r\n            console.log(\"subject\");\r\n        }\r\n\r\n        if(target.GlobalId.value == \"0dG4XB8Mj2QhLcDnrkJh$F\"){\r\n            console.log(\"target\");\r\n        }\r\n\r\n        const subjectURI = defaultURIBuilder(subject.GlobalId.value);\r\n        const targetURI = defaultURIBuilder(target.GlobalId.value);\r\n        const interfaceURI = defaultURIBuilder(relProps.GlobalId.value);\r\n\r\n        // Push relationships\r\n        graph.push({\r\n            \"@id\": subjectURI,\r\n            [d.rdfRelationship]: {\"@id\": targetURI}\r\n        });\r\n\r\n        // Optionally, push it in opposite direction\r\n        if(d.oppoiteRelationship != undefined){\r\n            graph.push({\r\n                \"@id\": targetURI,\r\n                [d.oppoiteRelationship]: {\"@id\": subjectURI}\r\n            });\r\n        }\r\n\r\n        // Optionally, also include the interface\r\n        if(d.includeInterface){\r\n            graph.push({\r\n                \"@id\": interfaceURI,\r\n                \"@type\": \"bot:Interface\",\r\n                \"ex:expressID\": relProps.expressID,\r\n                \"bot:interfaceOf\": [\r\n                    {\"@id\": subjectURI},\r\n                    {\"@id\": targetURI}\r\n                ]\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    return graph;\r\n\r\n}\r\n\r\n// ifcAPI: WebIFC.IfcAPI, modelID: number = 0, relationshipType: number, subjectRef: string, targetRef: string, rdfRelationship: string, subjectClassConstraint?: number, targetClassConstraint?: number\r\nexport async function buildRelOneToMany(d: Input): Promise<any>{\r\n\r\n    if(d.ifcSubjectClassIn == undefined) d.ifcSubjectClassIn = [];\r\n    if(d.ifcTargetClassIn == undefined) d.ifcTargetClassIn = [];\r\n\r\n    const graph = [];\r\n\r\n    const rels = await d.ifcAPI.properties.getAllItemsOfType(d.modelID, d.ifcRelationship, false);\r\n\r\n    for (let i = 0; i < rels.length; i++) {\r\n\r\n        const relID = rels[i];\r\n\r\n        const relProps = await d.ifcAPI.properties.getItemProperties(d.modelID, relID);\r\n\r\n        // Only continue if the interface is between an element and a space\r\n        if(!relProps[d.ifcSubjectRel] || !relProps[d.ifcTargetRel]) { continue; }\r\n\r\n        const subject = await d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcSubjectRel].value);\r\n\r\n        // It might be that we are only interested in relationship where the subject fulfills the constraint\r\n        if(d.ifcSubjectClassIn.length && !d.ifcSubjectClassIn.includes(subject.type)) { continue; }\r\n\r\n        const targetPromises: any = [];\r\n        for (let i = 0; i < relProps[d.ifcTargetRel].length; i++) {\r\n            targetPromises.push(d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcTargetRel][i].value));\r\n        }\r\n        const targets = await Promise.all(targetPromises);\r\n\r\n        const targetObjects = targets\r\n            .filter((t: any) => {\r\n                // It might be that we are only interested in relationship where the target fulfills the constraint\r\n                if(d.ifcTargetClassIn.length && !d.ifcTargetClassIn.includes(t.type)) return false;\r\n                return true;\r\n            })\r\n            .map((t: any) => {\r\n                const targetURI = defaultURIBuilder(t.GlobalId.value);\r\n                return {\"@id\": targetURI}\r\n            });\r\n\r\n        // Skip if no target objects\r\n        if(!targetObjects.length) { continue; }\r\n\r\n        const subjectURI = defaultURIBuilder(subject.GlobalId.value);\r\n\r\n        // Push relationships\r\n        graph.push({\r\n            \"@id\": subjectURI,\r\n            [d.rdfRelationship]: targetObjects\r\n        });\r\n\r\n    }\r\n\r\n    return graph;\r\n\r\n}"],"file":"path-search.js"}