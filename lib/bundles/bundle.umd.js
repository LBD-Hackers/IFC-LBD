(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jsonld'), require('n3'), require('@comunica/actor-init-sparql-rdfjs')) :
  typeof define === 'function' && define.amd ? define(['exports', 'jsonld', 'n3', '@comunica/actor-init-sparql-rdfjs'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["ifc-lbd"] = {}, global.jsonld, global.N3, global.comunica));
})(this, (function (exports, jsonld, N3, actorInitSparqlRdfjs) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var N3__namespace = /*#__PURE__*/_interopNamespace(N3);

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var runtime = {exports: {}};

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  (function (module) {
  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    define(Gp, toStringTagSymbol, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    define(Gp, iteratorSymbol, function() {
      return this;
    });

    define(Gp, "toString", function() {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  }(runtime));

  var regenerator = runtime.exports;

  var __filename = '/Users\mhra\Documents\Development\LBD\IFC-LBD\node_modules\web-ifc\web-ifc-api.js';

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance$1 = global$1.performance || {};
  var performanceNow =
    performance$1.now        ||
    performance$1.mozNow     ||
    performance$1.msNow      ||
    performance$1.oNow       ||
    performance$1.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance$1)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var __dirname = '/Users\mhra\Documents\Development\LBD\IFC-LBD\node_modules\web-ifc';

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read$1 (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read$1(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read$1(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read$1(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read$1(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __require = (x) => {
    if (typeof require !== "undefined")
      return require(x);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // dist/web-ifc-mt.js
  var require_web_ifc_mt = __commonJS({
    "dist/web-ifc-mt.js"(exports, module) {
      var WebIFCWasm2 = function() {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        _scriptDir = _scriptDir || __filename;
        return function(WebIFCWasm3) {
          WebIFCWasm3 = WebIFCWasm3 || {};
          function GROWABLE_HEAP_I8() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAP8;
          }
          function GROWABLE_HEAP_U8() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPU8;
          }
          function GROWABLE_HEAP_I16() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAP16;
          }
          function GROWABLE_HEAP_U16() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPU16;
          }
          function GROWABLE_HEAP_I32() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAP32;
          }
          function GROWABLE_HEAP_U32() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPU32;
          }
          function GROWABLE_HEAP_F32() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPF32;
          }
          function GROWABLE_HEAP_F64() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPF64;
          }
          var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = {};
          var key;
          for (key in Module) {
            if (Module.hasOwnProperty(key)) {
              moduleOverrides[key] = Module[key];
            }
          }
          var thisProgram = "./this.program";
          var quit_ = function(status, toThrow) {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = false;
          var ENVIRONMENT_IS_WORKER = false;
          var ENVIRONMENT_IS_NODE = false;
          var ENVIRONMENT_IS_SHELL = false;
          ENVIRONMENT_IS_WEB = typeof window === "object";
          ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
          ENVIRONMENT_IS_NODE = typeof process$1 === "object" && typeof process$1.versions === "object" && typeof process$1.versions.node === "string";
          ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
          var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
          if (ENVIRONMENT_IS_PTHREAD) {
            buffer = Module["buffer"];
          }
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readBinary;
          var nodeFS;
          var nodePath;
          if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            if (process$1["argv"].length > 1) {
              thisProgram = process$1["argv"][1].replace(/\\/g, "/");
            }
            quit_ = function(status) {
              process$1["exit"](status);
            };
            Module["inspect"] = function() {
              return "[Emscripten Module object]";
            };
            var nodeWorkerThreads;
            try {
              nodeWorkerThreads = __require("worker_threads");
            } catch (e) {
              console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
              throw e;
            }
            global$1.Worker = nodeWorkerThreads.Worker;
          } else if (ENVIRONMENT_IS_SHELL) {
            if (typeof read != "undefined") {
              read_ = function shell_read(f) {
                return read(f);
              };
            }
            readBinary = function readBinary2(f) {
              var data;
              if (typeof readbuffer === "function") {
                return new Uint8Array(readbuffer(f));
              }
              data = read(f, "binary");
              assert(typeof data === "object");
              return data;
            };
            if (typeof scriptArgs != "undefined") {
              scriptArgs;
            }
            if (typeof quit === "function") {
              quit_ = function(status) {
                quit(status);
              };
            }
            if (typeof print !== "undefined") {
              if (typeof console === "undefined")
                console = {};
              console.log = print;
              console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
            }
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document !== "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            if (ENVIRONMENT_IS_NODE) {
              read_ = function shell_read(filename, binary) {
                if (!nodeFS)
                  nodeFS = __require("fs");
                if (!nodePath)
                  nodePath = __require("path");
                filename = nodePath["normalize"](filename);
                return nodeFS["readFileSync"](filename, binary ? null : "utf8");
              };
              readBinary = function readBinary2(filename) {
                var ret = read_(filename, true);
                if (!ret.buffer) {
                  ret = new Uint8Array(ret);
                }
                assert(ret.buffer);
                return ret;
              };
            } else {
              read_ = function shell_read(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = function readBinary2(url) {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
            }
          } else ;
          if (ENVIRONMENT_IS_NODE) {
            if (typeof performance === "undefined") {
              global$1.performance = __require("perf_hooks").performance;
            }
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module[key] = moduleOverrides[key];
            }
          }
          moduleOverrides = null;
          if (Module["arguments"])
            ;
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var STACK_ALIGN = 16;
          function alignMemory(size, factor) {
            if (!factor)
              factor = STACK_ALIGN;
            return Math.ceil(size / factor) * factor;
          }
          function warnOnce(text) {
            if (!warnOnce.shown)
              warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
              warnOnce.shown[text] = 1;
              err(text);
            }
          }
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          var noExitRuntime;
          if (Module["noExitRuntime"])
            noExitRuntime = Module["noExitRuntime"];
          if (typeof WebAssembly !== "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var wasmModule;
          var threadInfoStruct = 0;
          var ABORT = false;
          function assert(condition, text) {
            if (!condition) {
              abort("Assertion failed: " + text);
            }
          }
          function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var str = "";
            while (!(idx >= endIdx)) {
              var u0 = heap[idx++ >>> 0];
              if (!u0)
                return str;
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            ptr >>>= 0;
            return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
          }
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343)
                u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
              if (u <= 127)
                ++len;
              else if (u <= 2047)
                len += 2;
              else if (u <= 65535)
                len += 3;
              else
                len += 4;
            }
            return len;
          }
          function UTF16ToString(ptr, maxBytesToRead) {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
          function stringToUTF16(str, outPtr, maxBytesToWrite) {
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 2)
              return 0;
            maxBytesToWrite -= 2;
            var startPtr = outPtr;
            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
            for (var i = 0; i < numCharsToWrite; ++i) {
              var codeUnit = str.charCodeAt(i);
              GROWABLE_HEAP_I16()[outPtr >> 1] = codeUnit;
              outPtr += 2;
            }
            GROWABLE_HEAP_I16()[outPtr >> 1] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF16(str) {
            return str.length * 2;
          }
          function UTF32ToString(ptr, maxBytesToRead) {
            var i = 0;
            var str = "";
            while (!(i >= maxBytesToRead / 4)) {
              var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >> 2];
              if (utf32 == 0)
                break;
              ++i;
              if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              } else {
                str += String.fromCharCode(utf32);
              }
            }
            return str;
          }
          function stringToUTF32(str, outPtr, maxBytesToWrite) {
            outPtr >>>= 0;
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 4)
              return 0;
            var startPtr = outPtr;
            var endPtr = startPtr + maxBytesToWrite - 4;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
              }
              GROWABLE_HEAP_I32()[outPtr >> 2] = codeUnit;
              outPtr += 4;
              if (outPtr + 4 > endPtr)
                break;
            }
            GROWABLE_HEAP_I32()[outPtr >> 2] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF32(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i;
              len += 4;
            }
            return len;
          }
          function writeArrayToMemory(array, buffer2) {
            GROWABLE_HEAP_I8().set(array, buffer2);
          }
          function writeAsciiToMemory(str, buffer2, dontAddNull) {
            for (var i = 0; i < str.length; ++i) {
              GROWABLE_HEAP_I8()[buffer2++ >> 0] = str.charCodeAt(i);
            }
            if (!dontAddNull)
              GROWABLE_HEAP_I8()[buffer2 >> 0] = 0;
          }
          function alignUp(x, multiple) {
            if (x % multiple > 0) {
              x += multiple - x % multiple;
            }
            return x;
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
          }
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          if (ENVIRONMENT_IS_PTHREAD) {
            wasmMemory = Module["wasmMemory"];
            buffer = Module["buffer"];
          } else {
            if (Module["wasmMemory"]) {
              wasmMemory = Module["wasmMemory"];
            } else {
              wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 4294967296 / 65536, "shared": true });
              if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
                err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
                if (ENVIRONMENT_IS_NODE) {
                  console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
                }
                throw Error("bad memory");
              }
            }
          }
          if (wasmMemory) {
            buffer = wasmMemory.buffer;
          }
          INITIAL_MEMORY = buffer.byteLength;
          updateGlobalBufferAndViews(buffer);
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          function preRun() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            if (!Module["noFSInit"] && !FS.init.initialized)
              FS.init();
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            FS.ignorePermissions = false;
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var dependenciesFulfilled = null;
          function addRunDependency(id) {
            assert(!ENVIRONMENT_IS_PTHREAD, "addRunDependency cannot be used in a pthread worker");
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          Module["preloadedImages"] = {};
          Module["preloadedAudios"] = {};
          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what);
            }
            if (ENVIRONMENT_IS_PTHREAD)
              console.error("Pthread aborting at " + new Error().stack);
            what += "";
            err(what);
            ABORT = true;
            what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          function hasPrefix(str, prefix) {
            return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return hasPrefix(filename, dataURIPrefix);
          }
          var fileURIPrefix = "file://";
          function isFileURI(filename) {
            return hasPrefix(filename, fileURIPrefix);
          }
          var wasmBinaryFile = "web-ifc-mt.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary() {
            try {
              if (wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(wasmBinaryFile);
              } else {
                throw "both async and sync fetching of the wasm failed";
              }
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary();
              });
            }
            return Promise.resolve().then(getBinary);
          }
          function createWasm() {
            var info = { "a": asmLibraryArg };
            function receiveInstance(instance, module2) {
              var exports3 = instance.exports;
              Module["asm"] = exports3;
              wasmTable = Module["asm"]["pa"];
              wasmModule = module2;
              if (!ENVIRONMENT_IS_PTHREAD) {
                var numWorkersToLoad = PThread.unusedWorkers.length;
                PThread.unusedWorkers.forEach(function(w) {
                  PThread.loadWasmModuleToWorker(w, function() {
                    if (!--numWorkersToLoad)
                      removeRunDependency();
                  });
                });
              }
            }
            if (!ENVIRONMENT_IS_PTHREAD) {
              addRunDependency();
            }
            function receiveInstantiatedSource(output) {
              receiveInstance(output["instance"], output["module"]);
            }
            function instantiateArrayBuffer(receiver) {
              return getBinaryPromise().then(function(binary) {
                return WebAssembly.instantiate(binary, info);
              }).then(receiver, function(reason) {
                err("failed to asynchronously prepare wasm: " + reason);
                abort(reason);
              });
            }
            function instantiateAsync() {
              if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
                return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  var result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiatedSource, function(reason) {
                    err("wasm streaming compile failed: " + reason);
                    err("falling back to ArrayBuffer instantiation");
                    return instantiateArrayBuffer(receiveInstantiatedSource);
                  });
                });
              } else {
                return instantiateArrayBuffer(receiveInstantiatedSource);
              }
            }
            if (Module["instantiateWasm"]) {
              try {
                var exports2 = Module["instantiateWasm"](info, receiveInstance);
                return exports2;
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false;
              }
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          var ASM_CONSTS = { 41793: function($0, $1) {
            setTimeout(function() {
              _do_emscripten_dispatch_to_thread($0, $1);
            }, 0);
          }, 41871: function() {
            throw "Canceled!";
          } };
          function initPthreadsJS() {
            PThread.initRuntime();
          }
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == "function") {
                callback(Module);
                continue;
              }
              var func = callback.func;
              if (typeof func === "number") {
                if (callback.arg === void 0) {
                  wasmTable.get(func)();
                } else {
                  wasmTable.get(func)(callback.arg);
                }
              } else {
                func(callback.arg === void 0 ? null : callback.arg);
              }
            }
          }
          function dynCallLegacy(sig, ptr, args) {
            if (args && args.length) {
              return Module["dynCall_" + sig].apply(null, [ptr].concat(args));
            }
            return Module["dynCall_" + sig].call(null, ptr);
          }
          function dynCall(sig, ptr, args) {
            if (sig.indexOf("j") != -1) {
              return dynCallLegacy(sig, ptr, args);
            }
            return wasmTable.get(ptr).apply(null, args);
          }
          Module["dynCall"] = dynCall;
          var __pthread_ptr = 0;
          var __pthread_is_main_runtime_thread = 0;
          var __pthread_is_main_browser_thread = 0;
          function registerPthreadPtr(pthreadPtr, isMainBrowserThread, isMainRuntimeThread) {
            pthreadPtr = pthreadPtr | 0;
            isMainBrowserThread = isMainBrowserThread | 0;
            isMainRuntimeThread = isMainRuntimeThread | 0;
            __pthread_ptr = pthreadPtr;
            __pthread_is_main_browser_thread = isMainBrowserThread;
            __pthread_is_main_runtime_thread = isMainRuntimeThread;
          }
          Module["registerPthreadPtr"] = registerPthreadPtr;
          var ERRNO_CODES = { EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135 };
          function _emscripten_futex_wake(addr, count) {
            if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count < 0)
              return -28;
            if (count == 0)
              return 0;
            if (count >= 2147483647)
              count = Infinity;
            var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), PThread.mainThreadFutex >> 2);
            var mainThreadWoken = 0;
            if (mainThreadWaitAddress == addr) {
              var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), PThread.mainThreadFutex >> 2, mainThreadWaitAddress, 0);
              if (loadedAddr == mainThreadWaitAddress) {
                --count;
                mainThreadWoken = 1;
                if (count <= 0)
                  return 1;
              }
            }
            var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count);
            if (ret >= 0)
              return ret + mainThreadWoken;
            throw "Atomics.notify returned an unexpected value " + ret;
          }
          Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
          function killThread(pthread_ptr) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! killThread() can only ever be called from main application thread!";
            if (!pthread_ptr)
              throw "Internal Error! Null pthread_ptr in killThread!";
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >> 2] = 0;
            var pthread = PThread.pthreads[pthread_ptr];
            pthread.worker.terminate();
            PThread.freeThreadData(pthread);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
            pthread.worker.pthread = void 0;
          }
          function cancelThread(pthread_ptr) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! cancelThread() can only ever be called from main application thread!";
            if (!pthread_ptr)
              throw "Internal Error! Null pthread_ptr in cancelThread!";
            var pthread = PThread.pthreads[pthread_ptr];
            pthread.worker.postMessage({ "cmd": "cancel" });
          }
          function cleanupThread(pthread_ptr) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! cleanupThread() can only ever be called from main application thread!";
            if (!pthread_ptr)
              throw "Internal Error! Null pthread_ptr in cleanupThread!";
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >> 2] = 0;
            var pthread = PThread.pthreads[pthread_ptr];
            if (pthread) {
              var worker = pthread.worker;
              PThread.returnWorkerToPool(worker);
            }
          }
          var PThread = { MAIN_THREAD_ID: 1, mainThreadInfo: { schedPolicy: 0, schedPrio: 0 }, unusedWorkers: [], runningWorkers: [], initMainThreadBlock: function() {
            var pthreadPoolSize = navigator.hardwareConcurrency;
            for (var i = 0; i < pthreadPoolSize; ++i) {
              PThread.allocateUnusedWorker();
            }
          }, initRuntime: function() {
            PThread.mainThreadBlock = _malloc(232);
            for (var i = 0; i < 232 / 4; ++i)
              GROWABLE_HEAP_U32()[PThread.mainThreadBlock / 4 + i] = 0;
            GROWABLE_HEAP_I32()[PThread.mainThreadBlock + 12 >> 2] = PThread.mainThreadBlock;
            var headPtr = PThread.mainThreadBlock + 156;
            GROWABLE_HEAP_I32()[headPtr >> 2] = headPtr;
            var tlsMemory = _malloc(512);
            for (var i = 0; i < 128; ++i)
              GROWABLE_HEAP_U32()[tlsMemory / 4 + i] = 0;
            Atomics.store(GROWABLE_HEAP_U32(), PThread.mainThreadBlock + 104 >> 2, tlsMemory);
            Atomics.store(GROWABLE_HEAP_U32(), PThread.mainThreadBlock + 40 >> 2, PThread.mainThreadBlock);
            Atomics.store(GROWABLE_HEAP_U32(), PThread.mainThreadBlock + 44 >> 2, 42);
            PThread.initShared();
            registerPthreadPtr(PThread.mainThreadBlock, !ENVIRONMENT_IS_WORKER, 1);
            _emscripten_register_main_browser_thread_id(PThread.mainThreadBlock);
          }, initWorker: function() {
            PThread.initShared();
            readyPromiseResolve(Module);
          }, initShared: function() {
            PThread.mainThreadFutex = _main_thread_futex;
          }, pthreads: {}, threadExitHandlers: [], setThreadStatus: function() {
          }, runExitHandlers: function() {
            while (PThread.threadExitHandlers.length > 0) {
              PThread.threadExitHandlers.pop()();
            }
            if (ENVIRONMENT_IS_PTHREAD && threadInfoStruct)
              ___pthread_tsd_run_dtors();
          }, threadExit: function(exitCode) {
            var tb = _pthread_self();
            if (tb) {
              Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
              Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
              Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 1);
              Atomics.store(GROWABLE_HEAP_U32(), tb + 64 >> 2, 0);
              PThread.runExitHandlers();
              _emscripten_futex_wake(tb + 0, 2147483647);
              registerPthreadPtr(0, 0, 0);
              threadInfoStruct = 0;
              if (ENVIRONMENT_IS_PTHREAD) {
                postMessage({ "cmd": "exit" });
              }
            }
          }, threadCancel: function() {
            PThread.runExitHandlers();
            Atomics.store(GROWABLE_HEAP_U32(), threadInfoStruct + 4 >> 2, -1);
            Atomics.store(GROWABLE_HEAP_U32(), threadInfoStruct + 0 >> 2, 1);
            _emscripten_futex_wake(threadInfoStruct + 0, 2147483647);
            threadInfoStruct = 0;
            registerPthreadPtr(0, 0, 0);
            postMessage({ "cmd": "cancelDone" });
          }, terminateAllThreads: function() {
            for (var t in PThread.pthreads) {
              var pthread = PThread.pthreads[t];
              if (pthread && pthread.worker) {
                PThread.returnWorkerToPool(pthread.worker);
              }
            }
            PThread.pthreads = {};
            for (var i = 0; i < PThread.unusedWorkers.length; ++i) {
              var worker = PThread.unusedWorkers[i];
              worker.terminate();
            }
            PThread.unusedWorkers = [];
            for (var i = 0; i < PThread.runningWorkers.length; ++i) {
              var worker = PThread.runningWorkers[i];
              var pthread = worker.pthread;
              PThread.freeThreadData(pthread);
              worker.terminate();
            }
            PThread.runningWorkers = [];
          }, freeThreadData: function(pthread) {
            if (!pthread)
              return;
            if (pthread.threadInfoStruct) {
              var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 104 >> 2];
              GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 104 >> 2] = 0;
              _free(tlsMemory);
              _free(pthread.threadInfoStruct);
            }
            pthread.threadInfoStruct = 0;
            if (pthread.allocatedOwnStack && pthread.stackBase)
              _free(pthread.stackBase);
            pthread.stackBase = 0;
            if (pthread.worker)
              pthread.worker.pthread = null;
          }, returnWorkerToPool: function(worker) {
            delete PThread.pthreads[worker.pthread.thread];
            PThread.unusedWorkers.push(worker);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
            PThread.freeThreadData(worker.pthread);
            worker.pthread = void 0;
          }, receiveObjectTransfer: function(data) {
          }, loadWasmModuleToWorker: function(worker, onFinishedLoading) {
            worker.onmessage = function(e) {
              var d = e["data"];
              var cmd = d["cmd"];
              if (worker.pthread)
                PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
              if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
                var thread = PThread.pthreads[d.targetThread];
                if (thread) {
                  thread.worker.postMessage(e.data, d["transferList"]);
                } else {
                  console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
                }
                PThread.currentProxiedOperationCallerThread = void 0;
                return;
              }
              if (cmd === "processQueuedMainThreadWork") {
                _emscripten_main_thread_process_queued_calls();
              } else if (cmd === "spawnThread") {
                spawnThread(e.data);
              } else if (cmd === "cleanupThread") {
                cleanupThread(d["thread"]);
              } else if (cmd === "killThread") {
                killThread(d["thread"]);
              } else if (cmd === "cancelThread") {
                cancelThread(d["thread"]);
              } else if (cmd === "loaded") {
                worker.loaded = true;
                if (onFinishedLoading)
                  onFinishedLoading(worker);
                if (worker.runPthread) {
                  worker.runPthread();
                  delete worker.runPthread;
                }
              } else if (cmd === "print") {
                out("Thread " + d["threadId"] + ": " + d["text"]);
              } else if (cmd === "printErr") {
                err("Thread " + d["threadId"] + ": " + d["text"]);
              } else if (cmd === "alert") {
                alert("Thread " + d["threadId"] + ": " + d["text"]);
              } else if (cmd === "exit") {
                var detached = worker.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker.pthread.thread + 68 >> 2);
                if (detached) {
                  PThread.returnWorkerToPool(worker);
                }
              } else if (cmd === "cancelDone") {
                PThread.returnWorkerToPool(worker);
              } else if (cmd === "objectTransfer") {
                PThread.receiveObjectTransfer(e.data);
              } else if (e.data.target === "setimmediate") {
                worker.postMessage(e.data);
              } else {
                err("worker sent an unknown command " + cmd);
              }
              PThread.currentProxiedOperationCallerThread = void 0;
            };
            worker.onerror = function(e) {
              err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
            };
            if (ENVIRONMENT_IS_NODE) {
              worker.on("message", function(data) {
                worker.onmessage({ data });
              });
              worker.on("error", function(data) {
                worker.onerror(data);
              });
              worker.on("exit", function(data) {
              });
            }
            worker.postMessage({ "cmd": "load", "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir, "wasmMemory": wasmMemory, "wasmModule": wasmModule });
          }, allocateUnusedWorker: function() {
            var pthreadMainJs = locateFile("web-ifc-mt.worker.js");
            PThread.unusedWorkers.push(new Worker(pthreadMainJs));
          }, getNewWorker: function() {
            if (PThread.unusedWorkers.length == 0) {
              PThread.allocateUnusedWorker();
              PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
            }
            if (PThread.unusedWorkers.length > 0)
              return PThread.unusedWorkers.pop();
            else
              return null;
          }, busySpinWait: function(msecs) {
            var t = performance.now() + msecs;
            while (performance.now() < t) {
            }
          } };
          function establishStackSpace(stackTop, stackMax) {
            _emscripten_stack_set_limits(stackTop, stackMax);
            stackRestore(stackTop);
          }
          Module["establishStackSpace"] = establishStackSpace;
          function getNoExitRuntime() {
            return noExitRuntime;
          }
          Module["getNoExitRuntime"] = getNoExitRuntime;
          function ___assert_fail(condition, filename, line, func) {
            abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
          }
          var _emscripten_get_now;
          if (ENVIRONMENT_IS_NODE) {
            _emscripten_get_now = function() {
              var t = process$1["hrtime"]();
              return t[0] * 1e3 + t[1] / 1e6;
            };
          } else if (ENVIRONMENT_IS_PTHREAD) {
            _emscripten_get_now = function() {
              return performance.now() - Module["__performance_now_clock_drift"];
            };
          } else if (typeof dateNow !== "undefined") {
            _emscripten_get_now = dateNow;
          } else
            _emscripten_get_now = function() {
              return performance.now();
            };
          var _emscripten_get_now_is_monotonic = true;
          function setErrNo(value) {
            GROWABLE_HEAP_I32()[___errno_location() >> 2] = value;
            return value;
          }
          function _clock_gettime(clk_id, tp) {
            var now;
            if (clk_id === 0) {
              now = Date.now();
            } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
              now = _emscripten_get_now();
            } else {
              setErrNo(28);
              return -1;
            }
            GROWABLE_HEAP_I32()[tp >> 2] = now / 1e3 | 0;
            GROWABLE_HEAP_I32()[tp + 4 >> 2] = now % 1e3 * 1e3 * 1e3 | 0;
            return 0;
          }
          var ExceptionInfoAttrs = { DESTRUCTOR_OFFSET: 0, REFCOUNT_OFFSET: 4, TYPE_OFFSET: 8, CAUGHT_OFFSET: 12, RETHROWN_OFFSET: 13, SIZE: 16 };
          function ___cxa_allocate_exception(size) {
            return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE;
          }
          function _atexit(func, arg) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(1, 1, func, arg);
          }
          function ExceptionInfo(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - ExceptionInfoAttrs.SIZE;
            this.set_type = function(type) {
              GROWABLE_HEAP_I32()[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >> 2] = type;
            };
            this.get_type = function() {
              return GROWABLE_HEAP_I32()[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >> 2];
            };
            this.set_destructor = function(destructor) {
              GROWABLE_HEAP_I32()[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >> 2] = destructor;
            };
            this.get_destructor = function() {
              return GROWABLE_HEAP_I32()[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >> 2];
            };
            this.set_refcount = function(refcount) {
              GROWABLE_HEAP_I32()[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = refcount;
            };
            this.set_caught = function(caught) {
              caught = caught ? 1 : 0;
              GROWABLE_HEAP_I8()[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >> 0] = caught;
            };
            this.get_caught = function() {
              return GROWABLE_HEAP_I8()[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >> 0] != 0;
            };
            this.set_rethrown = function(rethrown) {
              rethrown = rethrown ? 1 : 0;
              GROWABLE_HEAP_I8()[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >> 0] = rethrown;
            };
            this.get_rethrown = function() {
              return GROWABLE_HEAP_I8()[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >> 0] != 0;
            };
            this.init = function(type, destructor) {
              this.set_type(type);
              this.set_destructor(destructor);
              this.set_refcount(0);
              this.set_caught(false);
              this.set_rethrown(false);
            };
            this.add_ref = function() {
              Atomics.add(GROWABLE_HEAP_I32(), this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2, 1);
            };
            this.release_ref = function() {
              var prev = Atomics.sub(GROWABLE_HEAP_I32(), this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2, 1);
              return prev === 1;
            };
          }
          function ___cxa_throw(ptr, type, destructor) {
            var info = new ExceptionInfo(ptr);
            info.init(type, destructor);
            throw ptr;
          }
          var PATH = { splitPath: function(filename) {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, normalizeArray: function(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, normalize: function(path) {
            var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, dirname: function(path) {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, basename: function(path) {
            if (path === "/")
              return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1)
              return path;
            return path.substr(lastSlash + 1);
          }, extname: function(path) {
            return PATH.splitPath(path)[3];
          }, join: function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          }, join2: function(l, r) {
            return PATH.normalize(l + "/" + r);
          } };
          function getRandomDevice() {
            if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
              var randomBuffer = new Uint8Array(1);
              return function() {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0];
              };
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = require_crypto();
                return function() {
                  return crypto_module["randomBytes"](1)[0];
                };
              } catch (e) {
              }
            }
            return function() {
              abort("randomDevice");
            };
          }
          var PATH_FS = { resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : FS.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, relative: function(from, to) {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          } };
          var TTY = { ttys: [], init: function() {
          }, shutdown: function() {
          }, register: function(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, stream_ops: { open: function(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
              throw new FS.ErrnoError(43);
            }
            stream.tty = tty;
            stream.seekable = false;
          }, close: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, flush: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, read: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
              throw new FS.ErrnoError(60);
            }
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = stream.tty.ops.get_char(stream.tty);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
              throw new FS.ErrnoError(60);
            }
            try {
              for (var i = 0; i < length; i++) {
                stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
              }
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } }, default_tty_ops: { get_char: function(tty) {
            if (!tty.input.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
                var bytesRead = 0;
                try {
                  bytesRead = nodeFS.readSync(process$1.stdin.fd, buf, 0, BUFSIZE, null);
                } catch (e) {
                  if (e.toString().indexOf("EOF") != -1)
                    bytesRead = 0;
                  else
                    throw e;
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              tty.input = intArrayFromString(result, true);
            }
            return tty.input.shift();
          }, put_char: function(tty, val) {
            if (val === null || val === 10) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } }, default_tty1_ops: { put_char: function(tty, val) {
            if (val === null || val === 10) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } } };
          function mmapAlloc(size) {
            var alignedSize = alignMemory(size, 16384);
            var ptr = _malloc(alignedSize);
            while (size < alignedSize)
              GROWABLE_HEAP_I8()[ptr + size++] = 0;
            return ptr;
          }
          var MEMFS = { ops_table: null, mount: function(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, createNode: function(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            }
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
            }
            return node;
          }, getFileDataAsRegularArray: function(node) {
            if (node.contents && node.contents.subarray) {
              var arr = [];
              for (var i = 0; i < node.usedBytes; ++i)
                arr.push(node.contents[i]);
              return arr;
            }
            return node.contents;
          }, getFileDataAsTypedArray: function(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, expandFileStorage: function(node, newCapacity) {
            newCapacity >>>= 0;
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            return;
          }, resizeFileStorage: function(node, newSize) {
            newSize >>>= 0;
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
              return;
            }
            if (!node.contents || node.contents.subarray) {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
              return;
            }
            if (!node.contents)
              node.contents = [];
            if (node.contents.length > newSize)
              node.contents.length = newSize;
            else
              while (node.contents.length < newSize)
                node.contents.push(0);
            node.usedBytes = newSize;
          }, node_ops: { getattr: function(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
              attr.size = 4096;
            } else if (FS.isFile(node.mode)) {
              attr.size = node.usedBytes;
            } else if (FS.isLink(node.mode)) {
              attr.size = node.link.length;
            } else {
              attr.size = 0;
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr;
          }, setattr: function(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
            if (attr.size !== void 0) {
              MEMFS.resizeFileStorage(node, attr.size);
            }
          }, lookup: function(parent, name2) {
            throw FS.genericErrors[44];
          }, mknod: function(parent, name2, mode, dev) {
            return MEMFS.createNode(parent, name2, mode, dev);
          }, rename: function(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                for (var i in new_node.contents) {
                  throw new FS.ErrnoError(55);
                }
              }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            old_node.parent = new_dir;
          }, unlink: function(parent, name2) {
            delete parent.contents[name2];
          }, rmdir: function(parent, name2) {
            var node = FS.lookupNode(parent, name2);
            for (var i in node.contents) {
              throw new FS.ErrnoError(55);
            }
            delete parent.contents[name2];
          }, readdir: function(node) {
            var entries = [".", ".."];
            for (var key2 in node.contents) {
              if (!node.contents.hasOwnProperty(key2)) {
                continue;
              }
              entries.push(key2);
            }
            return entries;
          }, symlink: function(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node;
          }, readlink: function(node) {
            if (!FS.isLink(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            return node.link;
          } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes)
              return 0;
            var size = Math.min(stream.node.usedBytes - position, length);
            if (size > 8 && contents.subarray) {
              buffer2.set(contents.subarray(position, position + size), offset);
            } else {
              for (var i = 0; i < size; i++)
                buffer2[offset + i] = contents[position + i];
            }
            return size;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            if (buffer2.buffer === GROWABLE_HEAP_I8().buffer) {
              canOwn = false;
            }
            if (!length)
              return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
              if (canOwn) {
                node.contents = buffer2.subarray(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (node.usedBytes === 0 && position === 0) {
                node.contents = buffer2.slice(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (position + length <= node.usedBytes) {
                node.contents.set(buffer2.subarray(offset, offset + length), position);
                return length;
              }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer2.subarray) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
            } else {
              for (var i = 0; i < length; i++) {
                node.contents[position + i] = buffer2[offset + i];
              }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length;
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.usedBytes;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(28);
            }
            return position;
          }, allocate: function(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            assert(address === 0);
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && contents.buffer === buffer) {
              allocated = false;
              ptr = contents.byteOffset;
            } else {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              allocated = true;
              ptr = mmapAlloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              ptr >>>= 0;
              GROWABLE_HEAP_I8().set(contents, ptr);
            }
            return { ptr, allocated };
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (mmapFlags & 2) {
              return 0;
            }
            MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
            return 0;
          } } };
          var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
            path = PATH_FS.resolve(FS.cwd(), path);
            opts = opts || {};
            if (!path)
              return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            for (var key2 in defaults) {
              if (opts[key2] === void 0) {
                opts[key2] = defaults[key2];
              }
            }
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), false);
            var current = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, getPath: function(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path)
                  return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
              }
              path = path ? node.name + "/" + path : node.name;
              node = node.parent;
            }
          }, hashName: function(parentid, name2) {
            var hash = 0;
            for (var i = 0; i < name2.length; i++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, hashAddNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, hashRemoveNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, lookupNode: function(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          }, createNode: function(parent, name2, mode, rdev) {
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          }, destroyNode: function(node) {
            FS.hashRemoveNode(node);
          }, isRoot: function(node) {
            return node === node.parent;
          }, isMountpoint: function(node) {
            return !!node.mounted;
          }, isFile: function(mode) {
            return (mode & 61440) === 32768;
          }, isDir: function(mode) {
            return (mode & 61440) === 16384;
          }, isLink: function(mode) {
            return (mode & 61440) === 40960;
          }, isChrdev: function(mode) {
            return (mode & 61440) === 8192;
          }, isBlkdev: function(mode) {
            return (mode & 61440) === 24576;
          }, isFIFO: function(mode) {
            return (mode & 61440) === 4096;
          }, isSocket: function(mode) {
            return (mode & 49152) === 49152;
          }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
            var flags = FS.flagModes[str];
            if (typeof flags === "undefined") {
              throw new Error("Unknown file open mode: " + str);
            }
            return flags;
          }, flagsToPermissionString: function(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, nodePermissions: function(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
              return 2;
            } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
              return 2;
            } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          }, mayLookup: function(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          }, mayCreate: function(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, mayDelete: function(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          }, mayOpen: function(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
            fd_start = fd_start || 0;
            fd_end = fd_end || FS.MAX_OPEN_FDS;
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          }, getStream: function(fd) {
            return FS.streams[fd];
          }, createStream: function(stream, fd_start, fd_end) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
              };
              FS.FSStream.prototype = { object: { get: function() {
                return this.node;
              }, set: function(val) {
                this.node = val;
              } }, isRead: { get: function() {
                return (this.flags & 2097155) !== 1;
              } }, isWrite: { get: function() {
                return (this.flags & 2097155) !== 0;
              } }, isAppend: { get: function() {
                return this.flags & 1024;
              } } };
            }
            var newStream = new FS.FSStream();
            for (var p in stream) {
              newStream[p] = stream[p];
            }
            stream = newStream;
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          }, closeStream: function(fd) {
            FS.streams[fd] = null;
          }, chrdev_stream_ops: { open: function(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
          }, llseek: function() {
            throw new FS.ErrnoError(70);
          } }, major: function(dev) {
            return dev >> 8;
          }, minor: function(dev) {
            return dev & 255;
          }, makedev: function(ma, mi) {
            return ma << 8 | mi;
          }, registerDevice: function(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, getDevice: function(dev) {
            return FS.devices[dev];
          }, getMounts: function(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          }, syncfs: function(populate, callback) {
            if (typeof populate === "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach(function(mount) {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, mount: function(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = { type, opts, mountpoint, mounts: [] };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, unmount: function(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach(function(hash) {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.indexOf(current.mount) !== -1) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, lookup: function(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          }, mknod: function(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          }, create: function(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          }, mkdir: function(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          }, mkdirTree: function(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i])
                continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          }, mkdev: function(path, mode, dev) {
            if (typeof dev === "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          }, symlink: function(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, rename: function(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            try {
              if (FS.trackingDelegate["willMovePath"]) {
                FS.trackingDelegate["willMovePath"](old_path, new_path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
            try {
              if (FS.trackingDelegate["onMovePath"])
                FS.trackingDelegate["onMovePath"](old_path, new_path);
            } catch (e) {
              err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
          }, rmdir: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          }, unlink: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readlink: function(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          }, stat: function(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          }, lstat: function(path) {
            return FS.stat(path, true);
          }, chmod: function(path, mode, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
          }, lchmod: function(path, mode) {
            FS.chmod(path, mode, true);
          }, fchmod: function(fd, mode) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chmod(stream.node, mode);
          }, chown: function(path, uid, gid, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, lchown: function(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, fchown: function(fd, uid, gid) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chown(stream.node, uid, gid);
          }, truncate: function(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, ftruncate: function(fd, len) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          }, utime: function(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, open: function(path, flags, mode, fd_start, fd_end) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode === "undefined" ? 438 : mode;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path === "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512) {
              FS.truncate(node, 0);
            }
            flags &= ~(128 | 512 | 131072);
            var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles)
                FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                err("FS.trackingDelegate error on read file: " + path);
              }
            }
            try {
              if (FS.trackingDelegate["onOpenFile"]) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                  trackingFlags |= FS.tracking.openFlags.READ;
                }
                if ((flags & 2097155) !== 0) {
                  trackingFlags |= FS.tracking.openFlags.WRITE;
                }
                FS.trackingDelegate["onOpenFile"](path, trackingFlags);
              }
            } catch (e) {
              err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
            }
            return stream;
          }, close: function(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, isClosed: function(stream) {
            return stream.fd === null;
          }, llseek: function(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, read: function(stream, buffer2, offset, length, position) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            try {
              if (stream.path && FS.trackingDelegate["onWriteToFile"])
                FS.trackingDelegate["onWriteToFile"](stream.path);
            } catch (e) {
              err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
            }
            return bytesWritten;
          }, allocate: function(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            address >>>= 0;
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            offset >>>= 0;
            if (!stream || !stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
          }, munmap: function(stream) {
            return 0;
          }, ioctl: function(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, readFile: function(path, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, writeFile: function(path, data, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data === "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, cwd: function() {
            return FS.currentPath;
          }, chdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          }, createDefaultDirectories: function() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, createDefaultDevices: function() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), { read: function() {
              return 0;
            }, write: function(stream, buffer2, offset, length, pos) {
              return length;
            } });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var random_device = getRandomDevice();
            FS.createDevice("/dev", "random", random_device);
            FS.createDevice("/dev", "urandom", random_device);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, createSpecialDirectories: function() {
            FS.mkdir("/proc");
            FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({ mount: function() {
              var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
              node.node_ops = { lookup: function(parent, name2) {
                var fd = +name2;
                var stream = FS.getStream(fd);
                if (!stream)
                  throw new FS.ErrnoError(8);
                var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                  return stream.path;
                } } };
                ret.parent = ret;
                return ret;
              } };
              return node;
            } }, {}, "/proc/self/fd");
          }, createStandardStreams: function() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            FS.open("/dev/stdin", 0);
            FS.open("/dev/stdout", 1);
            FS.open("/dev/stderr", 1);
          }, ensureErrnoError: function() {
            if (FS.ErrnoError)
              return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach(function(code) {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          }, staticInit: function() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { "MEMFS": MEMFS };
          }, init: function(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          }, quit: function() {
            FS.init.initialized = false;
            var fflush = Module["_fflush"];
            if (fflush)
              fflush(0);
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, getMode: function(canRead, canWrite) {
            var mode = 0;
            if (canRead)
              mode |= 292 | 73;
            if (canWrite)
              mode |= 146;
            return mode;
          }, findObject: function(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (ret.exists) {
              return ret.object;
            } else {
              return null;
            }
          }, analyzePath: function(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, createPath: function(parent, path, canRead, canWrite) {
            parent = typeof parent === "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, createFile: function(parent, name2, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
            var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          }, createDevice: function(parent, name2, input, output) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major)
              FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, { open: function(stream) {
              stream.seekable = false;
            }, close: function(stream) {
              if (output && output.buffer && output.buffer.length) {
                output(10);
              }
            }, read: function(stream, buffer2, offset, length, pos) {
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = input();
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0)
                  break;
                bytesRead++;
                buffer2[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, write: function(stream, buffer2, offset, length, pos) {
              for (var i = 0; i < length; i++) {
                try {
                  output(buffer2[offset + i]);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            } });
            return FS.mkdev(path, mode, dev);
          }, forceLoadFile: function(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest !== "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing)
                chunkSize = datalength;
              var doXHR = function(from, to) {
                if (from > to)
                  throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1)
                  throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                if (typeof Uint8Array != "undefined")
                  xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                } else {
                  return intArrayFromString(xhr2.responseText || "", true);
                }
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest !== "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, { length: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              } }, chunkSize: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              } } });
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, { usedBytes: { get: function() {
              return this.contents.length;
            } } });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach(function(key2) {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
              FS.forceLoadFile(node);
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents.get(position + i);
                }
              }
              return size;
            };
            node.stream_ops = stream_ops;
            return node;
          }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
            Browser.init();
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            function processData(byteArray) {
              function finish(byteArray2) {
                if (preFinish)
                  preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                if (onload)
                  onload();
                removeRunDependency();
              }
              var handled = false;
              Module["preloadPlugins"].forEach(function(plugin) {
                if (handled)
                  return;
                if (plugin["canHandle"](fullname)) {
                  plugin["handle"](byteArray, fullname, finish, function() {
                    if (onerror)
                      onerror();
                    removeRunDependency();
                  });
                  handled = true;
                }
              });
              if (!handled)
                finish(byteArray);
            }
            addRunDependency();
            if (typeof url == "string") {
              Browser.asyncLoad(url, function(byteArray) {
                processData(byteArray);
              }, onerror);
            } else {
              processData(url);
            }
          }, indexedDB: function() {
            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
          }, DB_NAME: function() {
            return "EM_FS_" + window.location.pathname;
          }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
              out("creating db");
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            };
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                putRequest.onsuccess = function putRequest_onsuccess() {
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                putRequest.onerror = function putRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          }, loadFilesFromDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = function getRequest_onsuccess() {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                getRequest.onerror = function getRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          } };
          var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path) {
            if (path[0] !== "/") {
              var dir;
              if (dirfd === -100) {
                dir = FS.cwd();
              } else {
                var dirstream = FS.getStream(dirfd);
                if (!dirstream)
                  throw new FS.ErrnoError(8);
                dir = dirstream.path;
              }
              path = PATH.join2(dir, path);
            }
            return path;
          }, doStat: function(func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            GROWABLE_HEAP_I32()[buf >> 2] = stat.dev;
            GROWABLE_HEAP_I32()[buf + 4 >> 2] = 0;
            GROWABLE_HEAP_I32()[buf + 8 >> 2] = stat.ino;
            GROWABLE_HEAP_I32()[buf + 12 >> 2] = stat.mode;
            GROWABLE_HEAP_I32()[buf + 16 >> 2] = stat.nlink;
            GROWABLE_HEAP_I32()[buf + 20 >> 2] = stat.uid;
            GROWABLE_HEAP_I32()[buf + 24 >> 2] = stat.gid;
            GROWABLE_HEAP_I32()[buf + 28 >> 2] = stat.rdev;
            GROWABLE_HEAP_I32()[buf + 32 >> 2] = 0;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 40 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >> 2] = tempI64[1];
            GROWABLE_HEAP_I32()[buf + 48 >> 2] = 4096;
            GROWABLE_HEAP_I32()[buf + 52 >> 2] = stat.blocks;
            GROWABLE_HEAP_I32()[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
            GROWABLE_HEAP_I32()[buf + 60 >> 2] = 0;
            GROWABLE_HEAP_I32()[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
            GROWABLE_HEAP_I32()[buf + 68 >> 2] = 0;
            GROWABLE_HEAP_I32()[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
            GROWABLE_HEAP_I32()[buf + 76 >> 2] = 0;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 80 >> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 84 >> 2] = tempI64[1];
            return 0;
          }, doMsync: function(addr, stream, len, flags, offset) {
            var buffer2 = GROWABLE_HEAP_U8().slice(addr, addr + len);
            FS.msync(stream, buffer2, offset, len, flags);
          }, doMkdir: function(path, mode) {
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/")
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          }, doMknod: function(path, mode, dev) {
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path, mode, dev);
            return 0;
          }, doReadlink: function(path, buf, bufsize) {
            if (bufsize <= 0)
              return -28;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = GROWABLE_HEAP_I8()[buf + len];
            stringToUTF8(ret, buf, bufsize + 1);
            GROWABLE_HEAP_I8()[buf + len] = endChar;
            return len;
          }, doAccess: function(path, amode) {
            if (amode & ~7) {
              return -28;
            }
            var node;
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4)
              perms += "r";
            if (amode & 2)
              perms += "w";
            if (amode & 1)
              perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          }, doDup: function(path, flags, suggestFD) {
            var suggest = FS.getStream(suggestFD);
            if (suggest)
              FS.close(suggest);
            return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
          }, doReadv: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >> 2];
              var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >> 2];
              var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (curr < len)
                break;
            }
            return ret;
          }, doWritev: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >> 2];
              var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >> 2];
              var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
            }
            return ret;
          }, varargs: void 0, get: function() {
            SYSCALLS.varargs += 4;
            var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >> 2];
            return ret;
          }, getStr: function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }, getStreamFromFD: function(fd) {
            var stream = FS.getStream(fd);
            if (!stream)
              throw new FS.ErrnoError(8);
            return stream;
          }, get64: function(low, high) {
            return low;
          } };
          function ___sys_ioctl(fd, op, varargs) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(2, 1, fd, op, varargs);
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (op) {
                case 21509:
                case 21505: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21519: {
                  if (!stream.tty)
                    return -59;
                  var argp = SYSCALLS.get();
                  GROWABLE_HEAP_I32()[argp >> 2] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty)
                    return -59;
                  return -28;
                }
                case 21531: {
                  var argp = SYSCALLS.get();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21524: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                default:
                  abort("bad ioctl syscall " + op);
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          function ___sys_open(path, flags, varargs) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(3, 1, path, flags, varargs);
            SYSCALLS.varargs = varargs;
            try {
              var pathname = SYSCALLS.getStr(path);
              var mode = SYSCALLS.get();
              var stream = FS.open(pathname, flags, mode);
              return stream.fd;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          var tupleRegistrations = {};
          function runDestructors(destructors) {
            while (destructors.length) {
              var ptr = destructors.pop();
              var del = destructors.pop();
              del(ptr);
            }
          }
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](GROWABLE_HEAP_U32()[pointer >> 2]);
          }
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var char_0 = 48;
          var char_9 = 57;
          function makeLegalFunctionName(name2) {
            if (name2 === void 0) {
              return "_unknown";
            }
            name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name2.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return "_" + name2;
            } else {
              return name2;
            }
          }
          function createNamedFunction(name2, body) {
            name2 = makeLegalFunctionName(name2);
            return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
          }
          function extendError(baseErrorType, errorName) {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return this.name + ": " + this.message;
              }
            };
            return errorClass;
          }
          var InternalError = void 0;
          function throwInternalError(message) {
            throw new InternalError(message);
          }
          function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i = 0; i < myTypes.length; ++i) {
                registerType(myTypes[i], myTypeConverters[i]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach(function(dt, i) {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (unregisteredTypes.length === 0) {
              onComplete(typeConverters);
            }
          }
          function __embind_finalize_value_array(rawTupleType) {
            var reg = tupleRegistrations[rawTupleType];
            delete tupleRegistrations[rawTupleType];
            var elements = reg.elements;
            var elementsLength = elements.length;
            var elementTypes = elements.map(function(elt) {
              return elt.getterReturnType;
            }).concat(elements.map(function(elt) {
              return elt.setterArgumentType;
            }));
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
              elements.forEach(function(elt, i) {
                var getterReturnType = elementTypes2[i];
                var getter = elt.getter;
                var getterContext = elt.getterContext;
                var setterArgumentType = elementTypes2[i + elementsLength];
                var setter = elt.setter;
                var setterContext = elt.setterContext;
                elt.read = function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                };
                elt.write = function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = new Array(elementsLength);
                for (var i = 0; i < elementsLength; ++i) {
                  rv[i] = elements[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                if (elementsLength !== o.length) {
                  throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
                }
                var ptr = rawConstructor();
                for (var i = 0; i < elementsLength; ++i) {
                  elements[i].write(ptr, o[i]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          var structRegistrations = {};
          function __embind_finalize_value_object(structType) {
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map(function(field) {
              return field.getterReturnType;
            }).concat(fieldRecords.map(function(field) {
              return field.setterArgumentType;
            }));
            whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
              var fields = {};
              fieldRecords.forEach(function(field, i) {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = { read: function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                }, write: function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                } };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = {};
                for (var i in fields) {
                  rv[i] = fields[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError('Missing field:  "' + fieldName + '"');
                  }
                }
                var ptr = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          function getShiftFromSize(size) {
            switch (size) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + size);
            }
          }
          function embind_init_charCodes() {
            var codes = new Array(256);
            for (var i = 0; i < 256; ++i) {
              codes[i] = String.fromCharCode(i);
            }
            embind_charCodes = codes;
          }
          var embind_charCodes = void 0;
          function readLatin1String(ptr) {
            var ret = "";
            var c = ptr;
            while (GROWABLE_HEAP_U8()[c]) {
              ret += embind_charCodes[GROWABLE_HEAP_U8()[c++]];
            }
            return ret;
          }
          var BindingError = void 0;
          function throwBindingError(message) {
            throw new BindingError(message);
          }
          function registerType(rawType, registeredInstance, options) {
            options = options || {};
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            var name2 = registeredInstance.name;
            if (!rawType) {
              throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError("Cannot register type '" + name2 + "' twice");
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach(function(cb) {
                cb();
              });
            }
          }
          function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(wt) {
              return !!wt;
            }, "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
              var heap;
              if (size === 1) {
                heap = GROWABLE_HEAP_I8();
              } else if (size === 2) {
                heap = GROWABLE_HEAP_I16();
              } else if (size === 4) {
                heap = GROWABLE_HEAP_I32();
              } else {
                throw new TypeError("Unknown boolean type size: " + name2);
              }
              return this["fromWireType"](heap[pointer >>> shift]);
            }, destructorFunction: null });
          }
          function ClassHandle_isAliasOf(other) {
            if (!(this instanceof ClassHandle)) {
              return false;
            }
            if (!(other instanceof ClassHandle)) {
              return false;
            }
            var leftClass = this.$$.ptrType.registeredClass;
            var left = this.$$.ptr;
            var rightClass = other.$$.ptrType.registeredClass;
            var right = other.$$.ptr;
            while (leftClass.baseClass) {
              left = leftClass.upcast(left);
              leftClass = leftClass.baseClass;
            }
            while (rightClass.baseClass) {
              right = rightClass.upcast(right);
              rightClass = rightClass.baseClass;
            }
            return leftClass === rightClass && left === right;
          }
          function shallowCopyInternalPointer(o) {
            return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
          }
          function throwInstanceAlreadyDeleted(obj) {
            function getInstanceTypeName(handle) {
              return handle.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          }
          var finalizationGroup = false;
          function detachFinalizer(handle) {
          }
          function runDestructor($$) {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          }
          function releaseClassHandle($$) {
            $$.count.value -= 1;
            var toDelete = $$.count.value === 0;
            if (toDelete) {
              runDestructor($$);
            }
          }
          function attachFinalizer(handle) {
            if (typeof FinalizationGroup === "undefined") {
              attachFinalizer = function(handle2) {
                return handle2;
              };
              return handle;
            }
            finalizationGroup = new FinalizationGroup(function(iter) {
              for (var result = iter.next(); !result.done; result = iter.next()) {
                var $$ = result.value;
                if (!$$.ptr) {
                  console.warn("object already deleted: " + $$.ptr);
                } else {
                  releaseClassHandle($$);
                }
              }
            });
            attachFinalizer = function(handle2) {
              finalizationGroup.register(handle2, handle2.$$, handle2.$$);
              return handle2;
            };
            detachFinalizer = function(handle2) {
              finalizationGroup.unregister(handle2.$$);
            };
            return attachFinalizer(handle);
          }
          function ClassHandle_clone() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.preservePointerOnDelete) {
              this.$$.count.value += 1;
              return this;
            } else {
              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
              clone.$$.count.value += 1;
              clone.$$.deleteScheduled = false;
              return clone;
            }
          }
          function ClassHandle_delete() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            detachFinalizer(this);
            releaseClassHandle(this.$$);
            if (!this.$$.preservePointerOnDelete) {
              this.$$.smartPtr = void 0;
              this.$$.ptr = void 0;
            }
          }
          function ClassHandle_isDeleted() {
            return !this.$$.ptr;
          }
          var delayFunction = void 0;
          var deletionQueue = [];
          function flushPendingDeletes() {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          }
          function ClassHandle_deleteLater() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            deletionQueue.push(this);
            if (deletionQueue.length === 1 && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
            this.$$.deleteScheduled = true;
            return this;
          }
          function init_ClassHandle() {
            ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
            ClassHandle.prototype["clone"] = ClassHandle_clone;
            ClassHandle.prototype["delete"] = ClassHandle_delete;
            ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
            ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
          }
          function ClassHandle() {
          }
          var registeredPointers = {};
          function ensureOverloadTable(proto, methodName, humanName) {
            if (proto[methodName].overloadTable === void 0) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          }
          function exposePublicSymbol(name2, value, numArguments) {
            if (Module.hasOwnProperty(name2)) {
              if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
                throwBindingError("Cannot register public name '" + name2 + "' twice");
              }
              ensureOverloadTable(Module, name2, name2);
              if (Module.hasOwnProperty(numArguments)) {
                throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
              }
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              if (numArguments !== void 0) {
                Module[name2].numArguments = numArguments;
              }
            }
          }
          function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name2;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          function upcastPointer(ptr, ptrClass, desiredClass) {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
              }
              ptr = ptrClass.upcast(ptr);
              ptrClass = ptrClass.baseClass;
            }
            return ptr;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function genericPointerToWireType(destructors, handle) {
            var ptr;
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              if (this.isSmartPointer) {
                ptr = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
                return ptr;
              } else {
                return 0;
              }
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (!this.isConst && handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (handle.$$.smartPtr === void 0) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                  }
                  break;
                case 1:
                  ptr = handle.$$.smartPtr;
                  break;
                case 2:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    var clonedHandle = handle["clone"]();
                    ptr = this.rawShare(ptr, __emval_register(function() {
                      clonedHandle["delete"]();
                    }));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function RegisteredPointer_getPointee(ptr) {
            if (this.rawGetPointee) {
              ptr = this.rawGetPointee(ptr);
            }
            return ptr;
          }
          function RegisteredPointer_destructor(ptr) {
            if (this.rawDestructor) {
              this.rawDestructor(ptr);
            }
          }
          function RegisteredPointer_deleteObject(handle) {
            if (handle !== null) {
              handle["delete"]();
            }
          }
          function downcastPointer(ptr, ptrClass, desiredClass) {
            if (ptrClass === desiredClass) {
              return ptr;
            }
            if (desiredClass.baseClass === void 0) {
              return null;
            }
            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          }
          function getInheritedInstanceCount() {
            return Object.keys(registeredInstances).length;
          }
          function getLiveInheritedInstances() {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          }
          function setDelayFunction(fn) {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          }
          function init_embind() {
            Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module["flushPendingDeletes"] = flushPendingDeletes;
            Module["setDelayFunction"] = setDelayFunction;
          }
          var registeredInstances = {};
          function getBasestPointer(class_, ptr) {
            if (ptr === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr = class_.upcast(ptr);
              class_ = class_.baseClass;
            }
            return ptr;
          }
          function getInheritedInstance(class_, ptr) {
            ptr = getBasestPointer(class_, ptr);
            return registeredInstances[ptr];
          }
          function makeClassHandle(prototype, record) {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = { value: 1 };
            return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
          }
          function RegisteredPointer_fromWireType(ptr) {
            var rawPointer = this.getPointee(ptr);
            if (!rawPointer) {
              this.destructor(ptr);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (registeredInstance !== void 0) {
              if (registeredInstance.$$.count.value === 0) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
            }
          }
          function init_RegisteredPointer() {
            RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
            RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
            RegisteredPointer.prototype["argPackAdvance"] = 8;
            RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
            RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
            RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
          }
          function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name2;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          function replacePublicSymbol(name2, value, numArguments) {
            if (!Module.hasOwnProperty(name2)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              Module[name2].argCount = numArguments;
            }
          }
          function getDynCaller(sig, ptr) {
            assert(sig.indexOf("j") >= 0, "getDynCaller should only be called with i64 sigs");
            var argCache = [];
            return function() {
              argCache.length = arguments.length;
              for (var i = 0; i < arguments.length; i++) {
                argCache[i] = arguments[i];
              }
              return dynCall(sig, ptr, argCache);
            };
          }
          function embind__requireFunction(signature, rawFunction) {
            signature = readLatin1String(signature);
            function makeDynCaller() {
              if (signature.indexOf("j") != -1) {
                return getDynCaller(signature, rawFunction);
              }
              return wasmTable.get(rawFunction);
            }
            var fp = makeDynCaller();
            if (typeof fp !== "function") {
              throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
            }
            return fp;
          }
          var UnboundTypeError = void 0;
          function getTypeName(type) {
            var ptr = ___getTypeName(type);
            var rv = readLatin1String(ptr);
            _free(ptr);
            return rv;
          }
          function throwUnboundTypeError(message, types) {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
          }
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
            name2 = readLatin1String(name2);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            if (upcast) {
              upcast = embind__requireFunction(upcastSignature, upcast);
            }
            if (downcast) {
              downcast = embind__requireFunction(downcastSignature, downcast);
            }
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name2);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(legalFunctionName, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name2);
                }
                if (registeredClass.constructor_body === void 0) {
                  throw new BindingError(name2 + " has no accessible constructor");
                }
                var body = registeredClass.constructor_body[arguments.length];
                if (body === void 0) {
                  throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                }
                return body.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          function heap32VectorToArray(count, firstElement) {
            var array = [];
            for (var i = 0; i < count; i++) {
              array.push(GROWABLE_HEAP_I32()[(firstElement >> 2) + i]);
            }
            return array;
          }
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            assert(argCount > 0);
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            var args = [rawConstructor];
            var destructors = [];
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = "constructor " + classType.name;
              if (classType.registeredClass.constructor_body === void 0) {
                classType.registeredClass.constructor_body = [];
              }
              if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
                throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              }
              classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
                throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                    throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                  }
                  destructors.length = 0;
                  args.length = argCount;
                  for (var i = 1; i < argCount; ++i) {
                    args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                  }
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
                  return argTypes[0]["fromWireType"](ptr);
                };
                return [];
              });
              return [];
            });
          }
          function new_(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = false;
            for (var i = 1; i < argTypes.length; ++i) {
              if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
                needsDestructorStack = true;
                break;
              }
            }
            var returns = argTypes[0].name !== "void";
            var argsList = "";
            var argsListWired = "";
            for (var i = 0; i < argCount - 2; ++i) {
              argsList += (i !== 0 ? ", " : "") + "arg" + i;
              argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
            }
            var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
            }
            for (var i = 0; i < argCount - 2; ++i) {
              invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
              args1.push("argType" + i);
              args2.push(argTypes[i + 2]);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
                var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                  args1.push(paramName + "_dtor");
                  args2.push(argTypes[i].destructorFunction);
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
            }
            invokerFnBody += "}\n";
            args1.push(invokerFnBody);
            var invokerFunction = new_(Function, args1).apply(null, args2);
            return invokerFunction;
          }
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = classType.name + "." + methodName;
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
                if (proto[methodName].overloadTable === void 0) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          var emval_free_list = [];
          var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
          function __emval_decref(handle) {
            if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
              emval_handle_array[handle] = void 0;
              emval_free_list.push(handle);
            }
          }
          function count_emval_handles() {
            var count = 0;
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                ++count;
              }
            }
            return count;
          }
          function get_first_emval() {
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                return emval_handle_array[i];
              }
            }
            return null;
          }
          function init_emval() {
            Module["count_emval_handles"] = count_emval_handles;
            Module["get_first_emval"] = get_first_emval;
          }
          function __emval_register(value) {
            switch (value) {
              case void 0: {
                return 1;
              }
              case null: {
                return 2;
              }
              case true: {
                return 3;
              }
              case false: {
                return 4;
              }
              default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = { refcount: 1, value };
                return handle;
              }
            }
          }
          function __embind_register_emval(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
            }, "toWireType": function(destructors, value) {
              return __emval_register(value);
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
          }
          function enumReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return function(pointer) {
                  var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();
                  return this["fromWireType"](heap[pointer >>> 0]);
                };
              case 1:
                return function(pointer) {
                  var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();
                  return this["fromWireType"](heap[pointer >>> 1]);
                };
              case 2:
                return function(pointer) {
                  var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();
                  return this["fromWireType"](heap[pointer >>> 2]);
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_enum(rawType, name2, size, isSigned) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
              return this.constructor.values[c];
            }, "toWireType": function(destructors, c) {
              return c.value;
            }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
            exposePublicSymbol(name2, ctor);
          }
          function requireRegisteredType(rawType, humanName) {
            var impl = registeredTypes[rawType];
            if (impl === void 0) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          }
          function __embind_register_enum_value(rawEnumType, name2, enumValue) {
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name2 = readLatin1String(name2);
            var Enum = enumType.constructor;
            var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
            }) } });
            Enum.values[enumValue] = Value2;
            Enum[name2] = Value2;
          }
          function _embind_repr(v) {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          }
          function floatReadValueFromPointer(name2, shift) {
            switch (shift) {
              case 2:
                return function(pointer) {
                  return this["fromWireType"](GROWABLE_HEAP_F32()[pointer >> 2]);
                };
              case 3:
                return function(pointer) {
                  return this["fromWireType"](GROWABLE_HEAP_F64()[pointer >> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + name2);
            }
          }
          function __embind_register_float(rawType, name2, size) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              return value;
            }, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
            }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
          }
          function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            name2 = readLatin1String(name2);
            rawInvoker = embind__requireFunction(signature, rawInvoker);
            exposePublicSymbol(name2, function() {
              throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
            }, argCount - 1);
            whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
              var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
              replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
              return [];
            });
          }
          function integerReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return signed ? function readS8FromPointer(pointer) {
                  return GROWABLE_HEAP_I8()[pointer];
                } : function readU8FromPointer(pointer) {
                  return GROWABLE_HEAP_U8()[pointer];
                };
              case 1:
                return signed ? function readS16FromPointer(pointer) {
                  return GROWABLE_HEAP_I16()[pointer >> 1];
                } : function readU16FromPointer(pointer) {
                  return GROWABLE_HEAP_U16()[pointer >> 1];
                };
              case 2:
                return signed ? function readS32FromPointer(pointer) {
                  return GROWABLE_HEAP_I32()[pointer >> 2];
                } : function readU32FromPointer(pointer) {
                  return GROWABLE_HEAP_U32()[pointer >> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
            name2 = readLatin1String(name2);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var shift = getShiftFromSize(size);
            var fromWireType = function(value) {
              return value;
            };
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = function(value) {
                return value << bitshift >>> bitshift;
              };
            }
            var isUnsignedType = name2.indexOf("unsigned") != -1;
            registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
              }
              return isUnsignedType ? value >>> 0 : value | 0;
            }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
          }
          function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle) {
              handle = handle >> 2;
              var heap = GROWABLE_HEAP_U32();
              var size = heap[handle >>> 0];
              var data = heap[handle + 1 >>> 0];
              return new TA(buffer, data, size);
            }
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
          }
          function __embind_register_std_string(rawType, name2) {
            name2 = readLatin1String(name2);
            var stdStringIsUTF8 = name2 === "std::string";
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = GROWABLE_HEAP_U32()[value >> 2];
              var str;
              if (stdStringIsUTF8) {
                var decodeStartPtr = value + 4;
                for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = value + 4 + i;
                  if (i == length || GROWABLE_HEAP_U8()[currentBytePtr] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              } else {
                var a = new Array(length);
                for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[value + 4 + i]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var getLength;
              var valueIsOfTypeString = typeof value === "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function() {
                  return lengthBytesUTF8(value);
                };
              } else {
                getLength = function() {
                  return value.length;
                };
              }
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              ptr >>>= 0;
              GROWABLE_HEAP_U32()[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i = 0; i < length; ++i) {
                    var charCode = value.charCodeAt(i);
                    if (charCode > 255) {
                      _free(ptr);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    GROWABLE_HEAP_U8()[ptr + 4 + i] = charCode;
                  }
                } else {
                  for (var i = 0; i < length; ++i) {
                    GROWABLE_HEAP_U8()[ptr + 4 + i] = value[i];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_std_wstring(rawType, charSize, name2) {
            name2 = readLatin1String(name2);
            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
            if (charSize === 2) {
              decodeString = UTF16ToString;
              encodeString = stringToUTF16;
              lengthBytesUTF = lengthBytesUTF16;
              getHeap = function() {
                return GROWABLE_HEAP_U16();
              };
              shift = 1;
            } else if (charSize === 4) {
              decodeString = UTF32ToString;
              encodeString = stringToUTF32;
              lengthBytesUTF = lengthBytesUTF32;
              getHeap = function() {
                return GROWABLE_HEAP_U32();
              };
              shift = 2;
            }
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = GROWABLE_HEAP_U32()[value >> 2];
              var HEAP = getHeap();
              var str;
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i * charSize;
                if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (!(typeof value === "string")) {
                throwBindingError("Cannot pass non-string to C++ string type " + name2);
              }
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              ptr >>>= 0;
              GROWABLE_HEAP_U32()[ptr >> 2] = length >> shift;
              encodeString(value, ptr + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
          }
          function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
          }
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_void(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
              return void 0;
            }, "toWireType": function(destructors, o) {
              return void 0;
            } });
          }
          function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
            if (targetThreadId == mainThreadId) {
              postMessage({ "cmd": "processQueuedMainThreadWork" });
            } else if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "targetThread": targetThreadId, "cmd": "processThreadQueue" });
            } else {
              var pthread = PThread.pthreads[targetThreadId];
              var worker = pthread && pthread.worker;
              if (!worker) {
                return;
              }
              worker.postMessage({ "cmd": "processThreadQueue" });
            }
            return 1;
          }
          function requireHandle(handle) {
            if (!handle) {
              throwBindingError("Cannot use deleted val. handle = " + handle);
            }
            return emval_handle_array[handle].value;
          }
          function __emval_as(handle, returnType, destructorsRef) {
            handle = requireHandle(handle);
            returnType = requireRegisteredType(returnType, "emval::as");
            var destructors = [];
            var rd = __emval_register(destructors);
            GROWABLE_HEAP_I32()[destructorsRef >> 2] = rd;
            return returnType["toWireType"](destructors, handle);
          }
          function __emval_lookupTypes(argCount, argTypes) {
            var a = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              a[i] = requireRegisteredType(GROWABLE_HEAP_I32()[(argTypes >> 2) + i], "parameter " + i);
            }
            return a;
          }
          function __emval_call(handle, argCount, argTypes, argv) {
            handle = requireHandle(handle);
            var types = __emval_lookupTypes(argCount, argTypes);
            var args = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              var type = types[i];
              args[i] = type["readValueFromPointer"](argv);
              argv += type["argPackAdvance"];
            }
            var rv = handle.apply(void 0, args);
            return __emval_register(rv);
          }
          var emval_symbols = {};
          function getStringOrSymbol(address) {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            } else {
              return symbol;
            }
          }
          function emval_get_global() {
            if (typeof globalThis === "object") {
              return globalThis;
            }
            return function() {
              return Function;
            }()("return this")();
          }
          function __emval_get_global(name2) {
            if (name2 === 0) {
              return __emval_register(emval_get_global());
            } else {
              name2 = getStringOrSymbol(name2);
              return __emval_register(emval_get_global()[name2]);
            }
          }
          function __emval_get_property(handle, key2) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            return __emval_register(handle[key2]);
          }
          function __emval_incref(handle) {
            if (handle > 4) {
              emval_handle_array[handle].refcount += 1;
            }
          }
          function __emval_instanceof(object, constructor) {
            object = requireHandle(object);
            constructor = requireHandle(constructor);
            return object instanceof constructor;
          }
          function __emval_is_number(handle) {
            handle = requireHandle(handle);
            return typeof handle === "number";
          }
          function __emval_new_array() {
            return __emval_register([]);
          }
          function __emval_new_cstring(v) {
            return __emval_register(getStringOrSymbol(v));
          }
          function __emval_new_object() {
            return __emval_register({});
          }
          function __emval_run_destructors(handle) {
            var destructors = emval_handle_array[handle].value;
            runDestructors(destructors);
            __emval_decref(handle);
          }
          function __emval_set_property(handle, key2, value) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            value = requireHandle(value);
            handle[key2] = value;
          }
          function __emval_take_value(type, argv) {
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](argv);
            return __emval_register(v);
          }
          function _abort() {
            abort();
          }
          function _emscripten_asm_const_int(code, sigPtr, argbuf) {
            var args = readAsmConstArgs(sigPtr, argbuf);
            return ASM_CONSTS[code].apply(null, args);
          }
          function _emscripten_check_blocking_allowed() {
            if (ENVIRONMENT_IS_NODE)
              return;
            if (ENVIRONMENT_IS_WORKER)
              return;
            warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
          }
          function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
          }
          function _emscripten_futex_wait(addr, val, timeout) {
            if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
              return -28;
            if (!ENVIRONMENT_IS_WEB) {
              var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
              if (ret === "timed-out")
                return -73;
              if (ret === "not-equal")
                return -6;
              if (ret === "ok")
                return 0;
              throw "Atomics.wait returned an unexpected value " + ret;
            } else {
              if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                return -6;
              }
              var tNow = performance.now();
              var tEnd = tNow + timeout;
              var lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), PThread.mainThreadFutex >> 2, addr);
              while (1) {
                tNow = performance.now();
                if (tNow > tEnd) {
                  lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), PThread.mainThreadFutex >> 2, 0);
                  return -73;
                }
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), PThread.mainThreadFutex >> 2, 0);
                if (lastAddr == 0) {
                  break;
                }
                _emscripten_main_thread_process_queued_calls();
                if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                  return -6;
                }
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), PThread.mainThreadFutex >> 2, addr);
              }
              return 0;
            }
          }
          function _emscripten_is_main_browser_thread() {
            return __pthread_is_main_browser_thread | 0;
          }
          function _emscripten_is_main_runtime_thread() {
            return __pthread_is_main_runtime_thread | 0;
          }
          function _emscripten_memcpy_big(dest, src, num) {
            GROWABLE_HEAP_U8().copyWithin(dest, src, src + num);
          }
          function _emscripten_proxy_to_main_thread_js(index, sync) {
            var numCallArgs = arguments.length - 2;
            var stack = stackSave();
            var args = stackAlloc(numCallArgs * 8);
            var b = args >> 3;
            for (var i = 0; i < numCallArgs; i++) {
              GROWABLE_HEAP_F64()[b + i] = arguments[2 + i];
            }
            var ret = _emscripten_run_in_main_runtime_thread_js(index, numCallArgs, args, sync);
            stackRestore(stack);
            return ret;
          }
          var _emscripten_receive_on_main_thread_js_callArgs = [];
          var readAsmConstArgsArray = [];
          function readAsmConstArgs(sigPtr, buf) {
            readAsmConstArgsArray.length = 0;
            var ch;
            buf >>= 2;
            while (ch = GROWABLE_HEAP_U8()[sigPtr++]) {
              var double = ch < 105;
              if (double && buf & 1)
                buf++;
              readAsmConstArgsArray.push(double ? GROWABLE_HEAP_F64()[buf++ >> 1] : GROWABLE_HEAP_I32()[buf]);
              ++buf;
            }
            return readAsmConstArgsArray;
          }
          function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
            _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
            var b = args >> 3;
            for (var i = 0; i < numCallArgs; i++) {
              _emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i];
            }
            var isEmAsmConst = index < 0;
            var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
            return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
          }
          function _emscripten_get_heap_size() {
            return GROWABLE_HEAP_U8().length;
          }
          function emscripten_realloc_buffer(size) {
            try {
              wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
              updateGlobalBufferAndViews(wasmMemory.buffer);
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            requestedSize = requestedSize >>> 0;
            var oldSize = _emscripten_get_heap_size();
            if (requestedSize <= oldSize) {
              return false;
            }
            var maxHeapSize = 4294967296;
            if (requestedSize > maxHeapSize) {
              return false;
            }
            var minHeapSize = 16777216;
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));
              var replacement = emscripten_realloc_buffer(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          var JSEvents = { inEventHandler: 0, removeAllEventListeners: function() {
            for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
              JSEvents._removeHandler(i);
            }
            JSEvents.eventHandlers = [];
            JSEvents.deferredCalls = [];
          }, registerRemoveEventListeners: function() {
            if (!JSEvents.removeEventListenersRegistered) {
              JSEvents.removeEventListenersRegistered = true;
            }
          }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
            function arraysHaveEqualContent(arrA, arrB) {
              if (arrA.length != arrB.length)
                return false;
              for (var i2 in arrA) {
                if (arrA[i2] != arrB[i2])
                  return false;
              }
              return true;
            }
            for (var i in JSEvents.deferredCalls) {
              var call = JSEvents.deferredCalls[i];
              if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                return;
              }
            }
            JSEvents.deferredCalls.push({ targetFunction, precedence, argsList });
            JSEvents.deferredCalls.sort(function(x, y) {
              return x.precedence < y.precedence;
            });
          }, removeDeferredCalls: function(targetFunction) {
            for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
              if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
                JSEvents.deferredCalls.splice(i, 1);
                --i;
              }
            }
          }, canPerformEventHandlerRequests: function() {
            return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
          }, runDeferredCalls: function() {
            if (!JSEvents.canPerformEventHandlerRequests()) {
              return;
            }
            for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
              var call = JSEvents.deferredCalls[i];
              JSEvents.deferredCalls.splice(i, 1);
              --i;
              call.targetFunction.apply(null, call.argsList);
            }
          }, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
            for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
              if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
                JSEvents._removeHandler(i--);
              }
            }
          }, _removeHandler: function(i) {
            var h = JSEvents.eventHandlers[i];
            h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
            JSEvents.eventHandlers.splice(i, 1);
          }, registerOrRemoveHandler: function(eventHandler) {
            var jsEventHandler = function jsEventHandler2(event) {
              ++JSEvents.inEventHandler;
              JSEvents.currentEventHandler = eventHandler;
              JSEvents.runDeferredCalls();
              eventHandler.handlerFunc(event);
              JSEvents.runDeferredCalls();
              --JSEvents.inEventHandler;
            };
            if (eventHandler.callbackfunc) {
              eventHandler.eventListenerFunc = jsEventHandler;
              eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
              JSEvents.eventHandlers.push(eventHandler);
              JSEvents.registerRemoveEventListeners();
            } else {
              for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
                if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
                  JSEvents._removeHandler(i--);
                }
              }
            }
          }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
            var stackTop = stackSave();
            var varargs = stackAlloc(12);
            GROWABLE_HEAP_I32()[varargs >> 2] = eventTypeId;
            GROWABLE_HEAP_I32()[varargs + 4 >> 2] = eventData;
            GROWABLE_HEAP_I32()[varargs + 8 >> 2] = userData;
            __emscripten_call_on_thread(0, targetThread, 637534208, eventHandlerFunc, eventData, varargs);
            stackRestore(stackTop);
          }, getTargetThreadForEventCallback: function(targetThread) {
            switch (targetThread) {
              case 1:
                return 0;
              case 2:
                return PThread.currentProxiedOperationCallerThread;
              default:
                return targetThread;
            }
          }, getNodeNameForTarget: function(target) {
            if (!target)
              return "";
            if (target == window)
              return "#window";
            if (target == screen)
              return "#screen";
            return target && target.nodeName ? target.nodeName : "";
          }, fullscreenEnabled: function() {
            return document.fullscreenEnabled || document.webkitFullscreenEnabled;
          } };
          function stringToNewUTF8(jsString) {
            var length = lengthBytesUTF8(jsString) + 1;
            var cString = _malloc(length);
            stringToUTF8(jsString, cString, length);
            return cString;
          }
          function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
            var stackTop = stackSave();
            var varargs = stackAlloc(12);
            var targetCanvasPtr = 0;
            if (targetCanvas) {
              targetCanvasPtr = stringToNewUTF8(targetCanvas);
            }
            GROWABLE_HEAP_I32()[varargs >> 2] = targetCanvasPtr;
            GROWABLE_HEAP_I32()[varargs + 4 >> 2] = width;
            GROWABLE_HEAP_I32()[varargs + 8 >> 2] = height;
            __emscripten_call_on_thread(0, targetThread, 657457152, 0, targetCanvasPtr, varargs);
            stackRestore(stackTop);
          }
          function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
            targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
            _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
          }
          function maybeCStringToJsString(cString) {
            return cString > 2 ? UTF8ToString(cString) : cString;
          }
          var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
          function findEventTarget(target) {
            target = maybeCStringToJsString(target);
            var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
            return domElement;
          }
          function findCanvasEventTarget(target) {
            return findEventTarget(target);
          }
          function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (!canvas)
              return -4;
            if (canvas.canvasSharedPtr) {
              GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >> 2] = width;
              GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >> 2] = height;
            }
            if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
              if (canvas.offscreenCanvas)
                canvas = canvas.offscreenCanvas;
              var autoResizeViewport = false;
              if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
                var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
                autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
              }
              canvas.width = width;
              canvas.height = height;
              if (autoResizeViewport) {
                canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
              }
            } else if (canvas.canvasSharedPtr) {
              var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >> 2];
              _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
              return 1;
            } else {
              return -4;
            }
            return 0;
          }
          function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(4, 1, target, width, height);
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
          }
          function _emscripten_set_canvas_element_size(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (canvas) {
              return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
            } else {
              return _emscripten_set_canvas_element_size_main_thread(target, width, height);
            }
          }
          function _emscripten_set_current_thread_status(newStatus) {
          }
          function __webgl_enable_ANGLE_instanced_arrays(ctx) {
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
              ctx["vertexAttribDivisor"] = function(index, divisor) {
                ext["vertexAttribDivisorANGLE"](index, divisor);
              };
              ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
                ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
              };
              ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
                ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
              };
              return 1;
            }
          }
          function __webgl_enable_OES_vertex_array_object(ctx) {
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
              ctx["createVertexArray"] = function() {
                return ext["createVertexArrayOES"]();
              };
              ctx["deleteVertexArray"] = function(vao) {
                ext["deleteVertexArrayOES"](vao);
              };
              ctx["bindVertexArray"] = function(vao) {
                ext["bindVertexArrayOES"](vao);
              };
              ctx["isVertexArray"] = function(vao) {
                return ext["isVertexArrayOES"](vao);
              };
              return 1;
            }
          }
          function __webgl_enable_WEBGL_draw_buffers(ctx) {
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
              ctx["drawBuffers"] = function(n, bufs) {
                ext["drawBuffersWEBGL"](n, bufs);
              };
              return 1;
            }
          }
          function __webgl_enable_WEBGL_multi_draw(ctx) {
            return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
          }
          var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], uniforms: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, timerQueriesEXT: [], programInfos: {}, stringCache: {}, unpackAlignment: 4, recordError: function recordError(errorCode) {
            if (!GL.lastError) {
              GL.lastError = errorCode;
            }
          }, getNewId: function(table) {
            var ret = GL.counter++;
            for (var i = table.length; i < ret; i++) {
              table[i] = null;
            }
            return ret;
          }, getSource: function(shader, count, string, length) {
            var source = "";
            for (var i = 0; i < count; ++i) {
              var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >> 2] : -1;
              source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >> 2], len < 0 ? void 0 : len);
            }
            return source;
          }, createContext: function(canvas, webGLContextAttributes) {
            var ctx = canvas.getContext("webgl", webGLContextAttributes);
            if (!ctx)
              return 0;
            var handle = GL.registerContext(ctx, webGLContextAttributes);
            return handle;
          }, registerContext: function(ctx, webGLContextAttributes) {
            var handle = _malloc(8);
            GROWABLE_HEAP_I32()[handle + 4 >> 2] = _pthread_self();
            var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
            if (ctx.canvas)
              ctx.canvas.GLctxObject = context;
            GL.contexts[handle] = context;
            if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
              GL.initExtensions(context);
            }
            return handle;
          }, makeContextCurrent: function(contextHandle) {
            GL.currentContext = GL.contexts[contextHandle];
            Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
            return !(contextHandle && !GLctx);
          }, getContext: function(contextHandle) {
            return GL.contexts[contextHandle];
          }, deleteContext: function(contextHandle) {
            if (GL.currentContext === GL.contexts[contextHandle])
              GL.currentContext = null;
            if (typeof JSEvents === "object")
              JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
            if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
              GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
            _free(GL.contexts[contextHandle].handle);
            GL.contexts[contextHandle] = null;
          }, initExtensions: function(context) {
            if (!context)
              context = GL.currentContext;
            if (context.initExtensionsDone)
              return;
            context.initExtensionsDone = true;
            var GLctx2 = context.GLctx;
            __webgl_enable_ANGLE_instanced_arrays(GLctx2);
            __webgl_enable_OES_vertex_array_object(GLctx2);
            __webgl_enable_WEBGL_draw_buffers(GLctx2);
            GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
            __webgl_enable_WEBGL_multi_draw(GLctx2);
            var automaticallyEnabledExtensions = ["OES_texture_float", "OES_texture_half_float", "OES_standard_derivatives", "OES_vertex_array_object", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture", "OES_element_index_uint", "EXT_texture_filter_anisotropic", "EXT_frag_depth", "WEBGL_draw_buffers", "ANGLE_instanced_arrays", "OES_texture_float_linear", "OES_texture_half_float_linear", "EXT_blend_minmax", "EXT_shader_texture_lod", "EXT_texture_norm16", "WEBGL_compressed_texture_pvrtc", "EXT_color_buffer_half_float", "WEBGL_color_buffer_float", "EXT_sRGB", "WEBGL_compressed_texture_etc1", "EXT_disjoint_timer_query", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_astc", "EXT_color_buffer_float", "WEBGL_compressed_texture_s3tc_srgb", "EXT_disjoint_timer_query_webgl2", "WEBKIT_WEBGL_compressed_texture_pvrtc"];
            var exts = GLctx2.getSupportedExtensions() || [];
            exts.forEach(function(ext) {
              if (automaticallyEnabledExtensions.indexOf(ext) != -1) {
                GLctx2.getExtension(ext);
              }
            });
          }, populateUniformTable: function(program) {
            var p = GL.programs[program];
            var ptable = GL.programInfos[program] = { uniforms: {}, maxUniformLength: 0, maxAttributeLength: -1, maxUniformBlockNameLength: -1 };
            var utable = ptable.uniforms;
            var numUniforms = GLctx.getProgramParameter(p, 35718);
            for (var i = 0; i < numUniforms; ++i) {
              var u = GLctx.getActiveUniform(p, i);
              var name2 = u.name;
              ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name2.length + 1);
              if (name2.slice(-1) == "]") {
                name2 = name2.slice(0, name2.lastIndexOf("["));
              }
              var loc = GLctx.getUniformLocation(p, name2);
              if (loc) {
                var id = GL.getNewId(GL.uniforms);
                utable[name2] = [u.size, id];
                GL.uniforms[id] = loc;
                for (var j = 1; j < u.size; ++j) {
                  var n = name2 + "[" + j + "]";
                  loc = GLctx.getUniformLocation(p, n);
                  id = GL.getNewId(GL.uniforms);
                  GL.uniforms[id] = loc;
                }
              }
            }
          } };
          var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
          function _emscripten_webgl_do_create_context(target, attributes) {
            var a = attributes >> 2;
            var powerPreference = GROWABLE_HEAP_I32()[a + (24 >> 2)];
            var contextAttributes = { "alpha": !!GROWABLE_HEAP_I32()[a + (0 >> 2)], "depth": !!GROWABLE_HEAP_I32()[a + (4 >> 2)], "stencil": !!GROWABLE_HEAP_I32()[a + (8 >> 2)], "antialias": !!GROWABLE_HEAP_I32()[a + (12 >> 2)], "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a + (16 >> 2)], "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a + (20 >> 2)], "powerPreference": __emscripten_webgl_power_preferences[powerPreference], "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a + (28 >> 2)], majorVersion: GROWABLE_HEAP_I32()[a + (32 >> 2)], minorVersion: GROWABLE_HEAP_I32()[a + (36 >> 2)], enableExtensionsByDefault: GROWABLE_HEAP_I32()[a + (40 >> 2)], explicitSwapControl: GROWABLE_HEAP_I32()[a + (44 >> 2)], proxyContextToMainThread: GROWABLE_HEAP_I32()[a + (48 >> 2)], renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a + (52 >> 2)] };
            var canvas = findCanvasEventTarget(target);
            if (!canvas) {
              return 0;
            }
            if (contextAttributes.explicitSwapControl) {
              return 0;
            }
            var contextHandle = GL.createContext(canvas, contextAttributes);
            return contextHandle;
          }
          function _emscripten_webgl_create_context(a0, a1) {
            return _emscripten_webgl_do_create_context(a0, a1);
          }
          var ENV = {};
          function getExecutableName() {
            return thisProgram || "./this.program";
          }
          function getEnvStrings() {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
              for (var x in ENV) {
                env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(x + "=" + env[x]);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          }
          function _environ_get(__environ, environ_buf) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(5, 1, __environ, environ_buf);
            try {
              var bufSize = 0;
              getEnvStrings().forEach(function(string, i) {
                var ptr = environ_buf + bufSize;
                GROWABLE_HEAP_I32()[__environ + i * 4 >> 2] = ptr;
                writeAsciiToMemory(string, ptr);
                bufSize += string.length + 1;
              });
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _environ_sizes_get(penviron_count, penviron_buf_size) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(6, 1, penviron_count, penviron_buf_size);
            try {
              var strings = getEnvStrings();
              GROWABLE_HEAP_I32()[penviron_count >> 2] = strings.length;
              var bufSize = 0;
              strings.forEach(function(string) {
                bufSize += string.length + 1;
              });
              GROWABLE_HEAP_I32()[penviron_buf_size >> 2] = bufSize;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_close(fd) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(7, 1, fd);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_read(fd, iov, iovcnt, pnum) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(8, 1, fd, iov, iovcnt, pnum);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doReadv(stream, iov, iovcnt);
              GROWABLE_HEAP_I32()[pnum >> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(9, 1, fd, offset_low, offset_high, whence, newOffset);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -61;
              }
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[newOffset >> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_write(fd, iov, iovcnt, pnum) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(10, 1, fd, iov, iovcnt, pnum);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doWritev(stream, iov, iovcnt);
              GROWABLE_HEAP_I32()[pnum >> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _pthread_cleanup_push(routine, arg) {
            PThread.threadExitHandlers.push(function() {
              wasmTable.get(routine)(arg);
            });
          }
          function spawnThread(threadParams) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! spawnThread() can only ever be called from main application thread!";
            var worker = PThread.getNewWorker();
            if (worker.pthread !== void 0)
              throw "Internal error!";
            if (!threadParams.pthread_ptr)
              throw "Internal error, no pthread ptr!";
            PThread.runningWorkers.push(worker);
            var tlsMemory = _malloc(128 * 4);
            for (var i = 0; i < 128; ++i) {
              GROWABLE_HEAP_I32()[tlsMemory + i * 4 >> 2] = 0;
            }
            var stackHigh = threadParams.stackBase + threadParams.stackSize;
            var pthread = PThread.pthreads[threadParams.pthread_ptr] = { worker, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, thread: threadParams.pthread_ptr, threadInfoStruct: threadParams.pthread_ptr };
            var tis = pthread.threadInfoStruct >> 2;
            Atomics.store(GROWABLE_HEAP_U32(), tis + (0 >> 2), 0);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (4 >> 2), 0);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (8 >> 2), 0);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (68 >> 2), threadParams.detached);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), tlsMemory);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (48 >> 2), 0);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (44 >> 2), 42);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (108 >> 2), threadParams.stackSize);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (84 >> 2), threadParams.stackSize);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), stackHigh);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 8 >> 2), stackHigh);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 12 >> 2), threadParams.detached);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 20 >> 2), threadParams.schedPolicy);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 24 >> 2), threadParams.schedPrio);
            var global_libc = _emscripten_get_global_libc();
            var global_locale = global_libc + 40;
            Atomics.store(GROWABLE_HEAP_U32(), tis + (176 >> 2), global_locale);
            worker.pthread = pthread;
            var msg = { "cmd": "run", "start_routine": threadParams.startRoutine, "arg": threadParams.arg, "threadInfoStruct": threadParams.pthread_ptr, "selfThreadId": threadParams.pthread_ptr, "parentThreadId": threadParams.parent_pthread_ptr, "stackBase": threadParams.stackBase, "stackSize": threadParams.stackSize };
            worker.runPthread = function() {
              msg.time = performance.now();
              worker.postMessage(msg, threadParams.transferList);
            };
            if (worker.loaded) {
              worker.runPthread();
              delete worker.runPthread;
            }
          }
          function _pthread_getschedparam(thread, policy, schedparam) {
            if (!policy && !schedparam)
              return ERRNO_CODES.EINVAL;
            if (!thread) {
              err("pthread_getschedparam called with a null thread pointer!");
              return ERRNO_CODES.ESRCH;
            }
            var self2 = GROWABLE_HEAP_I32()[thread + 12 >> 2];
            if (self2 !== thread) {
              err("pthread_getschedparam attempted on thread " + thread + ", which does not point to a valid thread, or does not exist anymore!");
              return ERRNO_CODES.ESRCH;
            }
            var schedPolicy = Atomics.load(GROWABLE_HEAP_U32(), thread + 108 + 20 >> 2);
            var schedPrio = Atomics.load(GROWABLE_HEAP_U32(), thread + 108 + 24 >> 2);
            if (policy)
              GROWABLE_HEAP_I32()[policy >> 2] = schedPolicy;
            if (schedparam)
              GROWABLE_HEAP_I32()[schedparam >> 2] = schedPrio;
            return 0;
          }
          function _pthread_self() {
            return __pthread_ptr | 0;
          }
          Module["_pthread_self"] = _pthread_self;
          function _pthread_create(pthread_ptr, attr, start_routine, arg) {
            if (typeof SharedArrayBuffer === "undefined") {
              err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
              return 6;
            }
            if (!pthread_ptr) {
              err("pthread_create called with a null thread pointer!");
              return 28;
            }
            var transferList = [];
            var error = 0;
            if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
              return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
            }
            var stackSize = 0;
            var stackBase = 0;
            var detached = 0;
            var schedPolicy = 0;
            var schedPrio = 0;
            if (attr) {
              stackSize = GROWABLE_HEAP_I32()[attr >> 2];
              stackSize += 81920;
              stackBase = GROWABLE_HEAP_I32()[attr + 8 >> 2];
              detached = GROWABLE_HEAP_I32()[attr + 12 >> 2] !== 0;
              var inheritSched = GROWABLE_HEAP_I32()[attr + 16 >> 2] === 0;
              if (inheritSched) {
                var prevSchedPolicy = GROWABLE_HEAP_I32()[attr + 20 >> 2];
                var prevSchedPrio = GROWABLE_HEAP_I32()[attr + 24 >> 2];
                var parentThreadPtr = PThread.currentProxiedOperationCallerThread ? PThread.currentProxiedOperationCallerThread : _pthread_self();
                _pthread_getschedparam(parentThreadPtr, attr + 20, attr + 24);
                schedPolicy = GROWABLE_HEAP_I32()[attr + 20 >> 2];
                schedPrio = GROWABLE_HEAP_I32()[attr + 24 >> 2];
                GROWABLE_HEAP_I32()[attr + 20 >> 2] = prevSchedPolicy;
                GROWABLE_HEAP_I32()[attr + 24 >> 2] = prevSchedPrio;
              } else {
                schedPolicy = GROWABLE_HEAP_I32()[attr + 20 >> 2];
                schedPrio = GROWABLE_HEAP_I32()[attr + 24 >> 2];
              }
            } else {
              stackSize = 2097152;
            }
            var allocatedOwnStack = stackBase == 0;
            if (allocatedOwnStack) {
              stackBase = _memalign(16, stackSize);
            } else {
              stackBase -= stackSize;
              assert(stackBase > 0);
            }
            var threadInfoStruct2 = _malloc(232);
            for (var i = 0; i < 232 >> 2; ++i)
              GROWABLE_HEAP_U32()[(threadInfoStruct2 >> 2) + i] = 0;
            GROWABLE_HEAP_I32()[pthread_ptr >> 2] = threadInfoStruct2;
            GROWABLE_HEAP_I32()[threadInfoStruct2 + 12 >> 2] = threadInfoStruct2;
            var headPtr = threadInfoStruct2 + 156;
            GROWABLE_HEAP_I32()[headPtr >> 2] = headPtr;
            var threadParams = { stackBase, stackSize, allocatedOwnStack, schedPolicy, schedPrio, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct2, parent_pthread_ptr: _pthread_self(), arg, transferList };
            if (ENVIRONMENT_IS_PTHREAD) {
              threadParams.cmd = "spawnThread";
              postMessage(threadParams, transferList);
            } else {
              spawnThread(threadParams);
            }
            return 0;
          }
          function _setTempRet0($i) {
          }
          function __isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          function __arraySum(array, index) {
            var sum = 0;
            for (var i = 0; i <= index; sum += array[i++]) {
            }
            return sum;
          }
          var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function __addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = __isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >> 2];
            var date = { tm_sec: GROWABLE_HEAP_I32()[tm >> 2], tm_min: GROWABLE_HEAP_I32()[tm + 4 >> 2], tm_hour: GROWABLE_HEAP_I32()[tm + 8 >> 2], tm_mday: GROWABLE_HEAP_I32()[tm + 12 >> 2], tm_mon: GROWABLE_HEAP_I32()[tm + 16 >> 2], tm_year: GROWABLE_HEAP_I32()[tm + 20 >> 2], tm_wday: GROWABLE_HEAP_I32()[tm + 24 >> 2], tm_yday: GROWABLE_HEAP_I32()[tm + 28 >> 2], tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >> 2], tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value === "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                } else {
                  return thisDate.getFullYear();
                }
              } else {
                return thisDate.getFullYear() - 1;
              }
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              } else {
                return "PM";
              }
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var janFirst = new Date(date2.tm_year + 1900, 0, 1);
              var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstSunday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
            }, "%V": function(date2) {
              var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
              var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
                return "53";
              }
              if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
                return "01";
              }
              var daysDifference;
              if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
                daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
              } else {
                daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
              }
              return leadingNulls(Math.ceil(daysDifference / 7), 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var janFirst = new Date(date2.tm_year, 0, 1);
              var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstMonday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.indexOf(rule) >= 0) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm) {
            return _strftime(s, maxsize, format, tm);
          }
          if (!ENVIRONMENT_IS_PTHREAD)
            PThread.initMainThreadBlock();
          var FSNode = function(parent, name2, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name2;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, { read: { get: function() {
            return (this.mode & readMode) === readMode;
          }, set: function(val) {
            val ? this.mode |= readMode : this.mode &= ~readMode;
          } }, write: { get: function() {
            return (this.mode & writeMode) === writeMode;
          }, set: function(val) {
            val ? this.mode |= writeMode : this.mode &= ~writeMode;
          } }, isFolder: { get: function() {
            return FS.isDir(this.mode);
          } }, isDevice: { get: function() {
            return FS.isChrdev(this.mode);
          } } });
          FS.FSNode = FSNode;
          FS.staticInit();
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          InternalError = Module["InternalError"] = extendError(Error, "InternalError");
          embind_init_charCodes();
          BindingError = Module["BindingError"] = extendError(Error, "BindingError");
          init_ClassHandle();
          init_RegisteredPointer();
          init_embind();
          UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          init_emval();
          var GLctx;
          var proxiedFunctionTable = [null, _atexit, ___sys_ioctl, ___sys_open, _emscripten_set_canvas_element_size_main_thread, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write];
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          if (!ENVIRONMENT_IS_PTHREAD)
            __ATINIT__.push({ func: function() {
              ___wasm_call_ctors();
            } });
          var asmLibraryArg = { "p": ___assert_fail, "H": ___cxa_allocate_exception, "G": ___cxa_throw, "ha": ___sys_ioctl, "ia": ___sys_open, "na": __embind_finalize_value_array, "w": __embind_finalize_value_object, "ka": __embind_register_bool, "z": __embind_register_class, "y": __embind_register_class_constructor, "e": __embind_register_class_function, "ja": __embind_register_emval, "ma": __embind_register_enum, "E": __embind_register_enum_value, "N": __embind_register_float, "i": __embind_register_function, "u": __embind_register_integer, "q": __embind_register_memory_view, "O": __embind_register_std_string, "F": __embind_register_std_wstring, "oa": __embind_register_value_array, "l": __embind_register_value_array_element, "x": __embind_register_value_object, "h": __embind_register_value_object_field, "la": __embind_register_void, "$": __emscripten_notify_thread_queue, "s": __emval_as, "P": __emval_call, "b": __emval_decref, "Z": __emval_get_global, "t": __emval_get_property, "o": __emval_incref, "ba": __emval_instanceof, "Q": __emval_is_number, "I": __emval_new_array, "j": __emval_new_cstring, "A": __emval_new_object, "r": __emval_run_destructors, "m": __emval_set_property, "g": __emval_take_value, "K": _abort, "fa": _clock_gettime, "B": _emscripten_asm_const_int, "aa": _emscripten_check_blocking_allowed, "J": _emscripten_conditional_set_current_thread_status, "k": _emscripten_futex_wait, "n": _emscripten_futex_wake, "d": _emscripten_get_now, "D": _emscripten_is_main_browser_thread, "C": _emscripten_is_main_runtime_thread, "U": _emscripten_memcpy_big, "W": _emscripten_receive_on_main_thread_js, "v": _emscripten_resize_heap, "X": _emscripten_set_canvas_element_size, "f": _emscripten_set_current_thread_status, "Y": _emscripten_webgl_create_context, "da": _environ_get, "ea": _environ_sizes_get, "M": _fd_close, "ga": _fd_read, "R": _fd_seek, "L": _fd_write, "T": initPthreadsJS, "a": wasmMemory || Module["wasmMemory"], "V": _pthread_cleanup_push, "_": _pthread_create, "c": _pthread_self, "S": _setTempRet0, "ca": _strftime_l };
          createWasm();
          var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
            return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["qa"]).apply(null, arguments);
          };
          Module["_main"] = function() {
            return (Module["_main"] = Module["asm"]["ra"]).apply(null, arguments);
          };
          var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["sa"]).apply(null, arguments);
          };
          var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["ta"]).apply(null, arguments);
          };
          var ___getTypeName = Module["___getTypeName"] = function() {
            return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ua"]).apply(null, arguments);
          };
          Module["___embind_register_native_and_builtin_types"] = function() {
            return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["va"]).apply(null, arguments);
          };
          var ___errno_location = Module["___errno_location"] = function() {
            return (___errno_location = Module["___errno_location"] = Module["asm"]["wa"]).apply(null, arguments);
          };
          var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
            return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["xa"]).apply(null, arguments);
          };
          Module["___em_js__initPthreadsJS"] = function() {
            return (Module["___em_js__initPthreadsJS"] = Module["asm"]["ya"]).apply(null, arguments);
          };
          var stackSave = Module["stackSave"] = function() {
            return (stackSave = Module["stackSave"] = Module["asm"]["za"]).apply(null, arguments);
          };
          var stackRestore = Module["stackRestore"] = function() {
            return (stackRestore = Module["stackRestore"] = Module["asm"]["Aa"]).apply(null, arguments);
          };
          var stackAlloc = Module["stackAlloc"] = function() {
            return (stackAlloc = Module["stackAlloc"] = Module["asm"]["Ba"]).apply(null, arguments);
          };
          var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
            return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["Ca"]).apply(null, arguments);
          };
          var _memalign = Module["_memalign"] = function() {
            return (_memalign = Module["_memalign"] = Module["asm"]["Da"]).apply(null, arguments);
          };
          Module["_emscripten_main_browser_thread_id"] = function() {
            return (Module["_emscripten_main_browser_thread_id"] = Module["asm"]["Ea"]).apply(null, arguments);
          };
          var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
            return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["Fa"]).apply(null, arguments);
          };
          var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
            return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["Ga"]).apply(null, arguments);
          };
          Module["_emscripten_current_thread_process_queued_calls"] = function() {
            return (Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["Ha"]).apply(null, arguments);
          };
          var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
            return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["Ia"]).apply(null, arguments);
          };
          var _do_emscripten_dispatch_to_thread = Module["_do_emscripten_dispatch_to_thread"] = function() {
            return (_do_emscripten_dispatch_to_thread = Module["_do_emscripten_dispatch_to_thread"] = Module["asm"]["Ja"]).apply(null, arguments);
          };
          Module["_emscripten_async_run_in_main_thread"] = function() {
            return (Module["_emscripten_async_run_in_main_thread"] = Module["asm"]["Ka"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread"] = Module["asm"]["La"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_0"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_0"] = Module["asm"]["Ma"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_1"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_1"] = Module["asm"]["Na"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_2"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_2"] = Module["asm"]["Oa"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_xprintf_varargs"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_xprintf_varargs"] = Module["asm"]["Pa"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_3"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_3"] = Module["asm"]["Qa"]).apply(null, arguments);
          };
          var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
            return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["Ra"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_5"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_5"] = Module["asm"]["Sa"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_6"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_6"] = Module["asm"]["Ta"]).apply(null, arguments);
          };
          Module["_emscripten_sync_run_in_main_thread_7"] = function() {
            return (Module["_emscripten_sync_run_in_main_thread_7"] = Module["asm"]["Ua"]).apply(null, arguments);
          };
          var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
            return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["Va"]).apply(null, arguments);
          };
          var __emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = function() {
            return (__emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = Module["asm"]["Wa"]).apply(null, arguments);
          };
          Module["_emscripten_tls_init"] = function() {
            return (Module["_emscripten_tls_init"] = Module["asm"]["Xa"]).apply(null, arguments);
          };
          Module["dynCall_jiji"] = function() {
            return (Module["dynCall_jiji"] = Module["asm"]["Ya"]).apply(null, arguments);
          };
          Module["dynCall_viijii"] = function() {
            return (Module["dynCall_viijii"] = Module["asm"]["Za"]).apply(null, arguments);
          };
          Module["dynCall_iiiiiijj"] = function() {
            return (Module["dynCall_iiiiiijj"] = Module["asm"]["_a"]).apply(null, arguments);
          };
          Module["dynCall_iiiiij"] = function() {
            return (Module["dynCall_iiiiij"] = Module["asm"]["$a"]).apply(null, arguments);
          };
          Module["dynCall_iiiiijj"] = function() {
            return (Module["dynCall_iiiiijj"] = Module["asm"]["ab"]).apply(null, arguments);
          };
          var _main_thread_futex = Module["_main_thread_futex"] = 51928;
          Module["addRunDependency"] = addRunDependency;
          Module["removeRunDependency"] = removeRunDependency;
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          Module["FS"] = FS;
          Module["PThread"] = PThread;
          Module["PThread"] = PThread;
          Module["_pthread_self"] = _pthread_self;
          Module["wasmMemory"] = wasmMemory;
          Module["ExitStatus"] = ExitStatus;
          var calledRun;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
          }
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain(args) {
            var entryFunction = Module["_main"];
            var argc = 0;
            var argv = 0;
            try {
              var ret = entryFunction(argc, argv);
              exit(ret, true);
            } catch (e) {
              if (e instanceof ExitStatus) {
                return;
              } else if (e == "unwind") {
                noExitRuntime = true;
                return;
              } else {
                var toLog = e;
                if (e && typeof e === "object" && e.stack) {
                  toLog = [e, e.stack];
                }
                err("exception thrown: " + toLog);
                quit_(1, e);
              }
            } finally {
            }
          }
          function run(args) {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0)
              return;
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain();
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          Module["run"] = run;
          function exit(status, implicit) {
            if (implicit && noExitRuntime && status === 0) {
              return;
            }
            if (noExitRuntime) ; else {
              PThread.terminateAllThreads();
              if (Module["onExit"])
                Module["onExit"](status);
              ABORT = true;
            }
            quit_(status, new ExitStatus(status));
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          if (!ENVIRONMENT_IS_PTHREAD)
            noExitRuntime = true;
          if (!ENVIRONMENT_IS_PTHREAD) {
            run();
          } else {
            PThread.initWorker();
          }
          return WebIFCWasm3.ready;
        };
      }();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = WebIFCWasm2;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return WebIFCWasm2;
        });
      else if (typeof exports === "object")
        exports["WebIFCWasm"] = WebIFCWasm2;
    }
  });

  // dist/web-ifc.js
  var require_web_ifc = __commonJS({
    "dist/web-ifc.js"(exports, module) {
      var WebIFCWasm2 = function() {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        _scriptDir = _scriptDir || __filename;
        return function(WebIFCWasm3) {
          WebIFCWasm3 = WebIFCWasm3 || {};
          var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = {};
          var key;
          for (key in Module) {
            if (Module.hasOwnProperty(key)) {
              moduleOverrides[key] = Module[key];
            }
          }
          var thisProgram = "./this.program";
          var quit_ = function(status, toThrow) {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = false;
          var ENVIRONMENT_IS_WORKER = false;
          var ENVIRONMENT_IS_NODE = false;
          var ENVIRONMENT_IS_SHELL = false;
          ENVIRONMENT_IS_WEB = typeof window === "object";
          ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
          ENVIRONMENT_IS_NODE = typeof process$1 === "object" && typeof process$1.versions === "object" && typeof process$1.versions.node === "string";
          ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readBinary;
          var nodeFS;
          var nodePath;
          if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            if (process$1["argv"].length > 1) {
              thisProgram = process$1["argv"][1].replace(/\\/g, "/");
            }
            quit_ = function(status) {
              process$1["exit"](status);
            };
            Module["inspect"] = function() {
              return "[Emscripten Module object]";
            };
          } else if (ENVIRONMENT_IS_SHELL) {
            if (typeof read != "undefined") {
              read_ = function shell_read(f) {
                return read(f);
              };
            }
            readBinary = function readBinary2(f) {
              var data;
              if (typeof readbuffer === "function") {
                return new Uint8Array(readbuffer(f));
              }
              data = read(f, "binary");
              assert(typeof data === "object");
              return data;
            };
            if (typeof scriptArgs != "undefined") {
              scriptArgs;
            }
            if (typeof quit === "function") {
              quit_ = function(status) {
                quit(status);
              };
            }
            if (typeof print !== "undefined") {
              if (typeof console === "undefined")
                console = {};
              console.log = print;
              console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
            }
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document !== "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            {
              read_ = function shell_read(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = function readBinary2(url) {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
            }
          } else ;
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module[key] = moduleOverrides[key];
            }
          }
          moduleOverrides = null;
          if (Module["arguments"])
            ;
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var STACK_ALIGN = 16;
          function alignMemory(size, factor) {
            if (!factor)
              factor = STACK_ALIGN;
            return Math.ceil(size / factor) * factor;
          }
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          var noExitRuntime;
          if (Module["noExitRuntime"])
            noExitRuntime = Module["noExitRuntime"];
          if (typeof WebAssembly !== "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var ABORT = false;
          function assert(condition, text) {
            if (!condition) {
              abort("Assertion failed: " + text);
            }
          }
          var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
          function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
              return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
            } else {
              var str = "";
              while (idx < endPtr) {
                var u0 = heap[idx++ >>> 0];
                if (!(u0 & 128)) {
                  str += String.fromCharCode(u0);
                  continue;
                }
                var u1 = heap[idx++ >>> 0] & 63;
                if ((u0 & 224) == 192) {
                  str += String.fromCharCode((u0 & 31) << 6 | u1);
                  continue;
                }
                var u2 = heap[idx++ >>> 0] & 63;
                if ((u0 & 240) == 224) {
                  u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                } else {
                  u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
                }
                if (u0 < 65536) {
                  str += String.fromCharCode(u0);
                } else {
                  var ch = u0 - 65536;
                  str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                }
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            ptr >>>= 0;
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
          }
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343)
                u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
              if (u <= 127)
                ++len;
              else if (u <= 2047)
                len += 2;
              else if (u <= 65535)
                len += 3;
              else
                len += 4;
            }
            return len;
          }
          var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
          function UTF16ToString(ptr, maxBytesToRead) {
            var endPtr = ptr;
            var idx = endPtr >> 1;
            var maxIdx = idx + maxBytesToRead / 2;
            while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
              ++idx;
            endPtr = idx << 1;
            if (endPtr - ptr > 32 && UTF16Decoder) {
              return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));
            } else {
              var str = "";
              for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
                var codeUnit = HEAP16[ptr + i * 2 >>> 1];
                if (codeUnit == 0)
                  break;
                str += String.fromCharCode(codeUnit);
              }
              return str;
            }
          }
          function stringToUTF16(str, outPtr, maxBytesToWrite) {
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 2)
              return 0;
            maxBytesToWrite -= 2;
            var startPtr = outPtr;
            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
            for (var i = 0; i < numCharsToWrite; ++i) {
              var codeUnit = str.charCodeAt(i);
              HEAP16[outPtr >>> 1] = codeUnit;
              outPtr += 2;
            }
            HEAP16[outPtr >>> 1] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF16(str) {
            return str.length * 2;
          }
          function UTF32ToString(ptr, maxBytesToRead) {
            var i = 0;
            var str = "";
            while (!(i >= maxBytesToRead / 4)) {
              var utf32 = HEAP32[ptr + i * 4 >>> 2];
              if (utf32 == 0)
                break;
              ++i;
              if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              } else {
                str += String.fromCharCode(utf32);
              }
            }
            return str;
          }
          function stringToUTF32(str, outPtr, maxBytesToWrite) {
            outPtr >>>= 0;
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 4)
              return 0;
            var startPtr = outPtr;
            var endPtr = startPtr + maxBytesToWrite - 4;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
              }
              HEAP32[outPtr >>> 2] = codeUnit;
              outPtr += 4;
              if (outPtr + 4 > endPtr)
                break;
            }
            HEAP32[outPtr >>> 2] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF32(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i;
              len += 4;
            }
            return len;
          }
          function writeArrayToMemory(array, buffer2) {
            HEAP8.set(array, buffer2 >>> 0);
          }
          function writeAsciiToMemory(str, buffer2, dontAddNull) {
            for (var i = 0; i < str.length; ++i) {
              HEAP8[buffer2++ >>> 0] = str.charCodeAt(i);
            }
            if (!dontAddNull)
              HEAP8[buffer2 >>> 0] = 0;
          }
          function alignUp(x, multiple) {
            if (x % multiple > 0) {
              x += multiple - x % multiple;
            }
            return x;
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
          }
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 4294967296 / 65536 });
          }
          if (wasmMemory) {
            buffer = wasmMemory.buffer;
          }
          INITIAL_MEMORY = buffer.byteLength;
          updateGlobalBufferAndViews(buffer);
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            if (!Module["noFSInit"] && !FS.init.initialized)
              FS.init();
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            FS.ignorePermissions = false;
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var dependenciesFulfilled = null;
          function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          Module["preloadedImages"] = {};
          Module["preloadedAudios"] = {};
          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what);
            }
            what += "";
            err(what);
            ABORT = true;
            what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          function hasPrefix(str, prefix) {
            return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return hasPrefix(filename, dataURIPrefix);
          }
          var fileURIPrefix = "file://";
          function isFileURI(filename) {
            return hasPrefix(filename, fileURIPrefix);
          }
          var wasmBinaryFile = "web-ifc.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary() {
            try {
              if (wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(wasmBinaryFile);
              } else {
                throw "both async and sync fetching of the wasm failed";
              }
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary();
              });
            }
            return Promise.resolve().then(getBinary);
          }
          function createWasm() {
            var info = { "a": asmLibraryArg };
            function receiveInstance(instance, module2) {
              var exports3 = instance.exports;
              Module["asm"] = exports3;
              wasmTable = Module["asm"]["ba"];
              removeRunDependency();
            }
            addRunDependency();
            function receiveInstantiatedSource(output) {
              receiveInstance(output["instance"]);
            }
            function instantiateArrayBuffer(receiver) {
              return getBinaryPromise().then(function(binary) {
                return WebAssembly.instantiate(binary, info);
              }).then(receiver, function(reason) {
                err("failed to asynchronously prepare wasm: " + reason);
                abort(reason);
              });
            }
            function instantiateAsync() {
              if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
                return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  var result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiatedSource, function(reason) {
                    err("wasm streaming compile failed: " + reason);
                    err("falling back to ArrayBuffer instantiation");
                    return instantiateArrayBuffer(receiveInstantiatedSource);
                  });
                });
              } else {
                return instantiateArrayBuffer(receiveInstantiatedSource);
              }
            }
            if (Module["instantiateWasm"]) {
              try {
                var exports2 = Module["instantiateWasm"](info, receiveInstance);
                return exports2;
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false;
              }
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == "function") {
                callback(Module);
                continue;
              }
              var func = callback.func;
              if (typeof func === "number") {
                if (callback.arg === void 0) {
                  wasmTable.get(func)();
                } else {
                  wasmTable.get(func)(callback.arg);
                }
              } else {
                func(callback.arg === void 0 ? null : callback.arg);
              }
            }
          }
          function dynCallLegacy(sig, ptr, args) {
            if (args && args.length) {
              return Module["dynCall_" + sig].apply(null, [ptr].concat(args));
            }
            return Module["dynCall_" + sig].call(null, ptr);
          }
          function dynCall(sig, ptr, args) {
            if (sig.indexOf("j") != -1) {
              return dynCallLegacy(sig, ptr, args);
            }
            return wasmTable.get(ptr).apply(null, args);
          }
          function ___assert_fail(condition, filename, line, func) {
            abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
          }
          var ExceptionInfoAttrs = { DESTRUCTOR_OFFSET: 0, REFCOUNT_OFFSET: 4, TYPE_OFFSET: 8, CAUGHT_OFFSET: 12, RETHROWN_OFFSET: 13, SIZE: 16 };
          function ___cxa_allocate_exception(size) {
            return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE;
          }
          function ExceptionInfo(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - ExceptionInfoAttrs.SIZE;
            this.set_type = function(type) {
              HEAP32[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >>> 2] = type;
            };
            this.get_type = function() {
              return HEAP32[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >>> 2];
            };
            this.set_destructor = function(destructor) {
              HEAP32[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >>> 2] = destructor;
            };
            this.get_destructor = function() {
              return HEAP32[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >>> 2];
            };
            this.set_refcount = function(refcount) {
              HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >>> 2] = refcount;
            };
            this.set_caught = function(caught) {
              caught = caught ? 1 : 0;
              HEAP8[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >>> 0] = caught;
            };
            this.get_caught = function() {
              return HEAP8[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >>> 0] != 0;
            };
            this.set_rethrown = function(rethrown) {
              rethrown = rethrown ? 1 : 0;
              HEAP8[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >>> 0] = rethrown;
            };
            this.get_rethrown = function() {
              return HEAP8[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >>> 0] != 0;
            };
            this.init = function(type, destructor) {
              this.set_type(type);
              this.set_destructor(destructor);
              this.set_refcount(0);
              this.set_caught(false);
              this.set_rethrown(false);
            };
            this.add_ref = function() {
              var value = HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >>> 2];
              HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >>> 2] = value + 1;
            };
            this.release_ref = function() {
              var prev = HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >>> 2];
              HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >>> 2] = prev - 1;
              return prev === 1;
            };
          }
          function ___cxa_throw(ptr, type, destructor) {
            var info = new ExceptionInfo(ptr);
            info.init(type, destructor);
            throw ptr;
          }
          var PATH = { splitPath: function(filename) {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, normalizeArray: function(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, normalize: function(path) {
            var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, dirname: function(path) {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, basename: function(path) {
            if (path === "/")
              return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1)
              return path;
            return path.substr(lastSlash + 1);
          }, extname: function(path) {
            return PATH.splitPath(path)[3];
          }, join: function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          }, join2: function(l, r) {
            return PATH.normalize(l + "/" + r);
          } };
          function getRandomDevice() {
            if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
              var randomBuffer = new Uint8Array(1);
              return function() {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0];
              };
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = require_crypto();
                return function() {
                  return crypto_module["randomBytes"](1)[0];
                };
              } catch (e) {
              }
            }
            return function() {
              abort("randomDevice");
            };
          }
          var PATH_FS = { resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : FS.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, relative: function(from, to) {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          } };
          var TTY = { ttys: [], init: function() {
          }, shutdown: function() {
          }, register: function(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, stream_ops: { open: function(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
              throw new FS.ErrnoError(43);
            }
            stream.tty = tty;
            stream.seekable = false;
          }, close: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, flush: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, read: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
              throw new FS.ErrnoError(60);
            }
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = stream.tty.ops.get_char(stream.tty);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
              throw new FS.ErrnoError(60);
            }
            try {
              for (var i = 0; i < length; i++) {
                stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
              }
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } }, default_tty_ops: { get_char: function(tty) {
            if (!tty.input.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
                var bytesRead = 0;
                try {
                  bytesRead = nodeFS.readSync(process$1.stdin.fd, buf, 0, BUFSIZE, null);
                } catch (e) {
                  if (e.toString().indexOf("EOF") != -1)
                    bytesRead = 0;
                  else
                    throw e;
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              tty.input = intArrayFromString(result, true);
            }
            return tty.input.shift();
          }, put_char: function(tty, val) {
            if (val === null || val === 10) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } }, default_tty1_ops: { put_char: function(tty, val) {
            if (val === null || val === 10) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } } };
          function mmapAlloc(size) {
            var alignedSize = alignMemory(size, 16384);
            var ptr = _malloc(alignedSize);
            while (size < alignedSize)
              HEAP8[ptr + size++ >>> 0] = 0;
            return ptr;
          }
          var MEMFS = { ops_table: null, mount: function(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, createNode: function(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            }
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
            }
            return node;
          }, getFileDataAsRegularArray: function(node) {
            if (node.contents && node.contents.subarray) {
              var arr = [];
              for (var i = 0; i < node.usedBytes; ++i)
                arr.push(node.contents[i]);
              return arr;
            }
            return node.contents;
          }, getFileDataAsTypedArray: function(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, expandFileStorage: function(node, newCapacity) {
            newCapacity >>>= 0;
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            return;
          }, resizeFileStorage: function(node, newSize) {
            newSize >>>= 0;
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
              return;
            }
            if (!node.contents || node.contents.subarray) {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
              return;
            }
            if (!node.contents)
              node.contents = [];
            if (node.contents.length > newSize)
              node.contents.length = newSize;
            else
              while (node.contents.length < newSize)
                node.contents.push(0);
            node.usedBytes = newSize;
          }, node_ops: { getattr: function(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
              attr.size = 4096;
            } else if (FS.isFile(node.mode)) {
              attr.size = node.usedBytes;
            } else if (FS.isLink(node.mode)) {
              attr.size = node.link.length;
            } else {
              attr.size = 0;
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr;
          }, setattr: function(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
            if (attr.size !== void 0) {
              MEMFS.resizeFileStorage(node, attr.size);
            }
          }, lookup: function(parent, name2) {
            throw FS.genericErrors[44];
          }, mknod: function(parent, name2, mode, dev) {
            return MEMFS.createNode(parent, name2, mode, dev);
          }, rename: function(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                for (var i in new_node.contents) {
                  throw new FS.ErrnoError(55);
                }
              }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            old_node.parent = new_dir;
          }, unlink: function(parent, name2) {
            delete parent.contents[name2];
          }, rmdir: function(parent, name2) {
            var node = FS.lookupNode(parent, name2);
            for (var i in node.contents) {
              throw new FS.ErrnoError(55);
            }
            delete parent.contents[name2];
          }, readdir: function(node) {
            var entries = [".", ".."];
            for (var key2 in node.contents) {
              if (!node.contents.hasOwnProperty(key2)) {
                continue;
              }
              entries.push(key2);
            }
            return entries;
          }, symlink: function(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node;
          }, readlink: function(node) {
            if (!FS.isLink(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            return node.link;
          } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes)
              return 0;
            var size = Math.min(stream.node.usedBytes - position, length);
            if (size > 8 && contents.subarray) {
              buffer2.set(contents.subarray(position, position + size), offset);
            } else {
              for (var i = 0; i < size; i++)
                buffer2[offset + i] = contents[position + i];
            }
            return size;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            if (buffer2.buffer === HEAP8.buffer) {
              canOwn = false;
            }
            if (!length)
              return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
              if (canOwn) {
                node.contents = buffer2.subarray(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (node.usedBytes === 0 && position === 0) {
                node.contents = buffer2.slice(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (position + length <= node.usedBytes) {
                node.contents.set(buffer2.subarray(offset, offset + length), position);
                return length;
              }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer2.subarray) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
            } else {
              for (var i = 0; i < length; i++) {
                node.contents[position + i] = buffer2[offset + i];
              }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length;
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.usedBytes;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(28);
            }
            return position;
          }, allocate: function(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            assert(address === 0);
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && contents.buffer === buffer) {
              allocated = false;
              ptr = contents.byteOffset;
            } else {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              allocated = true;
              ptr = mmapAlloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              ptr >>>= 0;
              HEAP8.set(contents, ptr >>> 0);
            }
            return { ptr, allocated };
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (mmapFlags & 2) {
              return 0;
            }
            MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
            return 0;
          } } };
          var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
            path = PATH_FS.resolve(FS.cwd(), path);
            opts = opts || {};
            if (!path)
              return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            for (var key2 in defaults) {
              if (opts[key2] === void 0) {
                opts[key2] = defaults[key2];
              }
            }
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), false);
            var current = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, getPath: function(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path)
                  return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
              }
              path = path ? node.name + "/" + path : node.name;
              node = node.parent;
            }
          }, hashName: function(parentid, name2) {
            var hash = 0;
            for (var i = 0; i < name2.length; i++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, hashAddNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, hashRemoveNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, lookupNode: function(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          }, createNode: function(parent, name2, mode, rdev) {
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          }, destroyNode: function(node) {
            FS.hashRemoveNode(node);
          }, isRoot: function(node) {
            return node === node.parent;
          }, isMountpoint: function(node) {
            return !!node.mounted;
          }, isFile: function(mode) {
            return (mode & 61440) === 32768;
          }, isDir: function(mode) {
            return (mode & 61440) === 16384;
          }, isLink: function(mode) {
            return (mode & 61440) === 40960;
          }, isChrdev: function(mode) {
            return (mode & 61440) === 8192;
          }, isBlkdev: function(mode) {
            return (mode & 61440) === 24576;
          }, isFIFO: function(mode) {
            return (mode & 61440) === 4096;
          }, isSocket: function(mode) {
            return (mode & 49152) === 49152;
          }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
            var flags = FS.flagModes[str];
            if (typeof flags === "undefined") {
              throw new Error("Unknown file open mode: " + str);
            }
            return flags;
          }, flagsToPermissionString: function(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, nodePermissions: function(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
              return 2;
            } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
              return 2;
            } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          }, mayLookup: function(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          }, mayCreate: function(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, mayDelete: function(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          }, mayOpen: function(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
            fd_start = fd_start || 0;
            fd_end = fd_end || FS.MAX_OPEN_FDS;
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          }, getStream: function(fd) {
            return FS.streams[fd];
          }, createStream: function(stream, fd_start, fd_end) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
              };
              FS.FSStream.prototype = { object: { get: function() {
                return this.node;
              }, set: function(val) {
                this.node = val;
              } }, isRead: { get: function() {
                return (this.flags & 2097155) !== 1;
              } }, isWrite: { get: function() {
                return (this.flags & 2097155) !== 0;
              } }, isAppend: { get: function() {
                return this.flags & 1024;
              } } };
            }
            var newStream = new FS.FSStream();
            for (var p in stream) {
              newStream[p] = stream[p];
            }
            stream = newStream;
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          }, closeStream: function(fd) {
            FS.streams[fd] = null;
          }, chrdev_stream_ops: { open: function(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
          }, llseek: function() {
            throw new FS.ErrnoError(70);
          } }, major: function(dev) {
            return dev >> 8;
          }, minor: function(dev) {
            return dev & 255;
          }, makedev: function(ma, mi) {
            return ma << 8 | mi;
          }, registerDevice: function(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, getDevice: function(dev) {
            return FS.devices[dev];
          }, getMounts: function(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          }, syncfs: function(populate, callback) {
            if (typeof populate === "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach(function(mount) {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, mount: function(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = { type, opts, mountpoint, mounts: [] };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, unmount: function(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach(function(hash) {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.indexOf(current.mount) !== -1) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, lookup: function(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          }, mknod: function(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          }, create: function(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          }, mkdir: function(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          }, mkdirTree: function(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i])
                continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          }, mkdev: function(path, mode, dev) {
            if (typeof dev === "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          }, symlink: function(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, rename: function(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            try {
              if (FS.trackingDelegate["willMovePath"]) {
                FS.trackingDelegate["willMovePath"](old_path, new_path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
            try {
              if (FS.trackingDelegate["onMovePath"])
                FS.trackingDelegate["onMovePath"](old_path, new_path);
            } catch (e) {
              err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
          }, rmdir: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          }, unlink: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readlink: function(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          }, stat: function(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          }, lstat: function(path) {
            return FS.stat(path, true);
          }, chmod: function(path, mode, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
          }, lchmod: function(path, mode) {
            FS.chmod(path, mode, true);
          }, fchmod: function(fd, mode) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chmod(stream.node, mode);
          }, chown: function(path, uid, gid, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, lchown: function(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, fchown: function(fd, uid, gid) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chown(stream.node, uid, gid);
          }, truncate: function(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, ftruncate: function(fd, len) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          }, utime: function(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, open: function(path, flags, mode, fd_start, fd_end) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode === "undefined" ? 438 : mode;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path === "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512) {
              FS.truncate(node, 0);
            }
            flags &= ~(128 | 512 | 131072);
            var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles)
                FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                err("FS.trackingDelegate error on read file: " + path);
              }
            }
            try {
              if (FS.trackingDelegate["onOpenFile"]) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                  trackingFlags |= FS.tracking.openFlags.READ;
                }
                if ((flags & 2097155) !== 0) {
                  trackingFlags |= FS.tracking.openFlags.WRITE;
                }
                FS.trackingDelegate["onOpenFile"](path, trackingFlags);
              }
            } catch (e) {
              err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
            }
            return stream;
          }, close: function(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, isClosed: function(stream) {
            return stream.fd === null;
          }, llseek: function(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, read: function(stream, buffer2, offset, length, position) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            try {
              if (stream.path && FS.trackingDelegate["onWriteToFile"])
                FS.trackingDelegate["onWriteToFile"](stream.path);
            } catch (e) {
              err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
            }
            return bytesWritten;
          }, allocate: function(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            address >>>= 0;
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            offset >>>= 0;
            if (!stream || !stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
          }, munmap: function(stream) {
            return 0;
          }, ioctl: function(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, readFile: function(path, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, writeFile: function(path, data, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data === "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, cwd: function() {
            return FS.currentPath;
          }, chdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          }, createDefaultDirectories: function() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, createDefaultDevices: function() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), { read: function() {
              return 0;
            }, write: function(stream, buffer2, offset, length, pos) {
              return length;
            } });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var random_device = getRandomDevice();
            FS.createDevice("/dev", "random", random_device);
            FS.createDevice("/dev", "urandom", random_device);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, createSpecialDirectories: function() {
            FS.mkdir("/proc");
            FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({ mount: function() {
              var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
              node.node_ops = { lookup: function(parent, name2) {
                var fd = +name2;
                var stream = FS.getStream(fd);
                if (!stream)
                  throw new FS.ErrnoError(8);
                var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                  return stream.path;
                } } };
                ret.parent = ret;
                return ret;
              } };
              return node;
            } }, {}, "/proc/self/fd");
          }, createStandardStreams: function() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            FS.open("/dev/stdin", 0);
            FS.open("/dev/stdout", 1);
            FS.open("/dev/stderr", 1);
          }, ensureErrnoError: function() {
            if (FS.ErrnoError)
              return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach(function(code) {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          }, staticInit: function() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { "MEMFS": MEMFS };
          }, init: function(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          }, quit: function() {
            FS.init.initialized = false;
            var fflush = Module["_fflush"];
            if (fflush)
              fflush(0);
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, getMode: function(canRead, canWrite) {
            var mode = 0;
            if (canRead)
              mode |= 292 | 73;
            if (canWrite)
              mode |= 146;
            return mode;
          }, findObject: function(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (ret.exists) {
              return ret.object;
            } else {
              return null;
            }
          }, analyzePath: function(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, createPath: function(parent, path, canRead, canWrite) {
            parent = typeof parent === "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, createFile: function(parent, name2, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
            var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          }, createDevice: function(parent, name2, input, output) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major)
              FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, { open: function(stream) {
              stream.seekable = false;
            }, close: function(stream) {
              if (output && output.buffer && output.buffer.length) {
                output(10);
              }
            }, read: function(stream, buffer2, offset, length, pos) {
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = input();
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0)
                  break;
                bytesRead++;
                buffer2[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, write: function(stream, buffer2, offset, length, pos) {
              for (var i = 0; i < length; i++) {
                try {
                  output(buffer2[offset + i]);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            } });
            return FS.mkdev(path, mode, dev);
          }, forceLoadFile: function(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest !== "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing)
                chunkSize = datalength;
              var doXHR = function(from, to) {
                if (from > to)
                  throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1)
                  throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                if (typeof Uint8Array != "undefined")
                  xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                } else {
                  return intArrayFromString(xhr2.responseText || "", true);
                }
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest !== "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, { length: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              } }, chunkSize: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              } } });
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, { usedBytes: { get: function() {
              return this.contents.length;
            } } });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach(function(key2) {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
              FS.forceLoadFile(node);
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents.get(position + i);
                }
              }
              return size;
            };
            node.stream_ops = stream_ops;
            return node;
          }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
            Browser.init();
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            function processData(byteArray) {
              function finish(byteArray2) {
                if (preFinish)
                  preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                if (onload)
                  onload();
                removeRunDependency();
              }
              var handled = false;
              Module["preloadPlugins"].forEach(function(plugin) {
                if (handled)
                  return;
                if (plugin["canHandle"](fullname)) {
                  plugin["handle"](byteArray, fullname, finish, function() {
                    if (onerror)
                      onerror();
                    removeRunDependency();
                  });
                  handled = true;
                }
              });
              if (!handled)
                finish(byteArray);
            }
            addRunDependency();
            if (typeof url == "string") {
              Browser.asyncLoad(url, function(byteArray) {
                processData(byteArray);
              }, onerror);
            } else {
              processData(url);
            }
          }, indexedDB: function() {
            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
          }, DB_NAME: function() {
            return "EM_FS_" + window.location.pathname;
          }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
              out("creating db");
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            };
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                putRequest.onsuccess = function putRequest_onsuccess() {
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                putRequest.onerror = function putRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          }, loadFilesFromDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = function getRequest_onsuccess() {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                getRequest.onerror = function getRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          } };
          var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path) {
            if (path[0] !== "/") {
              var dir;
              if (dirfd === -100) {
                dir = FS.cwd();
              } else {
                var dirstream = FS.getStream(dirfd);
                if (!dirstream)
                  throw new FS.ErrnoError(8);
                dir = dirstream.path;
              }
              path = PATH.join2(dir, path);
            }
            return path;
          }, doStat: function(func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            HEAP32[buf >>> 2] = stat.dev;
            HEAP32[buf + 4 >>> 2] = 0;
            HEAP32[buf + 8 >>> 2] = stat.ino;
            HEAP32[buf + 12 >>> 2] = stat.mode;
            HEAP32[buf + 16 >>> 2] = stat.nlink;
            HEAP32[buf + 20 >>> 2] = stat.uid;
            HEAP32[buf + 24 >>> 2] = stat.gid;
            HEAP32[buf + 28 >>> 2] = stat.rdev;
            HEAP32[buf + 32 >>> 2] = 0;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2] = tempI64[0], HEAP32[buf + 44 >>> 2] = tempI64[1];
            HEAP32[buf + 48 >>> 2] = 4096;
            HEAP32[buf + 52 >>> 2] = stat.blocks;
            HEAP32[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
            HEAP32[buf + 60 >>> 2] = 0;
            HEAP32[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
            HEAP32[buf + 68 >>> 2] = 0;
            HEAP32[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
            HEAP32[buf + 76 >>> 2] = 0;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >>> 2] = tempI64[0], HEAP32[buf + 84 >>> 2] = tempI64[1];
            return 0;
          }, doMsync: function(addr, stream, len, flags, offset) {
            var buffer2 = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer2, offset, len, flags);
          }, doMkdir: function(path, mode) {
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/")
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          }, doMknod: function(path, mode, dev) {
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path, mode, dev);
            return 0;
          }, doReadlink: function(path, buf, bufsize) {
            if (bufsize <= 0)
              return -28;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len >>> 0];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len >>> 0] = endChar;
            return len;
          }, doAccess: function(path, amode) {
            if (amode & ~7) {
              return -28;
            }
            var node;
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4)
              perms += "r";
            if (amode & 2)
              perms += "w";
            if (amode & 1)
              perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          }, doDup: function(path, flags, suggestFD) {
            var suggest = FS.getStream(suggestFD);
            if (suggest)
              FS.close(suggest);
            return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
          }, doReadv: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAP32[iov + i * 8 >>> 2];
              var len = HEAP32[iov + (i * 8 + 4) >>> 2];
              var curr = FS.read(stream, HEAP8, ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (curr < len)
                break;
            }
            return ret;
          }, doWritev: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAP32[iov + i * 8 >>> 2];
              var len = HEAP32[iov + (i * 8 + 4) >>> 2];
              var curr = FS.write(stream, HEAP8, ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
            }
            return ret;
          }, varargs: void 0, get: function() {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
            return ret;
          }, getStr: function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }, getStreamFromFD: function(fd) {
            var stream = FS.getStream(fd);
            if (!stream)
              throw new FS.ErrnoError(8);
            return stream;
          }, get64: function(low, high) {
            return low;
          } };
          function ___sys_ioctl(fd, op, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (op) {
                case 21509:
                case 21505: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21519: {
                  if (!stream.tty)
                    return -59;
                  var argp = SYSCALLS.get();
                  HEAP32[argp >>> 2] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty)
                    return -59;
                  return -28;
                }
                case 21531: {
                  var argp = SYSCALLS.get();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21524: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                default:
                  abort("bad ioctl syscall " + op);
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          function ___sys_open(path, flags, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var pathname = SYSCALLS.getStr(path);
              var mode = SYSCALLS.get();
              var stream = FS.open(pathname, flags, mode);
              return stream.fd;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          var tupleRegistrations = {};
          function runDestructors(destructors) {
            while (destructors.length) {
              var ptr = destructors.pop();
              var del = destructors.pop();
              del(ptr);
            }
          }
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](HEAPU32[pointer >>> 2]);
          }
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var char_0 = 48;
          var char_9 = 57;
          function makeLegalFunctionName(name2) {
            if (name2 === void 0) {
              return "_unknown";
            }
            name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name2.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return "_" + name2;
            } else {
              return name2;
            }
          }
          function createNamedFunction(name2, body) {
            name2 = makeLegalFunctionName(name2);
            return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
          }
          function extendError(baseErrorType, errorName) {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return this.name + ": " + this.message;
              }
            };
            return errorClass;
          }
          var InternalError = void 0;
          function throwInternalError(message) {
            throw new InternalError(message);
          }
          function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i = 0; i < myTypes.length; ++i) {
                registerType(myTypes[i], myTypeConverters[i]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach(function(dt, i) {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (unregisteredTypes.length === 0) {
              onComplete(typeConverters);
            }
          }
          function __embind_finalize_value_array(rawTupleType) {
            var reg = tupleRegistrations[rawTupleType];
            delete tupleRegistrations[rawTupleType];
            var elements = reg.elements;
            var elementsLength = elements.length;
            var elementTypes = elements.map(function(elt) {
              return elt.getterReturnType;
            }).concat(elements.map(function(elt) {
              return elt.setterArgumentType;
            }));
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
              elements.forEach(function(elt, i) {
                var getterReturnType = elementTypes2[i];
                var getter = elt.getter;
                var getterContext = elt.getterContext;
                var setterArgumentType = elementTypes2[i + elementsLength];
                var setter = elt.setter;
                var setterContext = elt.setterContext;
                elt.read = function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                };
                elt.write = function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = new Array(elementsLength);
                for (var i = 0; i < elementsLength; ++i) {
                  rv[i] = elements[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                if (elementsLength !== o.length) {
                  throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
                }
                var ptr = rawConstructor();
                for (var i = 0; i < elementsLength; ++i) {
                  elements[i].write(ptr, o[i]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          var structRegistrations = {};
          function __embind_finalize_value_object(structType) {
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map(function(field) {
              return field.getterReturnType;
            }).concat(fieldRecords.map(function(field) {
              return field.setterArgumentType;
            }));
            whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
              var fields = {};
              fieldRecords.forEach(function(field, i) {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = { read: function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                }, write: function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                } };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = {};
                for (var i in fields) {
                  rv[i] = fields[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError('Missing field:  "' + fieldName + '"');
                  }
                }
                var ptr = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          function getShiftFromSize(size) {
            switch (size) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + size);
            }
          }
          function embind_init_charCodes() {
            var codes = new Array(256);
            for (var i = 0; i < 256; ++i) {
              codes[i] = String.fromCharCode(i);
            }
            embind_charCodes = codes;
          }
          var embind_charCodes = void 0;
          function readLatin1String(ptr) {
            var ret = "";
            var c = ptr;
            while (HEAPU8[c >>> 0]) {
              ret += embind_charCodes[HEAPU8[c++ >>> 0]];
            }
            return ret;
          }
          var BindingError = void 0;
          function throwBindingError(message) {
            throw new BindingError(message);
          }
          function registerType(rawType, registeredInstance, options) {
            options = options || {};
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            var name2 = registeredInstance.name;
            if (!rawType) {
              throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError("Cannot register type '" + name2 + "' twice");
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach(function(cb) {
                cb();
              });
            }
          }
          function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(wt) {
              return !!wt;
            }, "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
              var heap;
              if (size === 1) {
                heap = HEAP8;
              } else if (size === 2) {
                heap = HEAP16;
              } else if (size === 4) {
                heap = HEAP32;
              } else {
                throw new TypeError("Unknown boolean type size: " + name2);
              }
              return this["fromWireType"](heap[pointer >>> shift]);
            }, destructorFunction: null });
          }
          function ClassHandle_isAliasOf(other) {
            if (!(this instanceof ClassHandle)) {
              return false;
            }
            if (!(other instanceof ClassHandle)) {
              return false;
            }
            var leftClass = this.$$.ptrType.registeredClass;
            var left = this.$$.ptr;
            var rightClass = other.$$.ptrType.registeredClass;
            var right = other.$$.ptr;
            while (leftClass.baseClass) {
              left = leftClass.upcast(left);
              leftClass = leftClass.baseClass;
            }
            while (rightClass.baseClass) {
              right = rightClass.upcast(right);
              rightClass = rightClass.baseClass;
            }
            return leftClass === rightClass && left === right;
          }
          function shallowCopyInternalPointer(o) {
            return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
          }
          function throwInstanceAlreadyDeleted(obj) {
            function getInstanceTypeName(handle) {
              return handle.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          }
          var finalizationGroup = false;
          function detachFinalizer(handle) {
          }
          function runDestructor($$) {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          }
          function releaseClassHandle($$) {
            $$.count.value -= 1;
            var toDelete = $$.count.value === 0;
            if (toDelete) {
              runDestructor($$);
            }
          }
          function attachFinalizer(handle) {
            if (typeof FinalizationGroup === "undefined") {
              attachFinalizer = function(handle2) {
                return handle2;
              };
              return handle;
            }
            finalizationGroup = new FinalizationGroup(function(iter) {
              for (var result = iter.next(); !result.done; result = iter.next()) {
                var $$ = result.value;
                if (!$$.ptr) {
                  console.warn("object already deleted: " + $$.ptr);
                } else {
                  releaseClassHandle($$);
                }
              }
            });
            attachFinalizer = function(handle2) {
              finalizationGroup.register(handle2, handle2.$$, handle2.$$);
              return handle2;
            };
            detachFinalizer = function(handle2) {
              finalizationGroup.unregister(handle2.$$);
            };
            return attachFinalizer(handle);
          }
          function ClassHandle_clone() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.preservePointerOnDelete) {
              this.$$.count.value += 1;
              return this;
            } else {
              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
              clone.$$.count.value += 1;
              clone.$$.deleteScheduled = false;
              return clone;
            }
          }
          function ClassHandle_delete() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            detachFinalizer(this);
            releaseClassHandle(this.$$);
            if (!this.$$.preservePointerOnDelete) {
              this.$$.smartPtr = void 0;
              this.$$.ptr = void 0;
            }
          }
          function ClassHandle_isDeleted() {
            return !this.$$.ptr;
          }
          var delayFunction = void 0;
          var deletionQueue = [];
          function flushPendingDeletes() {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          }
          function ClassHandle_deleteLater() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            deletionQueue.push(this);
            if (deletionQueue.length === 1 && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
            this.$$.deleteScheduled = true;
            return this;
          }
          function init_ClassHandle() {
            ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
            ClassHandle.prototype["clone"] = ClassHandle_clone;
            ClassHandle.prototype["delete"] = ClassHandle_delete;
            ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
            ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
          }
          function ClassHandle() {
          }
          var registeredPointers = {};
          function ensureOverloadTable(proto, methodName, humanName) {
            if (proto[methodName].overloadTable === void 0) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          }
          function exposePublicSymbol(name2, value, numArguments) {
            if (Module.hasOwnProperty(name2)) {
              if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
                throwBindingError("Cannot register public name '" + name2 + "' twice");
              }
              ensureOverloadTable(Module, name2, name2);
              if (Module.hasOwnProperty(numArguments)) {
                throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
              }
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              if (numArguments !== void 0) {
                Module[name2].numArguments = numArguments;
              }
            }
          }
          function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name2;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          function upcastPointer(ptr, ptrClass, desiredClass) {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
              }
              ptr = ptrClass.upcast(ptr);
              ptrClass = ptrClass.baseClass;
            }
            return ptr;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function genericPointerToWireType(destructors, handle) {
            var ptr;
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              if (this.isSmartPointer) {
                ptr = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
                return ptr;
              } else {
                return 0;
              }
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (!this.isConst && handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (handle.$$.smartPtr === void 0) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                  }
                  break;
                case 1:
                  ptr = handle.$$.smartPtr;
                  break;
                case 2:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    var clonedHandle = handle["clone"]();
                    ptr = this.rawShare(ptr, __emval_register(function() {
                      clonedHandle["delete"]();
                    }));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function RegisteredPointer_getPointee(ptr) {
            if (this.rawGetPointee) {
              ptr = this.rawGetPointee(ptr);
            }
            return ptr;
          }
          function RegisteredPointer_destructor(ptr) {
            if (this.rawDestructor) {
              this.rawDestructor(ptr);
            }
          }
          function RegisteredPointer_deleteObject(handle) {
            if (handle !== null) {
              handle["delete"]();
            }
          }
          function downcastPointer(ptr, ptrClass, desiredClass) {
            if (ptrClass === desiredClass) {
              return ptr;
            }
            if (desiredClass.baseClass === void 0) {
              return null;
            }
            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          }
          function getInheritedInstanceCount() {
            return Object.keys(registeredInstances).length;
          }
          function getLiveInheritedInstances() {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          }
          function setDelayFunction(fn) {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          }
          function init_embind() {
            Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module["flushPendingDeletes"] = flushPendingDeletes;
            Module["setDelayFunction"] = setDelayFunction;
          }
          var registeredInstances = {};
          function getBasestPointer(class_, ptr) {
            if (ptr === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr = class_.upcast(ptr);
              class_ = class_.baseClass;
            }
            return ptr;
          }
          function getInheritedInstance(class_, ptr) {
            ptr = getBasestPointer(class_, ptr);
            return registeredInstances[ptr];
          }
          function makeClassHandle(prototype, record) {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = { value: 1 };
            return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
          }
          function RegisteredPointer_fromWireType(ptr) {
            var rawPointer = this.getPointee(ptr);
            if (!rawPointer) {
              this.destructor(ptr);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (registeredInstance !== void 0) {
              if (registeredInstance.$$.count.value === 0) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
            }
          }
          function init_RegisteredPointer() {
            RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
            RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
            RegisteredPointer.prototype["argPackAdvance"] = 8;
            RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
            RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
            RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
          }
          function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name2;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          function replacePublicSymbol(name2, value, numArguments) {
            if (!Module.hasOwnProperty(name2)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              Module[name2].argCount = numArguments;
            }
          }
          function getDynCaller(sig, ptr) {
            assert(sig.indexOf("j") >= 0, "getDynCaller should only be called with i64 sigs");
            var argCache = [];
            return function() {
              argCache.length = arguments.length;
              for (var i = 0; i < arguments.length; i++) {
                argCache[i] = arguments[i];
              }
              return dynCall(sig, ptr, argCache);
            };
          }
          function embind__requireFunction(signature, rawFunction) {
            signature = readLatin1String(signature);
            function makeDynCaller() {
              if (signature.indexOf("j") != -1) {
                return getDynCaller(signature, rawFunction);
              }
              return wasmTable.get(rawFunction);
            }
            var fp = makeDynCaller();
            if (typeof fp !== "function") {
              throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
            }
            return fp;
          }
          var UnboundTypeError = void 0;
          function getTypeName(type) {
            var ptr = ___getTypeName(type);
            var rv = readLatin1String(ptr);
            _free(ptr);
            return rv;
          }
          function throwUnboundTypeError(message, types) {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
          }
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
            name2 = readLatin1String(name2);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            if (upcast) {
              upcast = embind__requireFunction(upcastSignature, upcast);
            }
            if (downcast) {
              downcast = embind__requireFunction(downcastSignature, downcast);
            }
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name2);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(legalFunctionName, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name2);
                }
                if (registeredClass.constructor_body === void 0) {
                  throw new BindingError(name2 + " has no accessible constructor");
                }
                var body = registeredClass.constructor_body[arguments.length];
                if (body === void 0) {
                  throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                }
                return body.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          function heap32VectorToArray(count, firstElement) {
            var array = [];
            for (var i = 0; i < count; i++) {
              array.push(HEAP32[(firstElement >> 2) + i >>> 0]);
            }
            return array;
          }
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            assert(argCount > 0);
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            var args = [rawConstructor];
            var destructors = [];
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = "constructor " + classType.name;
              if (classType.registeredClass.constructor_body === void 0) {
                classType.registeredClass.constructor_body = [];
              }
              if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
                throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              }
              classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
                throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                    throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                  }
                  destructors.length = 0;
                  args.length = argCount;
                  for (var i = 1; i < argCount; ++i) {
                    args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                  }
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
                  return argTypes[0]["fromWireType"](ptr);
                };
                return [];
              });
              return [];
            });
          }
          function new_(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = false;
            for (var i = 1; i < argTypes.length; ++i) {
              if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
                needsDestructorStack = true;
                break;
              }
            }
            var returns = argTypes[0].name !== "void";
            var argsList = "";
            var argsListWired = "";
            for (var i = 0; i < argCount - 2; ++i) {
              argsList += (i !== 0 ? ", " : "") + "arg" + i;
              argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
            }
            var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
            }
            for (var i = 0; i < argCount - 2; ++i) {
              invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
              args1.push("argType" + i);
              args2.push(argTypes[i + 2]);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
                var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                  args1.push(paramName + "_dtor");
                  args2.push(argTypes[i].destructorFunction);
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
            }
            invokerFnBody += "}\n";
            args1.push(invokerFnBody);
            var invokerFunction = new_(Function, args1).apply(null, args2);
            return invokerFunction;
          }
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = classType.name + "." + methodName;
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
                if (proto[methodName].overloadTable === void 0) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          var emval_free_list = [];
          var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
          function __emval_decref(handle) {
            if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
              emval_handle_array[handle] = void 0;
              emval_free_list.push(handle);
            }
          }
          function count_emval_handles() {
            var count = 0;
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                ++count;
              }
            }
            return count;
          }
          function get_first_emval() {
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                return emval_handle_array[i];
              }
            }
            return null;
          }
          function init_emval() {
            Module["count_emval_handles"] = count_emval_handles;
            Module["get_first_emval"] = get_first_emval;
          }
          function __emval_register(value) {
            switch (value) {
              case void 0: {
                return 1;
              }
              case null: {
                return 2;
              }
              case true: {
                return 3;
              }
              case false: {
                return 4;
              }
              default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = { refcount: 1, value };
                return handle;
              }
            }
          }
          function __embind_register_emval(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
            }, "toWireType": function(destructors, value) {
              return __emval_register(value);
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
          }
          function enumReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return function(pointer) {
                  var heap = signed ? HEAP8 : HEAPU8;
                  return this["fromWireType"](heap[pointer >>> 0]);
                };
              case 1:
                return function(pointer) {
                  var heap = signed ? HEAP16 : HEAPU16;
                  return this["fromWireType"](heap[pointer >>> 1]);
                };
              case 2:
                return function(pointer) {
                  var heap = signed ? HEAP32 : HEAPU32;
                  return this["fromWireType"](heap[pointer >>> 2]);
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_enum(rawType, name2, size, isSigned) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
              return this.constructor.values[c];
            }, "toWireType": function(destructors, c) {
              return c.value;
            }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
            exposePublicSymbol(name2, ctor);
          }
          function requireRegisteredType(rawType, humanName) {
            var impl = registeredTypes[rawType];
            if (impl === void 0) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          }
          function __embind_register_enum_value(rawEnumType, name2, enumValue) {
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name2 = readLatin1String(name2);
            var Enum = enumType.constructor;
            var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
            }) } });
            Enum.values[enumValue] = Value2;
            Enum[name2] = Value2;
          }
          function _embind_repr(v) {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          }
          function floatReadValueFromPointer(name2, shift) {
            switch (shift) {
              case 2:
                return function(pointer) {
                  return this["fromWireType"](HEAPF32[pointer >>> 2]);
                };
              case 3:
                return function(pointer) {
                  return this["fromWireType"](HEAPF64[pointer >>> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + name2);
            }
          }
          function __embind_register_float(rawType, name2, size) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              return value;
            }, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
            }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
          }
          function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            name2 = readLatin1String(name2);
            rawInvoker = embind__requireFunction(signature, rawInvoker);
            exposePublicSymbol(name2, function() {
              throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
            }, argCount - 1);
            whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
              var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
              replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
              return [];
            });
          }
          function integerReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return signed ? function readS8FromPointer(pointer) {
                  return HEAP8[pointer >>> 0];
                } : function readU8FromPointer(pointer) {
                  return HEAPU8[pointer >>> 0];
                };
              case 1:
                return signed ? function readS16FromPointer(pointer) {
                  return HEAP16[pointer >>> 1];
                } : function readU16FromPointer(pointer) {
                  return HEAPU16[pointer >>> 1];
                };
              case 2:
                return signed ? function readS32FromPointer(pointer) {
                  return HEAP32[pointer >>> 2];
                } : function readU32FromPointer(pointer) {
                  return HEAPU32[pointer >>> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
            name2 = readLatin1String(name2);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var shift = getShiftFromSize(size);
            var fromWireType = function(value) {
              return value;
            };
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = function(value) {
                return value << bitshift >>> bitshift;
              };
            }
            var isUnsignedType = name2.indexOf("unsigned") != -1;
            registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
              }
              return isUnsignedType ? value >>> 0 : value | 0;
            }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
          }
          function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle) {
              handle = handle >> 2;
              var heap = HEAPU32;
              var size = heap[handle >>> 0];
              var data = heap[handle + 1 >>> 0];
              return new TA(buffer, data, size);
            }
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
          }
          function __embind_register_std_string(rawType, name2) {
            name2 = readLatin1String(name2);
            var stdStringIsUTF8 = name2 === "std::string";
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = HEAPU32[value >>> 2];
              var str;
              if (stdStringIsUTF8) {
                var decodeStartPtr = value + 4;
                for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = value + 4 + i;
                  if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              } else {
                var a = new Array(length);
                for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(HEAPU8[value + 4 + i >>> 0]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var getLength;
              var valueIsOfTypeString = typeof value === "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function() {
                  return lengthBytesUTF8(value);
                };
              } else {
                getLength = function() {
                  return value.length;
                };
              }
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              ptr >>>= 0;
              HEAPU32[ptr >>> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i = 0; i < length; ++i) {
                    var charCode = value.charCodeAt(i);
                    if (charCode > 255) {
                      _free(ptr);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    HEAPU8[ptr + 4 + i >>> 0] = charCode;
                  }
                } else {
                  for (var i = 0; i < length; ++i) {
                    HEAPU8[ptr + 4 + i >>> 0] = value[i];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_std_wstring(rawType, charSize, name2) {
            name2 = readLatin1String(name2);
            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
            if (charSize === 2) {
              decodeString = UTF16ToString;
              encodeString = stringToUTF16;
              lengthBytesUTF = lengthBytesUTF16;
              getHeap = function() {
                return HEAPU16;
              };
              shift = 1;
            } else if (charSize === 4) {
              decodeString = UTF32ToString;
              encodeString = stringToUTF32;
              lengthBytesUTF = lengthBytesUTF32;
              getHeap = function() {
                return HEAPU32;
              };
              shift = 2;
            }
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = HEAPU32[value >>> 2];
              var HEAP = getHeap();
              var str;
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i * charSize;
                if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (!(typeof value === "string")) {
                throwBindingError("Cannot pass non-string to C++ string type " + name2);
              }
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              ptr >>>= 0;
              HEAPU32[ptr >>> 2] = length >> shift;
              encodeString(value, ptr + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
          }
          function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
          }
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_void(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
              return void 0;
            }, "toWireType": function(destructors, o) {
              return void 0;
            } });
          }
          function requireHandle(handle) {
            if (!handle) {
              throwBindingError("Cannot use deleted val. handle = " + handle);
            }
            return emval_handle_array[handle].value;
          }
          function __emval_as(handle, returnType, destructorsRef) {
            handle = requireHandle(handle);
            returnType = requireRegisteredType(returnType, "emval::as");
            var destructors = [];
            var rd = __emval_register(destructors);
            HEAP32[destructorsRef >>> 2] = rd;
            return returnType["toWireType"](destructors, handle);
          }
          function __emval_lookupTypes(argCount, argTypes) {
            var a = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i >>> 0], "parameter " + i);
            }
            return a;
          }
          function __emval_call(handle, argCount, argTypes, argv) {
            handle = requireHandle(handle);
            var types = __emval_lookupTypes(argCount, argTypes);
            var args = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              var type = types[i];
              args[i] = type["readValueFromPointer"](argv);
              argv += type["argPackAdvance"];
            }
            var rv = handle.apply(void 0, args);
            return __emval_register(rv);
          }
          var emval_symbols = {};
          function getStringOrSymbol(address) {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            } else {
              return symbol;
            }
          }
          function emval_get_global() {
            if (typeof globalThis === "object") {
              return globalThis;
            }
            return function() {
              return Function;
            }()("return this")();
          }
          function __emval_get_global(name2) {
            if (name2 === 0) {
              return __emval_register(emval_get_global());
            } else {
              name2 = getStringOrSymbol(name2);
              return __emval_register(emval_get_global()[name2]);
            }
          }
          function __emval_get_property(handle, key2) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            return __emval_register(handle[key2]);
          }
          function __emval_incref(handle) {
            if (handle > 4) {
              emval_handle_array[handle].refcount += 1;
            }
          }
          function __emval_instanceof(object, constructor) {
            object = requireHandle(object);
            constructor = requireHandle(constructor);
            return object instanceof constructor;
          }
          function __emval_is_number(handle) {
            handle = requireHandle(handle);
            return typeof handle === "number";
          }
          function __emval_new_array() {
            return __emval_register([]);
          }
          function __emval_new_cstring(v) {
            return __emval_register(getStringOrSymbol(v));
          }
          function __emval_new_object() {
            return __emval_register({});
          }
          function __emval_run_destructors(handle) {
            var destructors = emval_handle_array[handle].value;
            runDestructors(destructors);
            __emval_decref(handle);
          }
          function __emval_set_property(handle, key2, value) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            value = requireHandle(value);
            handle[key2] = value;
          }
          function __emval_take_value(type, argv) {
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](argv);
            return __emval_register(v);
          }
          function _abort() {
            abort();
          }
          var _emscripten_get_now;
          if (ENVIRONMENT_IS_NODE) {
            _emscripten_get_now = function() {
              var t = process$1["hrtime"]();
              return t[0] * 1e3 + t[1] / 1e6;
            };
          } else if (typeof dateNow !== "undefined") {
            _emscripten_get_now = dateNow;
          } else
            _emscripten_get_now = function() {
              return performance.now();
            };
          var _emscripten_get_now_is_monotonic = true;
          function setErrNo(value) {
            HEAP32[___errno_location() >>> 2] = value;
            return value;
          }
          function _clock_gettime(clk_id, tp) {
            var now;
            if (clk_id === 0) {
              now = Date.now();
            } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
              now = _emscripten_get_now();
            } else {
              setErrNo(28);
              return -1;
            }
            HEAP32[tp >>> 2] = now / 1e3 | 0;
            HEAP32[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
            return 0;
          }
          function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          function _emscripten_get_heap_size() {
            return HEAPU8.length;
          }
          function emscripten_realloc_buffer(size) {
            try {
              wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
              updateGlobalBufferAndViews(wasmMemory.buffer);
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            requestedSize = requestedSize >>> 0;
            var oldSize = _emscripten_get_heap_size();
            var maxHeapSize = 4294967296;
            if (requestedSize > maxHeapSize) {
              return false;
            }
            var minHeapSize = 16777216;
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), 65536));
              var replacement = emscripten_realloc_buffer(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          var ENV = {};
          function getExecutableName() {
            return thisProgram || "./this.program";
          }
          function getEnvStrings() {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
              for (var x in ENV) {
                env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(x + "=" + env[x]);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          }
          function _environ_get(__environ, environ_buf) {
            try {
              var bufSize = 0;
              getEnvStrings().forEach(function(string, i) {
                var ptr = environ_buf + bufSize;
                HEAP32[__environ + i * 4 >>> 2] = ptr;
                writeAsciiToMemory(string, ptr);
                bufSize += string.length + 1;
              });
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _environ_sizes_get(penviron_count, penviron_buf_size) {
            try {
              var strings = getEnvStrings();
              HEAP32[penviron_count >>> 2] = strings.length;
              var bufSize = 0;
              strings.forEach(function(string) {
                bufSize += string.length + 1;
              });
              HEAP32[penviron_buf_size >>> 2] = bufSize;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_close(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_read(fd, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doReadv(stream, iov, iovcnt);
              HEAP32[pnum >>> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -61;
              }
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2] = tempI64[0], HEAP32[newOffset + 4 >>> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_write(fd, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doWritev(stream, iov, iovcnt);
              HEAP32[pnum >>> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _pthread_mutexattr_destroy() {
          }
          function _pthread_mutexattr_init() {
          }
          function _pthread_mutexattr_settype() {
          }
          function _setTempRet0($i) {
          }
          function __isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          function __arraySum(array, index) {
            var sum = 0;
            for (var i = 0; i <= index; sum += array[i++]) {
            }
            return sum;
          }
          var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function __addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = __isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = HEAP32[tm + 40 >>> 2];
            var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value === "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                } else {
                  return thisDate.getFullYear();
                }
              } else {
                return thisDate.getFullYear() - 1;
              }
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              } else {
                return "PM";
              }
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var janFirst = new Date(date2.tm_year + 1900, 0, 1);
              var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstSunday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
            }, "%V": function(date2) {
              var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
              var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
                return "53";
              }
              if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
                return "01";
              }
              var daysDifference;
              if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
                daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
              } else {
                daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
              }
              return leadingNulls(Math.ceil(daysDifference / 7), 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var janFirst = new Date(date2.tm_year, 0, 1);
              var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstMonday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.indexOf(rule) >= 0) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm) {
            return _strftime(s, maxsize, format, tm);
          }
          var FSNode = function(parent, name2, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name2;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, { read: { get: function() {
            return (this.mode & readMode) === readMode;
          }, set: function(val) {
            val ? this.mode |= readMode : this.mode &= ~readMode;
          } }, write: { get: function() {
            return (this.mode & writeMode) === writeMode;
          }, set: function(val) {
            val ? this.mode |= writeMode : this.mode &= ~writeMode;
          } }, isFolder: { get: function() {
            return FS.isDir(this.mode);
          } }, isDevice: { get: function() {
            return FS.isChrdev(this.mode);
          } } });
          FS.FSNode = FSNode;
          FS.staticInit();
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          InternalError = Module["InternalError"] = extendError(Error, "InternalError");
          embind_init_charCodes();
          BindingError = Module["BindingError"] = extendError(Error, "BindingError");
          init_ClassHandle();
          init_RegisteredPointer();
          init_embind();
          UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          init_emval();
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          __ATINIT__.push({ func: function() {
            ___wasm_call_ctors();
          } });
          var asmLibraryArg = { "z": ___assert_fail, "y": ___cxa_allocate_exception, "x": ___cxa_throw, "V": ___sys_ioctl, "W": ___sys_open, "$": __embind_finalize_value_array, "q": __embind_finalize_value_object, "Y": __embind_register_bool, "t": __embind_register_class, "s": __embind_register_class_constructor, "c": __embind_register_class_function, "X": __embind_register_emval, "_": __embind_register_enum, "v": __embind_register_enum_value, "F": __embind_register_float, "f": __embind_register_function, "o": __embind_register_integer, "k": __embind_register_memory_view, "G": __embind_register_std_string, "w": __embind_register_std_wstring, "aa": __embind_register_value_array, "h": __embind_register_value_array_element, "r": __embind_register_value_object, "e": __embind_register_value_object_field, "Z": __embind_register_void, "m": __emval_as, "H": __emval_call, "b": __emval_decref, "J": __emval_get_global, "n": __emval_get_property, "j": __emval_incref, "N": __emval_instanceof, "I": __emval_is_number, "A": __emval_new_array, "g": __emval_new_cstring, "u": __emval_new_object, "l": __emval_run_destructors, "i": __emval_set_property, "d": __emval_take_value, "C": _abort, "T": _clock_gettime, "M": _emscripten_memcpy_big, "p": _emscripten_resize_heap, "R": _environ_get, "S": _environ_sizes_get, "E": _fd_close, "U": _fd_read, "K": _fd_seek, "D": _fd_write, "a": wasmMemory, "B": _pthread_mutexattr_destroy, "P": _pthread_mutexattr_init, "O": _pthread_mutexattr_settype, "L": _setTempRet0, "Q": _strftime_l };
          createWasm();
          var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
            return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["ca"]).apply(null, arguments);
          };
          Module["_main"] = function() {
            return (Module["_main"] = Module["asm"]["da"]).apply(null, arguments);
          };
          var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["ea"]).apply(null, arguments);
          };
          var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["fa"]).apply(null, arguments);
          };
          var ___getTypeName = Module["___getTypeName"] = function() {
            return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ga"]).apply(null, arguments);
          };
          Module["___embind_register_native_and_builtin_types"] = function() {
            return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["ha"]).apply(null, arguments);
          };
          var ___errno_location = Module["___errno_location"] = function() {
            return (___errno_location = Module["___errno_location"] = Module["asm"]["ia"]).apply(null, arguments);
          };
          Module["dynCall_jiji"] = function() {
            return (Module["dynCall_jiji"] = Module["asm"]["ja"]).apply(null, arguments);
          };
          Module["dynCall_viijii"] = function() {
            return (Module["dynCall_viijii"] = Module["asm"]["ka"]).apply(null, arguments);
          };
          Module["dynCall_iiiiiijj"] = function() {
            return (Module["dynCall_iiiiiijj"] = Module["asm"]["la"]).apply(null, arguments);
          };
          Module["dynCall_iiiiij"] = function() {
            return (Module["dynCall_iiiiij"] = Module["asm"]["ma"]).apply(null, arguments);
          };
          Module["dynCall_iiiiijj"] = function() {
            return (Module["dynCall_iiiiijj"] = Module["asm"]["na"]).apply(null, arguments);
          };
          Module["addRunDependency"] = addRunDependency;
          Module["removeRunDependency"] = removeRunDependency;
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          Module["FS"] = FS;
          var calledRun;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
          }
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain(args) {
            var entryFunction = Module["_main"];
            var argc = 0;
            var argv = 0;
            try {
              var ret = entryFunction(argc, argv);
              exit(ret, true);
            } catch (e) {
              if (e instanceof ExitStatus) {
                return;
              } else if (e == "unwind") {
                noExitRuntime = true;
                return;
              } else {
                var toLog = e;
                if (e && typeof e === "object" && e.stack) {
                  toLog = [e, e.stack];
                }
                err("exception thrown: " + toLog);
                quit_(1, e);
              }
            } finally {
            }
          }
          function run(args) {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0)
              return;
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain();
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          Module["run"] = run;
          function exit(status, implicit) {
            if (implicit && noExitRuntime && status === 0) {
              return;
            }
            if (noExitRuntime) ; else {
              if (Module["onExit"])
                Module["onExit"](status);
              ABORT = true;
            }
            quit_(status, new ExitStatus(status));
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          noExitRuntime = true;
          run();
          return WebIFCWasm3.ready;
        };
      }();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = WebIFCWasm2;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return WebIFCWasm2;
        });
      else if (typeof exports === "object")
        exports["WebIFCWasm"] = WebIFCWasm2;
    }
  });

  // dist/ifc2x4.ts
  var IFCACTIONREQUEST = 3821786052;
  var IFCACTOR = 2296667514;
  var IFCACTORROLE = 3630933823;
  var IFCACTUATOR = 4288193352;
  var IFCACTUATORTYPE = 2874132201;
  var IFCADDRESS = 618182010;
  var IFCADVANCEDBREP = 1635779807;
  var IFCADVANCEDBREPWITHVOIDS = 2603310189;
  var IFCADVANCEDFACE = 3406155212;
  var IFCAIRTERMINAL = 1634111441;
  var IFCAIRTERMINALBOX = 177149247;
  var IFCAIRTERMINALBOXTYPE = 1411407467;
  var IFCAIRTERMINALTYPE = 3352864051;
  var IFCAIRTOAIRHEATRECOVERY = 2056796094;
  var IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353;
  var IFCALARM = 3087945054;
  var IFCALARMTYPE = 3001207471;
  var IFCALIGNMENT = 325726236;
  var IFCALIGNMENT2DHORIZONTAL = 749761778;
  var IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722;
  var IFCALIGNMENT2DSEGMENT = 2483840362;
  var IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081;
  var IFCALIGNMENT2DVERSEGLINE = 3239324667;
  var IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512;
  var IFCALIGNMENT2DVERTICAL = 53199957;
  var IFCALIGNMENT2DVERTICALSEGMENT = 2029264950;
  var IFCALIGNMENTCURVE = 3512275521;
  var IFCANNOTATION = 1674181508;
  var IFCANNOTATIONFILLAREA = 669184980;
  var IFCAPPLICATION = 639542469;
  var IFCAPPLIEDVALUE = 411424972;
  var IFCAPPROVAL = 130549933;
  var IFCAPPROVALRELATIONSHIP = 3869604511;
  var IFCARBITRARYCLOSEDPROFILEDEF = 3798115385;
  var IFCARBITRARYOPENPROFILEDEF = 1310608509;
  var IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697;
  var IFCASSET = 3460190687;
  var IFCASYMMETRICISHAPEPROFILEDEF = 3207858831;
  var IFCAUDIOVISUALAPPLIANCE = 277319702;
  var IFCAUDIOVISUALAPPLIANCETYPE = 1532957894;
  var IFCAXIS1PLACEMENT = 4261334040;
  var IFCAXIS2PLACEMENT2D = 3125803723;
  var IFCAXIS2PLACEMENT3D = 2740243338;
  var IFCBSPLINECURVE = 1967976161;
  var IFCBSPLINECURVEWITHKNOTS = 2461110595;
  var IFCBSPLINESURFACE = 2887950389;
  var IFCBSPLINESURFACEWITHKNOTS = 167062518;
  var IFCBEAM = 753842376;
  var IFCBEAMSTANDARDCASE = 2906023776;
  var IFCBEAMTYPE = 819618141;
  var IFCBEARING = 4196446775;
  var IFCBEARINGTYPE = 3649138523;
  var IFCBLOBTEXTURE = 616511568;
  var IFCBLOCK = 1334484129;
  var IFCBOILER = 32344328;
  var IFCBOILERTYPE = 231477066;
  var IFCBOOLEANCLIPPINGRESULT = 3649129432;
  var IFCBOOLEANRESULT = 2736907675;
  var IFCBOUNDARYCONDITION = 4037036970;
  var IFCBOUNDARYCURVE = 1136057603;
  var IFCBOUNDARYEDGECONDITION = 1560379544;
  var IFCBOUNDARYFACECONDITION = 3367102660;
  var IFCBOUNDARYNODECONDITION = 1387855156;
  var IFCBOUNDARYNODECONDITIONWARPING = 2069777674;
  var IFCBOUNDEDCURVE = 1260505505;
  var IFCBOUNDEDSURFACE = 4182860854;
  var IFCBOUNDINGBOX = 2581212453;
  var IFCBOXEDHALFSPACE = 2713105998;
  var IFCBRIDGE = 644574406;
  var IFCBRIDGEPART = 963979645;
  var IFCBUILDING = 4031249490;
  var IFCBUILDINGELEMENT = 3299480353;
  var IFCBUILDINGELEMENTPART = 2979338954;
  var IFCBUILDINGELEMENTPARTTYPE = 39481116;
  var IFCBUILDINGELEMENTPROXY = 1095909175;
  var IFCBUILDINGELEMENTPROXYTYPE = 1909888760;
  var IFCBUILDINGELEMENTTYPE = 1950629157;
  var IFCBUILDINGSTOREY = 3124254112;
  var IFCBUILDINGSYSTEM = 1177604601;
  var IFCBURNER = 2938176219;
  var IFCBURNERTYPE = 2188180465;
  var IFCCSHAPEPROFILEDEF = 2898889636;
  var IFCCABLECARRIERFITTING = 635142910;
  var IFCCABLECARRIERFITTINGTYPE = 395041908;
  var IFCCABLECARRIERSEGMENT = 3758799889;
  var IFCCABLECARRIERSEGMENTTYPE = 3293546465;
  var IFCCABLEFITTING = 1051757585;
  var IFCCABLEFITTINGTYPE = 2674252688;
  var IFCCABLESEGMENT = 4217484030;
  var IFCCABLESEGMENTTYPE = 1285652485;
  var IFCCAISSONFOUNDATION = 3999819293;
  var IFCCAISSONFOUNDATIONTYPE = 3203706013;
  var IFCCARTESIANPOINT = 1123145078;
  var IFCCARTESIANPOINTLIST = 574549367;
  var IFCCARTESIANPOINTLIST2D = 1675464909;
  var IFCCARTESIANPOINTLIST3D = 2059837836;
  var IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748;
  var IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601;
  var IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946;
  var IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920;
  var IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885;
  var IFCCENTERLINEPROFILEDEF = 3150382593;
  var IFCCHILLER = 3902619387;
  var IFCCHILLERTYPE = 2951183804;
  var IFCCHIMNEY = 3296154744;
  var IFCCHIMNEYTYPE = 2197970202;
  var IFCCIRCLE = 2611217952;
  var IFCCIRCLEHOLLOWPROFILEDEF = 2937912522;
  var IFCCIRCLEPROFILEDEF = 1383045692;
  var IFCCIRCULARARCSEGMENT2D = 1062206242;
  var IFCCIVILELEMENT = 1677625105;
  var IFCCIVILELEMENTTYPE = 3893394355;
  var IFCCLASSIFICATION = 747523909;
  var IFCCLASSIFICATIONREFERENCE = 647927063;
  var IFCCLOSEDSHELL = 2205249479;
  var IFCCOIL = 639361253;
  var IFCCOILTYPE = 2301859152;
  var IFCCOLOURRGB = 776857604;
  var IFCCOLOURRGBLIST = 3285139300;
  var IFCCOLOURSPECIFICATION = 3264961684;
  var IFCCOLUMN = 843113511;
  var IFCCOLUMNSTANDARDCASE = 905975707;
  var IFCCOLUMNTYPE = 300633059;
  var IFCCOMMUNICATIONSAPPLIANCE = 3221913625;
  var IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858;
  var IFCCOMPLEXPROPERTY = 2542286263;
  var IFCCOMPLEXPROPERTYTEMPLATE = 3875453745;
  var IFCCOMPOSITECURVE = 3732776249;
  var IFCCOMPOSITECURVEONSURFACE = 15328376;
  var IFCCOMPOSITECURVESEGMENT = 2485617015;
  var IFCCOMPOSITEPROFILEDEF = 1485152156;
  var IFCCOMPRESSOR = 3571504051;
  var IFCCOMPRESSORTYPE = 3850581409;
  var IFCCONDENSER = 2272882330;
  var IFCCONDENSERTYPE = 2816379211;
  var IFCCONIC = 2510884976;
  var IFCCONNECTEDFACESET = 370225590;
  var IFCCONNECTIONCURVEGEOMETRY = 1981873012;
  var IFCCONNECTIONGEOMETRY = 2859738748;
  var IFCCONNECTIONPOINTECCENTRICITY = 45288368;
  var IFCCONNECTIONPOINTGEOMETRY = 2614616156;
  var IFCCONNECTIONSURFACEGEOMETRY = 2732653382;
  var IFCCONNECTIONVOLUMEGEOMETRY = 775493141;
  var IFCCONSTRAINT = 1959218052;
  var IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240;
  var IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099;
  var IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209;
  var IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743;
  var IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124;
  var IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444;
  var IFCCONSTRUCTIONRESOURCE = 2559216714;
  var IFCCONSTRUCTIONRESOURCETYPE = 2574617495;
  var IFCCONTEXT = 3419103109;
  var IFCCONTEXTDEPENDENTUNIT = 3050246964;
  var IFCCONTROL = 3293443760;
  var IFCCONTROLLER = 25142252;
  var IFCCONTROLLERTYPE = 578613899;
  var IFCCONVERSIONBASEDUNIT = 2889183280;
  var IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722;
  var IFCCOOLEDBEAM = 4136498852;
  var IFCCOOLEDBEAMTYPE = 335055490;
  var IFCCOOLINGTOWER = 3640358203;
  var IFCCOOLINGTOWERTYPE = 2954562838;
  var IFCCOORDINATEOPERATION = 1785450214;
  var IFCCOORDINATEREFERENCESYSTEM = 1466758467;
  var IFCCOSTITEM = 3895139033;
  var IFCCOSTSCHEDULE = 1419761937;
  var IFCCOSTVALUE = 602808272;
  var IFCCOVERING = 1973544240;
  var IFCCOVERINGTYPE = 1916426348;
  var IFCCREWRESOURCE = 3295246426;
  var IFCCREWRESOURCETYPE = 1815067380;
  var IFCCSGPRIMITIVE3D = 2506170314;
  var IFCCSGSOLID = 2147822146;
  var IFCCURRENCYRELATIONSHIP = 539742890;
  var IFCCURTAINWALL = 3495092785;
  var IFCCURTAINWALLTYPE = 1457835157;
  var IFCCURVE = 2601014836;
  var IFCCURVEBOUNDEDPLANE = 2827736869;
  var IFCCURVEBOUNDEDSURFACE = 2629017746;
  var IFCCURVESEGMENT2D = 1186437898;
  var IFCCURVESTYLE = 3800577675;
  var IFCCURVESTYLEFONT = 1105321065;
  var IFCCURVESTYLEFONTANDSCALING = 2367409068;
  var IFCCURVESTYLEFONTPATTERN = 3510044353;
  var IFCCYLINDRICALSURFACE = 1213902940;
  var IFCDAMPER = 4074379575;
  var IFCDAMPERTYPE = 3961806047;
  var IFCDEEPFOUNDATION = 3426335179;
  var IFCDEEPFOUNDATIONTYPE = 1306400036;
  var IFCDERIVEDPROFILEDEF = 3632507154;
  var IFCDERIVEDUNIT = 1765591967;
  var IFCDERIVEDUNITELEMENT = 1045800335;
  var IFCDIMENSIONALEXPONENTS = 2949456006;
  var IFCDIRECTION = 32440307;
  var IFCDISCRETEACCESSORY = 1335981549;
  var IFCDISCRETEACCESSORYTYPE = 2635815018;
  var IFCDISTANCEEXPRESSION = 1945343521;
  var IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943;
  var IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980;
  var IFCDISTRIBUTIONCIRCUIT = 562808652;
  var IFCDISTRIBUTIONCONTROLELEMENT = 1062813311;
  var IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501;
  var IFCDISTRIBUTIONELEMENT = 1945004755;
  var IFCDISTRIBUTIONELEMENTTYPE = 3256556792;
  var IFCDISTRIBUTIONFLOWELEMENT = 3040386961;
  var IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793;
  var IFCDISTRIBUTIONPORT = 3041715199;
  var IFCDISTRIBUTIONSYSTEM = 3205830791;
  var IFCDOCUMENTINFORMATION = 1154170062;
  var IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208;
  var IFCDOCUMENTREFERENCE = 3732053477;
  var IFCDOOR = 395920057;
  var IFCDOORLININGPROPERTIES = 2963535650;
  var IFCDOORPANELPROPERTIES = 1714330368;
  var IFCDOORSTANDARDCASE = 3242481149;
  var IFCDOORSTYLE = 526551008;
  var IFCDOORTYPE = 2323601079;
  var IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917;
  var IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654;
  var IFCDUCTFITTING = 342316401;
  var IFCDUCTFITTINGTYPE = 869906466;
  var IFCDUCTSEGMENT = 3518393246;
  var IFCDUCTSEGMENTTYPE = 3760055223;
  var IFCDUCTSILENCER = 1360408905;
  var IFCDUCTSILENCERTYPE = 2030761528;
  var IFCEDGE = 3900360178;
  var IFCEDGECURVE = 476780140;
  var IFCEDGELOOP = 1472233963;
  var IFCELECTRICAPPLIANCE = 1904799276;
  var IFCELECTRICAPPLIANCETYPE = 663422040;
  var IFCELECTRICDISTRIBUTIONBOARD = 862014818;
  var IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758;
  var IFCELECTRICFLOWSTORAGEDEVICE = 3310460725;
  var IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161;
  var IFCELECTRICGENERATOR = 264262732;
  var IFCELECTRICGENERATORTYPE = 1534661035;
  var IFCELECTRICMOTOR = 402227799;
  var IFCELECTRICMOTORTYPE = 1217240411;
  var IFCELECTRICTIMECONTROL = 1003880860;
  var IFCELECTRICTIMECONTROLTYPE = 712377611;
  var IFCELEMENT = 1758889154;
  var IFCELEMENTASSEMBLY = 4123344466;
  var IFCELEMENTASSEMBLYTYPE = 2397081782;
  var IFCELEMENTCOMPONENT = 1623761950;
  var IFCELEMENTCOMPONENTTYPE = 2590856083;
  var IFCELEMENTQUANTITY = 1883228015;
  var IFCELEMENTTYPE = 339256511;
  var IFCELEMENTARYSURFACE = 2777663545;
  var IFCELLIPSE = 1704287377;
  var IFCELLIPSEPROFILEDEF = 2835456948;
  var IFCENERGYCONVERSIONDEVICE = 1658829314;
  var IFCENERGYCONVERSIONDEVICETYPE = 2107101300;
  var IFCENGINE = 2814081492;
  var IFCENGINETYPE = 132023988;
  var IFCEVAPORATIVECOOLER = 3747195512;
  var IFCEVAPORATIVECOOLERTYPE = 3174744832;
  var IFCEVAPORATOR = 484807127;
  var IFCEVAPORATORTYPE = 3390157468;
  var IFCEVENT = 4148101412;
  var IFCEVENTTIME = 211053100;
  var IFCEVENTTYPE = 4024345920;
  var IFCEXTENDEDPROPERTIES = 297599258;
  var IFCEXTERNALINFORMATION = 4294318154;
  var IFCEXTERNALREFERENCE = 3200245327;
  var IFCEXTERNALREFERENCERELATIONSHIP = 1437805879;
  var IFCEXTERNALSPATIALELEMENT = 1209101575;
  var IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674;
  var IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968;
  var IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647;
  var IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201;
  var IFCEXTRUDEDAREASOLID = 477187591;
  var IFCEXTRUDEDAREASOLIDTAPERED = 2804161546;
  var IFCFACE = 2556980723;
  var IFCFACEBASEDSURFACEMODEL = 2047409740;
  var IFCFACEBOUND = 1809719519;
  var IFCFACEOUTERBOUND = 803316827;
  var IFCFACESURFACE = 3008276851;
  var IFCFACETEDBREP = 807026263;
  var IFCFACETEDBREPWITHVOIDS = 3737207727;
  var IFCFACILITY = 24185140;
  var IFCFACILITYPART = 1310830890;
  var IFCFAILURECONNECTIONCONDITION = 4219587988;
  var IFCFAN = 3415622556;
  var IFCFANTYPE = 346874300;
  var IFCFASTENER = 647756555;
  var IFCFASTENERTYPE = 2489546625;
  var IFCFEATUREELEMENT = 2827207264;
  var IFCFEATUREELEMENTADDITION = 2143335405;
  var IFCFEATUREELEMENTSUBTRACTION = 1287392070;
  var IFCFILLAREASTYLE = 738692330;
  var IFCFILLAREASTYLEHATCHING = 374418227;
  var IFCFILLAREASTYLETILES = 315944413;
  var IFCFILTER = 819412036;
  var IFCFILTERTYPE = 1810631287;
  var IFCFIRESUPPRESSIONTERMINAL = 1426591983;
  var IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408;
  var IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860;
  var IFCFLOWCONTROLLER = 2058353004;
  var IFCFLOWCONTROLLERTYPE = 3907093117;
  var IFCFLOWFITTING = 4278956645;
  var IFCFLOWFITTINGTYPE = 3198132628;
  var IFCFLOWINSTRUMENT = 182646315;
  var IFCFLOWINSTRUMENTTYPE = 4037862832;
  var IFCFLOWMETER = 2188021234;
  var IFCFLOWMETERTYPE = 3815607619;
  var IFCFLOWMOVINGDEVICE = 3132237377;
  var IFCFLOWMOVINGDEVICETYPE = 1482959167;
  var IFCFLOWSEGMENT = 987401354;
  var IFCFLOWSEGMENTTYPE = 1834744321;
  var IFCFLOWSTORAGEDEVICE = 707683696;
  var IFCFLOWSTORAGEDEVICETYPE = 1339347760;
  var IFCFLOWTERMINAL = 2223149337;
  var IFCFLOWTERMINALTYPE = 2297155007;
  var IFCFLOWTREATMENTDEVICE = 3508470533;
  var IFCFLOWTREATMENTDEVICETYPE = 3009222698;
  var IFCFOOTING = 900683007;
  var IFCFOOTINGTYPE = 1893162501;
  var IFCFURNISHINGELEMENT = 263784265;
  var IFCFURNISHINGELEMENTTYPE = 4238390223;
  var IFCFURNITURE = 1509553395;
  var IFCFURNITURETYPE = 1268542332;
  var IFCGEOGRAPHICELEMENT = 3493046030;
  var IFCGEOGRAPHICELEMENTTYPE = 4095422895;
  var IFCGEOMETRICCURVESET = 987898635;
  var IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350;
  var IFCGEOMETRICREPRESENTATIONITEM = 2453401579;
  var IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618;
  var IFCGEOMETRICSET = 3590301190;
  var IFCGRID = 3009204131;
  var IFCGRIDAXIS = 852622518;
  var IFCGRIDPLACEMENT = 178086475;
  var IFCGROUP = 2706460486;
  var IFCHALFSPACESOLID = 812098782;
  var IFCHEATEXCHANGER = 3319311131;
  var IFCHEATEXCHANGERTYPE = 1251058090;
  var IFCHUMIDIFIER = 2068733104;
  var IFCHUMIDIFIERTYPE = 1806887404;
  var IFCISHAPEPROFILEDEF = 1484403080;
  var IFCIMAGETEXTURE = 3905492369;
  var IFCINDEXEDCOLOURMAP = 3570813810;
  var IFCINDEXEDPOLYCURVE = 2571569899;
  var IFCINDEXEDPOLYGONALFACE = 178912537;
  var IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976;
  var IFCINDEXEDTEXTUREMAP = 1437953363;
  var IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955;
  var IFCINTERCEPTOR = 4175244083;
  var IFCINTERCEPTORTYPE = 3946677679;
  var IFCINTERSECTIONCURVE = 3113134337;
  var IFCINVENTORY = 2391368822;
  var IFCIRREGULARTIMESERIES = 3741457305;
  var IFCIRREGULARTIMESERIESVALUE = 3020489413;
  var IFCJUNCTIONBOX = 2176052936;
  var IFCJUNCTIONBOXTYPE = 4288270099;
  var IFCLSHAPEPROFILEDEF = 572779678;
  var IFCLABORRESOURCE = 3827777499;
  var IFCLABORRESOURCETYPE = 428585644;
  var IFCLAGTIME = 1585845231;
  var IFCLAMP = 76236018;
  var IFCLAMPTYPE = 1051575348;
  var IFCLIBRARYINFORMATION = 2655187982;
  var IFCLIBRARYREFERENCE = 3452421091;
  var IFCLIGHTDISTRIBUTIONDATA = 4162380809;
  var IFCLIGHTFIXTURE = 629592764;
  var IFCLIGHTFIXTURETYPE = 1161773419;
  var IFCLIGHTINTENSITYDISTRIBUTION = 1566485204;
  var IFCLIGHTSOURCE = 1402838566;
  var IFCLIGHTSOURCEAMBIENT = 125510826;
  var IFCLIGHTSOURCEDIRECTIONAL = 2604431987;
  var IFCLIGHTSOURCEGONIOMETRIC = 4266656042;
  var IFCLIGHTSOURCEPOSITIONAL = 1520743889;
  var IFCLIGHTSOURCESPOT = 3422422726;
  var IFCLINE = 1281925730;
  var IFCLINESEGMENT2D = 3092502836;
  var IFCLINEARPLACEMENT = 388784114;
  var IFCLINEARPOSITIONINGELEMENT = 1154579445;
  var IFCLOCALPLACEMENT = 2624227202;
  var IFCLOOP = 1008929658;
  var IFCMANIFOLDSOLIDBREP = 1425443689;
  var IFCMAPCONVERSION = 3057273783;
  var IFCMAPPEDITEM = 2347385850;
  var IFCMATERIAL = 1838606355;
  var IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766;
  var IFCMATERIALCONSTITUENT = 3708119e3;
  var IFCMATERIALCONSTITUENTSET = 2852063980;
  var IFCMATERIALDEFINITION = 760658860;
  var IFCMATERIALDEFINITIONREPRESENTATION = 2022407955;
  var IFCMATERIALLAYER = 248100487;
  var IFCMATERIALLAYERSET = 3303938423;
  var IFCMATERIALLAYERSETUSAGE = 1303795690;
  var IFCMATERIALLAYERWITHOFFSETS = 1847252529;
  var IFCMATERIALLIST = 2199411900;
  var IFCMATERIALPROFILE = 2235152071;
  var IFCMATERIALPROFILESET = 164193824;
  var IFCMATERIALPROFILESETUSAGE = 3079605661;
  var IFCMATERIALPROFILESETUSAGETAPERING = 3404854881;
  var IFCMATERIALPROFILEWITHOFFSETS = 552965576;
  var IFCMATERIALPROPERTIES = 3265635763;
  var IFCMATERIALRELATIONSHIP = 853536259;
  var IFCMATERIALUSAGEDEFINITION = 1507914824;
  var IFCMEASUREWITHUNIT = 2597039031;
  var IFCMECHANICALFASTENER = 377706215;
  var IFCMECHANICALFASTENERTYPE = 2108223431;
  var IFCMEDICALDEVICE = 1437502449;
  var IFCMEDICALDEVICETYPE = 1114901282;
  var IFCMEMBER = 1073191201;
  var IFCMEMBERSTANDARDCASE = 1911478936;
  var IFCMEMBERTYPE = 3181161470;
  var IFCMETRIC = 3368373690;
  var IFCMIRROREDPROFILEDEF = 2998442950;
  var IFCMONETARYUNIT = 2706619895;
  var IFCMOTORCONNECTION = 2474470126;
  var IFCMOTORCONNECTIONTYPE = 977012517;
  var IFCNAMEDUNIT = 1918398963;
  var IFCOBJECT = 3888040117;
  var IFCOBJECTDEFINITION = 219451334;
  var IFCOBJECTPLACEMENT = 3701648758;
  var IFCOBJECTIVE = 2251480897;
  var IFCOCCUPANT = 4143007308;
  var IFCOFFSETCURVE = 590820931;
  var IFCOFFSETCURVE2D = 3388369263;
  var IFCOFFSETCURVE3D = 3505215534;
  var IFCOFFSETCURVEBYDISTANCES = 2485787929;
  var IFCOPENSHELL = 2665983363;
  var IFCOPENINGELEMENT = 3588315303;
  var IFCOPENINGSTANDARDCASE = 3079942009;
  var IFCORGANIZATION = 4251960020;
  var IFCORGANIZATIONRELATIONSHIP = 1411181986;
  var IFCORIENTATIONEXPRESSION = 643959842;
  var IFCORIENTEDEDGE = 1029017970;
  var IFCOUTERBOUNDARYCURVE = 144952367;
  var IFCOUTLET = 3694346114;
  var IFCOUTLETTYPE = 2837617999;
  var IFCOWNERHISTORY = 1207048766;
  var IFCPARAMETERIZEDPROFILEDEF = 2529465313;
  var IFCPATH = 2519244187;
  var IFCPCURVE = 1682466193;
  var IFCPERFORMANCEHISTORY = 2382730787;
  var IFCPERMEABLECOVERINGPROPERTIES = 3566463478;
  var IFCPERMIT = 3327091369;
  var IFCPERSON = 2077209135;
  var IFCPERSONANDORGANIZATION = 101040310;
  var IFCPHYSICALCOMPLEXQUANTITY = 3021840470;
  var IFCPHYSICALQUANTITY = 2483315170;
  var IFCPHYSICALSIMPLEQUANTITY = 2226359599;
  var IFCPILE = 1687234759;
  var IFCPILETYPE = 1158309216;
  var IFCPIPEFITTING = 310824031;
  var IFCPIPEFITTINGTYPE = 804291784;
  var IFCPIPESEGMENT = 3612865200;
  var IFCPIPESEGMENTTYPE = 4231323485;
  var IFCPIXELTEXTURE = 597895409;
  var IFCPLACEMENT = 2004835150;
  var IFCPLANARBOX = 603570806;
  var IFCPLANAREXTENT = 1663979128;
  var IFCPLANE = 220341763;
  var IFCPLATE = 3171933400;
  var IFCPLATESTANDARDCASE = 1156407060;
  var IFCPLATETYPE = 4017108033;
  var IFCPOINT = 2067069095;
  var IFCPOINTONCURVE = 4022376103;
  var IFCPOINTONSURFACE = 1423911732;
  var IFCPOLYLOOP = 2924175390;
  var IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180;
  var IFCPOLYGONALFACESET = 2839578677;
  var IFCPOLYLINE = 3724593414;
  var IFCPORT = 3740093272;
  var IFCPOSITIONINGELEMENT = 1946335990;
  var IFCPOSTALADDRESS = 3355820592;
  var IFCPREDEFINEDCOLOUR = 759155922;
  var IFCPREDEFINEDCURVEFONT = 2559016684;
  var IFCPREDEFINEDITEM = 3727388367;
  var IFCPREDEFINEDPROPERTIES = 3778827333;
  var IFCPREDEFINEDPROPERTYSET = 3967405729;
  var IFCPREDEFINEDTEXTFONT = 1775413392;
  var IFCPRESENTATIONITEM = 677532197;
  var IFCPRESENTATIONLAYERASSIGNMENT = 2022622350;
  var IFCPRESENTATIONLAYERWITHSTYLE = 1304840413;
  var IFCPRESENTATIONSTYLE = 3119450353;
  var IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796;
  var IFCPROCEDURE = 2744685151;
  var IFCPROCEDURETYPE = 569719735;
  var IFCPROCESS = 2945172077;
  var IFCPRODUCT = 4208778838;
  var IFCPRODUCTDEFINITIONSHAPE = 673634403;
  var IFCPRODUCTREPRESENTATION = 2095639259;
  var IFCPROFILEDEF = 3958567839;
  var IFCPROFILEPROPERTIES = 2802850158;
  var IFCPROJECT = 103090709;
  var IFCPROJECTLIBRARY = 653396225;
  var IFCPROJECTORDER = 2904328755;
  var IFCPROJECTEDCRS = 3843373140;
  var IFCPROJECTIONELEMENT = 3651124850;
  var IFCPROPERTY = 2598011224;
  var IFCPROPERTYABSTRACTION = 986844984;
  var IFCPROPERTYBOUNDEDVALUE = 871118103;
  var IFCPROPERTYDEFINITION = 1680319473;
  var IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276;
  var IFCPROPERTYENUMERATEDVALUE = 4166981789;
  var IFCPROPERTYENUMERATION = 3710013099;
  var IFCPROPERTYLISTVALUE = 2752243245;
  var IFCPROPERTYREFERENCEVALUE = 941946838;
  var IFCPROPERTYSET = 1451395588;
  var IFCPROPERTYSETDEFINITION = 3357820518;
  var IFCPROPERTYSETTEMPLATE = 492091185;
  var IFCPROPERTYSINGLEVALUE = 3650150729;
  var IFCPROPERTYTABLEVALUE = 110355661;
  var IFCPROPERTYTEMPLATE = 3521284610;
  var IFCPROPERTYTEMPLATEDEFINITION = 1482703590;
  var IFCPROTECTIVEDEVICE = 738039164;
  var IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155;
  var IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474;
  var IFCPROTECTIVEDEVICETYPE = 1842657554;
  var IFCPROXY = 3219374653;
  var IFCPUMP = 90941305;
  var IFCPUMPTYPE = 2250791053;
  var IFCQUANTITYAREA = 2044713172;
  var IFCQUANTITYCOUNT = 2093928680;
  var IFCQUANTITYLENGTH = 931644368;
  var IFCQUANTITYSET = 2090586900;
  var IFCQUANTITYTIME = 3252649465;
  var IFCQUANTITYVOLUME = 2405470396;
  var IFCQUANTITYWEIGHT = 825690147;
  var IFCRAILING = 2262370178;
  var IFCRAILINGTYPE = 2893384427;
  var IFCRAMP = 3024970846;
  var IFCRAMPFLIGHT = 3283111854;
  var IFCRAMPFLIGHTTYPE = 2324767716;
  var IFCRAMPTYPE = 1469900589;
  var IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972;
  var IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671;
  var IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689;
  var IFCRECTANGLEPROFILEDEF = 3615266464;
  var IFCRECTANGULARPYRAMID = 2798486643;
  var IFCRECTANGULARTRIMMEDSURFACE = 3454111270;
  var IFCRECURRENCEPATTERN = 3915482550;
  var IFCREFERENCE = 2433181523;
  var IFCREFERENT = 4021432810;
  var IFCREGULARTIMESERIES = 3413951693;
  var IFCREINFORCEMENTBARPROPERTIES = 1580146022;
  var IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017;
  var IFCREINFORCINGBAR = 979691226;
  var IFCREINFORCINGBARTYPE = 2572171363;
  var IFCREINFORCINGELEMENT = 3027567501;
  var IFCREINFORCINGELEMENTTYPE = 964333572;
  var IFCREINFORCINGMESH = 2320036040;
  var IFCREINFORCINGMESHTYPE = 2310774935;
  var IFCRELAGGREGATES = 160246688;
  var IFCRELASSIGNS = 3939117080;
  var IFCRELASSIGNSTOACTOR = 1683148259;
  var IFCRELASSIGNSTOCONTROL = 2495723537;
  var IFCRELASSIGNSTOGROUP = 1307041759;
  var IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054;
  var IFCRELASSIGNSTOPROCESS = 4278684876;
  var IFCRELASSIGNSTOPRODUCT = 2857406711;
  var IFCRELASSIGNSTORESOURCE = 205026976;
  var IFCRELASSOCIATES = 1865459582;
  var IFCRELASSOCIATESAPPROVAL = 4095574036;
  var IFCRELASSOCIATESCLASSIFICATION = 919958153;
  var IFCRELASSOCIATESCONSTRAINT = 2728634034;
  var IFCRELASSOCIATESDOCUMENT = 982818633;
  var IFCRELASSOCIATESLIBRARY = 3840914261;
  var IFCRELASSOCIATESMATERIAL = 2655215786;
  var IFCRELCONNECTS = 826625072;
  var IFCRELCONNECTSELEMENTS = 1204542856;
  var IFCRELCONNECTSPATHELEMENTS = 3945020480;
  var IFCRELCONNECTSPORTTOELEMENT = 4201705270;
  var IFCRELCONNECTSPORTS = 3190031847;
  var IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289;
  var IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189;
  var IFCRELCONNECTSWITHECCENTRICITY = 504942748;
  var IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232;
  var IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779;
  var IFCRELCOVERSBLDGELEMENTS = 886880790;
  var IFCRELCOVERSSPACES = 2802773753;
  var IFCRELDECLARES = 2565941209;
  var IFCRELDECOMPOSES = 2551354335;
  var IFCRELDEFINES = 693640335;
  var IFCRELDEFINESBYOBJECT = 1462361463;
  var IFCRELDEFINESBYPROPERTIES = 4186316022;
  var IFCRELDEFINESBYTEMPLATE = 307848117;
  var IFCRELDEFINESBYTYPE = 781010003;
  var IFCRELFILLSELEMENT = 3940055652;
  var IFCRELFLOWCONTROLELEMENTS = 279856033;
  var IFCRELINTERFERESELEMENTS = 427948657;
  var IFCRELNESTS = 3268803585;
  var IFCRELPOSITIONS = 1441486842;
  var IFCRELPROJECTSELEMENT = 750771296;
  var IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292;
  var IFCRELSEQUENCE = 4122056220;
  var IFCRELSERVICESBUILDINGS = 366585022;
  var IFCRELSPACEBOUNDARY = 3451746338;
  var IFCRELSPACEBOUNDARY1STLEVEL = 3523091289;
  var IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863;
  var IFCRELVOIDSELEMENT = 1401173127;
  var IFCRELATIONSHIP = 478536968;
  var IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949;
  var IFCREPRESENTATION = 1076942058;
  var IFCREPRESENTATIONCONTEXT = 3377609919;
  var IFCREPRESENTATIONITEM = 3008791417;
  var IFCREPRESENTATIONMAP = 1660063152;
  var IFCRESOURCE = 2914609552;
  var IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501;
  var IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552;
  var IFCRESOURCELEVELRELATIONSHIP = 2439245199;
  var IFCRESOURCETIME = 1042787934;
  var IFCREVOLVEDAREASOLID = 1856042241;
  var IFCREVOLVEDAREASOLIDTAPERED = 3243963512;
  var IFCRIGHTCIRCULARCONE = 4158566097;
  var IFCRIGHTCIRCULARCYLINDER = 3626867408;
  var IFCROOF = 2016517767;
  var IFCROOFTYPE = 2781568857;
  var IFCROOT = 2341007311;
  var IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089;
  var IFCSIUNIT = 448429030;
  var IFCSANITARYTERMINAL = 3053780830;
  var IFCSANITARYTERMINALTYPE = 1768891740;
  var IFCSCHEDULINGTIME = 1054537805;
  var IFCSEAMCURVE = 2157484638;
  var IFCSECTIONPROPERTIES = 2042790032;
  var IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628;
  var IFCSECTIONEDSOLID = 1862484736;
  var IFCSECTIONEDSOLIDHORIZONTAL = 1290935644;
  var IFCSECTIONEDSPINE = 1509187699;
  var IFCSENSOR = 4086658281;
  var IFCSENSORTYPE = 1783015770;
  var IFCSHADINGDEVICE = 1329646415;
  var IFCSHADINGDEVICETYPE = 4074543187;
  var IFCSHAPEASPECT = 867548509;
  var IFCSHAPEMODEL = 3982875396;
  var IFCSHAPEREPRESENTATION = 4240577450;
  var IFCSHELLBASEDSURFACEMODEL = 4124623270;
  var IFCSIMPLEPROPERTY = 3692461612;
  var IFCSIMPLEPROPERTYTEMPLATE = 3663146110;
  var IFCSITE = 4097777520;
  var IFCSLAB = 1529196076;
  var IFCSLABELEMENTEDCASE = 3127900445;
  var IFCSLABSTANDARDCASE = 3027962421;
  var IFCSLABTYPE = 2533589738;
  var IFCSLIPPAGECONNECTIONCONDITION = 2609359061;
  var IFCSOLARDEVICE = 3420628829;
  var IFCSOLARDEVICETYPE = 1072016465;
  var IFCSOLIDMODEL = 723233188;
  var IFCSPACE = 3856911033;
  var IFCSPACEHEATER = 1999602285;
  var IFCSPACEHEATERTYPE = 1305183839;
  var IFCSPACETYPE = 3812236995;
  var IFCSPATIALELEMENT = 1412071761;
  var IFCSPATIALELEMENTTYPE = 710998568;
  var IFCSPATIALSTRUCTUREELEMENT = 2706606064;
  var IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262;
  var IFCSPATIALZONE = 463610769;
  var IFCSPATIALZONETYPE = 2481509218;
  var IFCSPHERE = 451544542;
  var IFCSPHERICALSURFACE = 4015995234;
  var IFCSTACKTERMINAL = 1404847402;
  var IFCSTACKTERMINALTYPE = 3112655638;
  var IFCSTAIR = 331165859;
  var IFCSTAIRFLIGHT = 4252922144;
  var IFCSTAIRFLIGHTTYPE = 1039846685;
  var IFCSTAIRTYPE = 338393293;
  var IFCSTRUCTURALACTION = 682877961;
  var IFCSTRUCTURALACTIVITY = 3544373492;
  var IFCSTRUCTURALANALYSISMODEL = 2515109513;
  var IFCSTRUCTURALCONNECTION = 1179482911;
  var IFCSTRUCTURALCONNECTIONCONDITION = 2273995522;
  var IFCSTRUCTURALCURVEACTION = 1004757350;
  var IFCSTRUCTURALCURVECONNECTION = 4243806635;
  var IFCSTRUCTURALCURVEMEMBER = 214636428;
  var IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289;
  var IFCSTRUCTURALCURVEREACTION = 2757150158;
  var IFCSTRUCTURALITEM = 3136571912;
  var IFCSTRUCTURALLINEARACTION = 1807405624;
  var IFCSTRUCTURALLOAD = 2162789131;
  var IFCSTRUCTURALLOADCASE = 385403989;
  var IFCSTRUCTURALLOADCONFIGURATION = 3478079324;
  var IFCSTRUCTURALLOADGROUP = 1252848954;
  var IFCSTRUCTURALLOADLINEARFORCE = 1595516126;
  var IFCSTRUCTURALLOADORRESULT = 609421318;
  var IFCSTRUCTURALLOADPLANARFORCE = 2668620305;
  var IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415;
  var IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258;
  var IFCSTRUCTURALLOADSINGLEFORCE = 1597423693;
  var IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807;
  var IFCSTRUCTURALLOADSTATIC = 2525727697;
  var IFCSTRUCTURALLOADTEMPERATURE = 3408363356;
  var IFCSTRUCTURALMEMBER = 530289379;
  var IFCSTRUCTURALPLANARACTION = 1621171031;
  var IFCSTRUCTURALPOINTACTION = 2082059205;
  var IFCSTRUCTURALPOINTCONNECTION = 734778138;
  var IFCSTRUCTURALPOINTREACTION = 1235345126;
  var IFCSTRUCTURALREACTION = 3689010777;
  var IFCSTRUCTURALRESULTGROUP = 2986769608;
  var IFCSTRUCTURALSURFACEACTION = 3657597509;
  var IFCSTRUCTURALSURFACECONNECTION = 1975003073;
  var IFCSTRUCTURALSURFACEMEMBER = 3979015343;
  var IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070;
  var IFCSTRUCTURALSURFACEREACTION = 603775116;
  var IFCSTYLEMODEL = 2830218821;
  var IFCSTYLEDITEM = 3958052878;
  var IFCSTYLEDREPRESENTATION = 3049322572;
  var IFCSUBCONTRACTRESOURCE = 148013059;
  var IFCSUBCONTRACTRESOURCETYPE = 4095615324;
  var IFCSUBEDGE = 2233826070;
  var IFCSURFACE = 2513912981;
  var IFCSURFACECURVE = 699246055;
  var IFCSURFACECURVESWEPTAREASOLID = 2028607225;
  var IFCSURFACEFEATURE = 3101698114;
  var IFCSURFACEOFLINEAREXTRUSION = 2809605785;
  var IFCSURFACEOFREVOLUTION = 4124788165;
  var IFCSURFACEREINFORCEMENTAREA = 2934153892;
  var IFCSURFACESTYLE = 1300840506;
  var IFCSURFACESTYLELIGHTING = 3303107099;
  var IFCSURFACESTYLEREFRACTION = 1607154358;
  var IFCSURFACESTYLERENDERING = 1878645084;
  var IFCSURFACESTYLESHADING = 846575682;
  var IFCSURFACESTYLEWITHTEXTURES = 1351298697;
  var IFCSURFACETEXTURE = 626085974;
  var IFCSWEPTAREASOLID = 2247615214;
  var IFCSWEPTDISKSOLID = 1260650574;
  var IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881;
  var IFCSWEPTSURFACE = 230924584;
  var IFCSWITCHINGDEVICE = 1162798199;
  var IFCSWITCHINGDEVICETYPE = 2315554128;
  var IFCSYSTEM = 2254336722;
  var IFCSYSTEMFURNITUREELEMENT = 413509423;
  var IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250;
  var IFCTSHAPEPROFILEDEF = 3071757647;
  var IFCTABLE = 985171141;
  var IFCTABLECOLUMN = 2043862942;
  var IFCTABLEROW = 531007025;
  var IFCTANK = 812556717;
  var IFCTANKTYPE = 5716631;
  var IFCTASK = 3473067441;
  var IFCTASKTIME = 1549132990;
  var IFCTASKTIMERECURRING = 2771591690;
  var IFCTASKTYPE = 3206491090;
  var IFCTELECOMADDRESS = 912023232;
  var IFCTENDON = 3824725483;
  var IFCTENDONANCHOR = 2347447852;
  var IFCTENDONANCHORTYPE = 3081323446;
  var IFCTENDONCONDUIT = 3663046924;
  var IFCTENDONCONDUITTYPE = 2281632017;
  var IFCTENDONTYPE = 2415094496;
  var IFCTESSELLATEDFACESET = 2387106220;
  var IFCTESSELLATEDITEM = 901063453;
  var IFCTEXTLITERAL = 4282788508;
  var IFCTEXTLITERALWITHEXTENT = 3124975700;
  var IFCTEXTSTYLE = 1447204868;
  var IFCTEXTSTYLEFONTMODEL = 1983826977;
  var IFCTEXTSTYLEFORDEFINEDFONT = 2636378356;
  var IFCTEXTSTYLETEXTMODEL = 1640371178;
  var IFCTEXTURECOORDINATE = 280115917;
  var IFCTEXTURECOORDINATEGENERATOR = 1742049831;
  var IFCTEXTUREMAP = 2552916305;
  var IFCTEXTUREVERTEX = 1210645708;
  var IFCTEXTUREVERTEXLIST = 3611470254;
  var IFCTIMEPERIOD = 1199560280;
  var IFCTIMESERIES = 3101149627;
  var IFCTIMESERIESVALUE = 581633288;
  var IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343;
  var IFCTOPOLOGYREPRESENTATION = 1735638870;
  var IFCTOROIDALSURFACE = 1935646853;
  var IFCTRANSFORMER = 3825984169;
  var IFCTRANSFORMERTYPE = 1692211062;
  var IFCTRANSITIONCURVESEGMENT2D = 2595432518;
  var IFCTRANSPORTELEMENT = 1620046519;
  var IFCTRANSPORTELEMENTTYPE = 2097647324;
  var IFCTRAPEZIUMPROFILEDEF = 2715220739;
  var IFCTRIANGULATEDFACESET = 2916149573;
  var IFCTRIANGULATEDIRREGULARNETWORK = 1229763772;
  var IFCTRIMMEDCURVE = 3593883385;
  var IFCTUBEBUNDLE = 3026737570;
  var IFCTUBEBUNDLETYPE = 1600972822;
  var IFCTYPEOBJECT = 1628702193;
  var IFCTYPEPROCESS = 3736923433;
  var IFCTYPEPRODUCT = 2347495698;
  var IFCTYPERESOURCE = 3698973494;
  var IFCUSHAPEPROFILEDEF = 427810014;
  var IFCUNITASSIGNMENT = 180925521;
  var IFCUNITARYCONTROLELEMENT = 630975310;
  var IFCUNITARYCONTROLELEMENTTYPE = 3179687236;
  var IFCUNITARYEQUIPMENT = 4292641817;
  var IFCUNITARYEQUIPMENTTYPE = 1911125066;
  var IFCVALVE = 4207607924;
  var IFCVALVETYPE = 728799441;
  var IFCVECTOR = 1417489154;
  var IFCVERTEX = 2799835756;
  var IFCVERTEXLOOP = 2759199220;
  var IFCVERTEXPOINT = 1907098498;
  var IFCVIBRATIONDAMPER = 1530820697;
  var IFCVIBRATIONDAMPERTYPE = 3956297820;
  var IFCVIBRATIONISOLATOR = 2391383451;
  var IFCVIBRATIONISOLATORTYPE = 3313531582;
  var IFCVIRTUALELEMENT = 2769231204;
  var IFCVIRTUALGRIDINTERSECTION = 891718957;
  var IFCVOIDINGFEATURE = 926996030;
  var IFCWALL = 2391406946;
  var IFCWALLELEMENTEDCASE = 4156078855;
  var IFCWALLSTANDARDCASE = 3512223829;
  var IFCWALLTYPE = 1898987631;
  var IFCWASTETERMINAL = 4237592921;
  var IFCWASTETERMINALTYPE = 1133259667;
  var IFCWINDOW = 3304561284;
  var IFCWINDOWLININGPROPERTIES = 336235671;
  var IFCWINDOWPANELPROPERTIES = 512836454;
  var IFCWINDOWSTANDARDCASE = 486154966;
  var IFCWINDOWSTYLE = 1299126871;
  var IFCWINDOWTYPE = 4009809668;
  var IFCWORKCALENDAR = 4088093105;
  var IFCWORKCONTROL = 1028945134;
  var IFCWORKPLAN = 4218914973;
  var IFCWORKSCHEDULE = 3342526732;
  var IFCWORKTIME = 1236880293;
  var IFCZSHAPEPROFILEDEF = 2543172580;
  var IFCZONE = 1033361043;
  var IfcElements$1 = [
    IFCACTUATOR,
    IFCAIRTERMINAL,
    IFCAIRTERMINALBOX,
    IFCAIRTOAIRHEATRECOVERY,
    IFCALARM,
    IFCALIGNMENT,
    IFCANNOTATION,
    IFCAUDIOVISUALAPPLIANCE,
    IFCBEAM,
    IFCBEAMSTANDARDCASE,
    IFCBEARING,
    IFCBOILER,
    IFCBRIDGE,
    IFCBRIDGEPART,
    IFCBUILDING,
    IFCBUILDINGELEMENT,
    IFCBUILDINGELEMENTPART,
    IFCBUILDINGELEMENTPROXY,
    IFCBUILDINGSTOREY,
    IFCBURNER,
    IFCCABLECARRIERFITTING,
    IFCCABLECARRIERSEGMENT,
    IFCCABLEFITTING,
    IFCCABLESEGMENT,
    IFCCAISSONFOUNDATION,
    IFCCHILLER,
    IFCCHIMNEY,
    IFCCIVILELEMENT,
    IFCCOIL,
    IFCCOLUMN,
    IFCCOLUMNSTANDARDCASE,
    IFCCOMMUNICATIONSAPPLIANCE,
    IFCCOMPRESSOR,
    IFCCONDENSER,
    IFCCONTROLLER,
    IFCCOOLEDBEAM,
    IFCCOOLINGTOWER,
    IFCCOVERING,
    IFCCURTAINWALL,
    IFCDAMPER,
    IFCDEEPFOUNDATION,
    IFCDISCRETEACCESSORY,
    IFCDISTRIBUTIONCHAMBERELEMENT,
    IFCDISTRIBUTIONCONTROLELEMENT,
    IFCDISTRIBUTIONELEMENT,
    IFCDISTRIBUTIONFLOWELEMENT,
    IFCDISTRIBUTIONPORT,
    IFCDOOR,
    IFCDOORSTANDARDCASE,
    IFCDUCTFITTING,
    IFCDUCTSEGMENT,
    IFCDUCTSILENCER,
    IFCELECTRICAPPLIANCE,
    IFCELECTRICDISTRIBUTIONBOARD,
    IFCELECTRICFLOWSTORAGEDEVICE,
    IFCELECTRICGENERATOR,
    IFCELECTRICMOTOR,
    IFCELECTRICTIMECONTROL,
    IFCELEMENT,
    IFCELEMENTASSEMBLY,
    IFCELEMENTCOMPONENT,
    IFCENERGYCONVERSIONDEVICE,
    IFCENGINE,
    IFCEVAPORATIVECOOLER,
    IFCEVAPORATOR,
    IFCEXTERNALSPATIALELEMENT,
    IFCEXTERNALSPATIALSTRUCTUREELEMENT,
    IFCFACILITY,
    IFCFACILITYPART,
    IFCFAN,
    IFCFASTENER,
    IFCFEATUREELEMENT,
    IFCFEATUREELEMENTADDITION,
    IFCFEATUREELEMENTSUBTRACTION,
    IFCFILTER,
    IFCFIRESUPPRESSIONTERMINAL,
    IFCFLOWCONTROLLER,
    IFCFLOWFITTING,
    IFCFLOWINSTRUMENT,
    IFCFLOWMETER,
    IFCFLOWMOVINGDEVICE,
    IFCFLOWSEGMENT,
    IFCFLOWSTORAGEDEVICE,
    IFCFLOWTERMINAL,
    IFCFLOWTREATMENTDEVICE,
    IFCFOOTING,
    IFCFURNISHINGELEMENT,
    IFCFURNITURE,
    IFCGEOGRAPHICELEMENT,
    IFCGRID,
    IFCHEATEXCHANGER,
    IFCHUMIDIFIER,
    IFCINTERCEPTOR,
    IFCJUNCTIONBOX,
    IFCLAMP,
    IFCLIGHTFIXTURE,
    IFCLINEARPOSITIONINGELEMENT,
    IFCMECHANICALFASTENER,
    IFCMEDICALDEVICE,
    IFCMEMBER,
    IFCMEMBERSTANDARDCASE,
    IFCMOTORCONNECTION,
    IFCOPENINGELEMENT,
    IFCOPENINGSTANDARDCASE,
    IFCOUTLET,
    IFCPILE,
    IFCPIPEFITTING,
    IFCPIPESEGMENT,
    IFCPLATE,
    IFCPLATESTANDARDCASE,
    IFCPORT,
    IFCPOSITIONINGELEMENT,
    IFCPROJECTIONELEMENT,
    IFCPROTECTIVEDEVICE,
    IFCPROTECTIVEDEVICETRIPPINGUNIT,
    IFCPROXY,
    IFCPUMP,
    IFCRAILING,
    IFCRAMP,
    IFCRAMPFLIGHT,
    IFCREFERENT,
    IFCREINFORCINGBAR,
    IFCREINFORCINGELEMENT,
    IFCREINFORCINGMESH,
    IFCROOF,
    IFCSANITARYTERMINAL,
    IFCSENSOR,
    IFCSHADINGDEVICE,
    IFCSITE,
    IFCSLAB,
    IFCSLABELEMENTEDCASE,
    IFCSLABSTANDARDCASE,
    IFCSOLARDEVICE,
    IFCSPACE,
    IFCSPACEHEATER,
    IFCSPATIALELEMENT,
    IFCSPATIALSTRUCTUREELEMENT,
    IFCSPATIALZONE,
    IFCSTACKTERMINAL,
    IFCSTAIR,
    IFCSTAIRFLIGHT,
    IFCSTRUCTURALACTION,
    IFCSTRUCTURALACTIVITY,
    IFCSTRUCTURALCONNECTION,
    IFCSTRUCTURALCURVEACTION,
    IFCSTRUCTURALCURVECONNECTION,
    IFCSTRUCTURALCURVEMEMBER,
    IFCSTRUCTURALCURVEMEMBERVARYING,
    IFCSTRUCTURALCURVEREACTION,
    IFCSTRUCTURALITEM,
    IFCSTRUCTURALLINEARACTION,
    IFCSTRUCTURALMEMBER,
    IFCSTRUCTURALPLANARACTION,
    IFCSTRUCTURALPOINTACTION,
    IFCSTRUCTURALPOINTCONNECTION,
    IFCSTRUCTURALPOINTREACTION,
    IFCSTRUCTURALREACTION,
    IFCSTRUCTURALSURFACEACTION,
    IFCSTRUCTURALSURFACECONNECTION,
    IFCSTRUCTURALSURFACEMEMBER,
    IFCSTRUCTURALSURFACEMEMBERVARYING,
    IFCSTRUCTURALSURFACEREACTION,
    IFCSURFACEFEATURE,
    IFCSWITCHINGDEVICE,
    IFCSYSTEMFURNITUREELEMENT,
    IFCTANK,
    IFCTENDON,
    IFCTENDONANCHOR,
    IFCTENDONCONDUIT,
    IFCTRANSFORMER,
    IFCTRANSPORTELEMENT,
    IFCTUBEBUNDLE,
    IFCUNITARYCONTROLELEMENT,
    IFCUNITARYEQUIPMENT,
    IFCVALVE,
    IFCVIBRATIONDAMPER,
    IFCVIBRATIONISOLATOR,
    IFCVIRTUALELEMENT,
    IFCVOIDINGFEATURE,
    IFCWALL,
    IFCWALLELEMENTEDCASE,
    IFCWALLSTANDARDCASE,
    IFCWASTETERMINAL,
    IFCWINDOW,
    IFCWINDOWSTANDARDCASE
  ];

  // dist/ifc2x4_helper.ts
  var FromRawLineData = {};
  FromRawLineData[IFCACTIONREQUEST] = (d) => {
    return IfcActionRequest.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTOR] = (d) => {
    return IfcActor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTORROLE] = (d) => {
    return IfcActorRole.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTUATOR] = (d) => {
    return IfcActuator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTUATORTYPE] = (d) => {
    return IfcActuatorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADDRESS] = (d) => {
    return IfcAddress.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADVANCEDBREP] = (d) => {
    return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = (d) => {
    return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADVANCEDFACE] = (d) => {
    return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINAL] = (d) => {
    return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINALBOX] = (d) => {
    return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINALBOXTYPE] = (d) => {
    return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINALTYPE] = (d) => {
    return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = (d) => {
    return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = (d) => {
    return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALARM] = (d) => {
    return IfcAlarm.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALARMTYPE] = (d) => {
    return IfcAlarmType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT] = (d) => {
    return IfcAlignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = (d) => {
    return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = (d) => {
    return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DSEGMENT] = (d) => {
    return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = (d) => {
    return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = (d) => {
    return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = (d) => {
    return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERTICAL] = (d) => {
    return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = (d) => {
    return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENTCURVE] = (d) => {
    return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCANNOTATION] = (d) => {
    return IfcAnnotation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCANNOTATIONFILLAREA] = (d) => {
    return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPLICATION] = (d) => {
    return IfcApplication.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPLIEDVALUE] = (d) => {
    return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPROVAL] = (d) => {
    return IfcApproval.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPROVALRELATIONSHIP] = (d) => {
    return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = (d) => {
    return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = (d) => {
    return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = (d) => {
    return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCASSET] = (d) => {
    return IfcAsset.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = (d) => {
    return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = (d) => {
    return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = (d) => {
    return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAXIS1PLACEMENT] = (d) => {
    return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAXIS2PLACEMENT2D] = (d) => {
    return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAXIS2PLACEMENT3D] = (d) => {
    return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINECURVE] = (d) => {
    return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = (d) => {
    return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINESURFACE] = (d) => {
    return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = (d) => {
    return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEAM] = (d) => {
    return IfcBeam.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEAMSTANDARDCASE] = (d) => {
    return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEAMTYPE] = (d) => {
    return IfcBeamType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEARING] = (d) => {
    return IfcBearing.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEARINGTYPE] = (d) => {
    return IfcBearingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBLOBTEXTURE] = (d) => {
    return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBLOCK] = (d) => {
    return IfcBlock.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOILER] = (d) => {
    return IfcBoiler.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOILERTYPE] = (d) => {
    return IfcBoilerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = (d) => {
    return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOOLEANRESULT] = (d) => {
    return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYCONDITION] = (d) => {
    return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYCURVE] = (d) => {
    return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYEDGECONDITION] = (d) => {
    return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYFACECONDITION] = (d) => {
    return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYNODECONDITION] = (d) => {
    return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = (d) => {
    return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDEDCURVE] = (d) => {
    return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDEDSURFACE] = (d) => {
    return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDINGBOX] = (d) => {
    return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOXEDHALFSPACE] = (d) => {
    return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBRIDGE] = (d) => {
    return IfcBridge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBRIDGEPART] = (d) => {
    return IfcBridgePart.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDING] = (d) => {
    return IfcBuilding.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENT] = (d) => {
    return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPART] = (d) => {
    return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = (d) => {
    return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPROXY] = (d) => {
    return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = (d) => {
    return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTTYPE] = (d) => {
    return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGSTOREY] = (d) => {
    return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGSYSTEM] = (d) => {
    return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBURNER] = (d) => {
    return IfcBurner.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBURNERTYPE] = (d) => {
    return IfcBurnerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCSHAPEPROFILEDEF] = (d) => {
    return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERFITTING] = (d) => {
    return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = (d) => {
    return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERSEGMENT] = (d) => {
    return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = (d) => {
    return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLEFITTING] = (d) => {
    return IfcCableFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLEFITTINGTYPE] = (d) => {
    return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLESEGMENT] = (d) => {
    return IfcCableSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLESEGMENTTYPE] = (d) => {
    return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCAISSONFOUNDATION] = (d) => {
    return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = (d) => {
    return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINT] = (d) => {
    return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINTLIST] = (d) => {
    return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINTLIST2D] = (d) => {
    return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINTLIST3D] = (d) => {
    return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = (d) => {
    return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = (d) => {
    return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = (d) => {
    return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = (d) => {
    return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = (d) => {
    return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCENTERLINEPROFILEDEF] = (d) => {
    return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHILLER] = (d) => {
    return IfcChiller.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHILLERTYPE] = (d) => {
    return IfcChillerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHIMNEY] = (d) => {
    return IfcChimney.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHIMNEYTYPE] = (d) => {
    return IfcChimneyType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCLE] = (d) => {
    return IfcCircle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = (d) => {
    return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCLEPROFILEDEF] = (d) => {
    return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCULARARCSEGMENT2D] = (d) => {
    return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIVILELEMENT] = (d) => {
    return IfcCivilElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIVILELEMENTTYPE] = (d) => {
    return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCLASSIFICATION] = (d) => {
    return IfcClassification.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCLASSIFICATIONREFERENCE] = (d) => {
    return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCLOSEDSHELL] = (d) => {
    return IfcClosedShell.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOIL] = (d) => {
    return IfcCoil.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOILTYPE] = (d) => {
    return IfcCoilType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLOURRGB] = (d) => {
    return IfcColourRgb.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLOURRGBLIST] = (d) => {
    return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLOURSPECIFICATION] = (d) => {
    return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLUMN] = (d) => {
    return IfcColumn.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLUMNSTANDARDCASE] = (d) => {
    return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLUMNTYPE] = (d) => {
    return IfcColumnType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = (d) => {
    return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = (d) => {
    return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPLEXPROPERTY] = (d) => {
    return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = (d) => {
    return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITECURVE] = (d) => {
    return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = (d) => {
    return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITECURVESEGMENT] = (d) => {
    return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITEPROFILEDEF] = (d) => {
    return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPRESSOR] = (d) => {
    return IfcCompressor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPRESSORTYPE] = (d) => {
    return IfcCompressorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONDENSER] = (d) => {
    return IfcCondenser.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONDENSERTYPE] = (d) => {
    return IfcCondenserType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONIC] = (d) => {
    return IfcConic.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTEDFACESET] = (d) => {
    return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = (d) => {
    return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONGEOMETRY] = (d) => {
    return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = (d) => {
    return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = (d) => {
    return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = (d) => {
    return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = (d) => {
    return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRAINT] = (d) => {
    return IfcConstraint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = (d) => {
    return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = (d) => {
    return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = (d) => {
    return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = (d) => {
    return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = (d) => {
    return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = (d) => {
    return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONRESOURCE] = (d) => {
    return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = (d) => {
    return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTEXT] = (d) => {
    return IfcContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = (d) => {
    return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTROL] = (d) => {
    return IfcControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTROLLER] = (d) => {
    return IfcController.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTROLLERTYPE] = (d) => {
    return IfcControllerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONVERSIONBASEDUNIT] = (d) => {
    return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = (d) => {
    return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLEDBEAM] = (d) => {
    return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLEDBEAMTYPE] = (d) => {
    return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLINGTOWER] = (d) => {
    return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLINGTOWERTYPE] = (d) => {
    return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOORDINATEOPERATION] = (d) => {
    return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = (d) => {
    return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOSTITEM] = (d) => {
    return IfcCostItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOSTSCHEDULE] = (d) => {
    return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOSTVALUE] = (d) => {
    return IfcCostValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOVERING] = (d) => {
    return IfcCovering.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOVERINGTYPE] = (d) => {
    return IfcCoveringType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCREWRESOURCE] = (d) => {
    return IfcCrewResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCREWRESOURCETYPE] = (d) => {
    return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCSGPRIMITIVE3D] = (d) => {
    return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCSGSOLID] = (d) => {
    return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURRENCYRELATIONSHIP] = (d) => {
    return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURTAINWALL] = (d) => {
    return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURTAINWALLTYPE] = (d) => {
    return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVE] = (d) => {
    return IfcCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVEBOUNDEDPLANE] = (d) => {
    return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVEBOUNDEDSURFACE] = (d) => {
    return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESEGMENT2D] = (d) => {
    return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLE] = (d) => {
    return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLEFONT] = (d) => {
    return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = (d) => {
    return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLEFONTPATTERN] = (d) => {
    return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCYLINDRICALSURFACE] = (d) => {
    return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDAMPER] = (d) => {
    return IfcDamper.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDAMPERTYPE] = (d) => {
    return IfcDamperType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDEEPFOUNDATION] = (d) => {
    return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDEEPFOUNDATIONTYPE] = (d) => {
    return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDERIVEDPROFILEDEF] = (d) => {
    return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDERIVEDUNIT] = (d) => {
    return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDERIVEDUNITELEMENT] = (d) => {
    return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDIMENSIONALEXPONENTS] = (d) => {
    return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDIRECTION] = (d) => {
    return IfcDirection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISCRETEACCESSORY] = (d) => {
    return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISCRETEACCESSORYTYPE] = (d) => {
    return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTANCEEXPRESSION] = (d) => {
    return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = (d) => {
    return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = (d) => {
    return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = (d) => {
    return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = (d) => {
    return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = (d) => {
    return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONELEMENT] = (d) => {
    return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = (d) => {
    return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = (d) => {
    return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = (d) => {
    return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONPORT] = (d) => {
    return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONSYSTEM] = (d) => {
    return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOCUMENTINFORMATION] = (d) => {
    return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = (d) => {
    return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOCUMENTREFERENCE] = (d) => {
    return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOOR] = (d) => {
    return IfcDoor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORLININGPROPERTIES] = (d) => {
    return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORPANELPROPERTIES] = (d) => {
    return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORSTANDARDCASE] = (d) => {
    return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORSTYLE] = (d) => {
    return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORTYPE] = (d) => {
    return IfcDoorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = (d) => {
    return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = (d) => {
    return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTFITTING] = (d) => {
    return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTFITTINGTYPE] = (d) => {
    return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSEGMENT] = (d) => {
    return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSEGMENTTYPE] = (d) => {
    return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSILENCER] = (d) => {
    return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSILENCERTYPE] = (d) => {
    return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEDGE] = (d) => {
    return IfcEdge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEDGECURVE] = (d) => {
    return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEDGELOOP] = (d) => {
    return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICAPPLIANCE] = (d) => {
    return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICAPPLIANCETYPE] = (d) => {
    return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = (d) => {
    return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = (d) => {
    return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = (d) => {
    return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = (d) => {
    return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICGENERATOR] = (d) => {
    return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICGENERATORTYPE] = (d) => {
    return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICMOTOR] = (d) => {
    return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICMOTORTYPE] = (d) => {
    return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICTIMECONTROL] = (d) => {
    return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = (d) => {
    return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENT] = (d) => {
    return IfcElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTASSEMBLY] = (d) => {
    return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTASSEMBLYTYPE] = (d) => {
    return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTCOMPONENT] = (d) => {
    return IfcElementComponent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTCOMPONENTTYPE] = (d) => {
    return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTQUANTITY] = (d) => {
    return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTTYPE] = (d) => {
    return IfcElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTARYSURFACE] = (d) => {
    return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELLIPSE] = (d) => {
    return IfcEllipse.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELLIPSEPROFILEDEF] = (d) => {
    return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENERGYCONVERSIONDEVICE] = (d) => {
    return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = (d) => {
    return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENGINE] = (d) => {
    return IfcEngine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENGINETYPE] = (d) => {
    return IfcEngineType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATIVECOOLER] = (d) => {
    return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = (d) => {
    return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATOR] = (d) => {
    return IfcEvaporator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATORTYPE] = (d) => {
    return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVENT] = (d) => {
    return IfcEvent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVENTTIME] = (d) => {
    return IfcEventTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVENTTYPE] = (d) => {
    return IfcEventType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTENDEDPROPERTIES] = (d) => {
    return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALINFORMATION] = (d) => {
    return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALREFERENCE] = (d) => {
    return IfcExternalReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = (d) => {
    return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALSPATIALELEMENT] = (d) => {
    return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = (d) => {
    return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = (d) => {
    return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = (d) => {
    return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = (d) => {
    return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTRUDEDAREASOLID] = (d) => {
    return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = (d) => {
    return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACE] = (d) => {
    return IfcFace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACEBASEDSURFACEMODEL] = (d) => {
    return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACEBOUND] = (d) => {
    return IfcFaceBound.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACEOUTERBOUND] = (d) => {
    return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACESURFACE] = (d) => {
    return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACETEDBREP] = (d) => {
    return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACETEDBREPWITHVOIDS] = (d) => {
    return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACILITY] = (d) => {
    return IfcFacility.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACILITYPART] = (d) => {
    return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFAILURECONNECTIONCONDITION] = (d) => {
    return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFAN] = (d) => {
    return IfcFan.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFANTYPE] = (d) => {
    return IfcFanType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFASTENER] = (d) => {
    return IfcFastener.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFASTENERTYPE] = (d) => {
    return IfcFastenerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFEATUREELEMENT] = (d) => {
    return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFEATUREELEMENTADDITION] = (d) => {
    return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = (d) => {
    return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILLAREASTYLE] = (d) => {
    return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILLAREASTYLEHATCHING] = (d) => {
    return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILLAREASTYLETILES] = (d) => {
    return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILTER] = (d) => {
    return IfcFilter.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILTERTYPE] = (d) => {
    return IfcFilterType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = (d) => {
    return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = (d) => {
    return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = (d) => {
    return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWCONTROLLER] = (d) => {
    return IfcFlowController.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWCONTROLLERTYPE] = (d) => {
    return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWFITTING] = (d) => {
    return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWFITTINGTYPE] = (d) => {
    return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWINSTRUMENT] = (d) => {
    return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWINSTRUMENTTYPE] = (d) => {
    return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMETER] = (d) => {
    return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMETERTYPE] = (d) => {
    return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMOVINGDEVICE] = (d) => {
    return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = (d) => {
    return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSEGMENT] = (d) => {
    return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSEGMENTTYPE] = (d) => {
    return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSTORAGEDEVICE] = (d) => {
    return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = (d) => {
    return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTERMINAL] = (d) => {
    return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTERMINALTYPE] = (d) => {
    return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTREATMENTDEVICE] = (d) => {
    return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = (d) => {
    return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFOOTING] = (d) => {
    return IfcFooting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFOOTINGTYPE] = (d) => {
    return IfcFootingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNISHINGELEMENT] = (d) => {
    return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNISHINGELEMENTTYPE] = (d) => {
    return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNITURE] = (d) => {
    return IfcFurniture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNITURETYPE] = (d) => {
    return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOGRAPHICELEMENT] = (d) => {
    return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = (d) => {
    return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICCURVESET] = (d) => {
    return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = (d) => {
    return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = (d) => {
    return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = (d) => {
    return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICSET] = (d) => {
    return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGRID] = (d) => {
    return IfcGrid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGRIDAXIS] = (d) => {
    return IfcGridAxis.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGRIDPLACEMENT] = (d) => {
    return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGROUP] = (d) => {
    return IfcGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHALFSPACESOLID] = (d) => {
    return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHEATEXCHANGER] = (d) => {
    return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHEATEXCHANGERTYPE] = (d) => {
    return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHUMIDIFIER] = (d) => {
    return IfcHumidifier.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHUMIDIFIERTYPE] = (d) => {
    return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCISHAPEPROFILEDEF] = (d) => {
    return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCIMAGETEXTURE] = (d) => {
    return IfcImageTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDCOLOURMAP] = (d) => {
    return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDPOLYCURVE] = (d) => {
    return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDPOLYGONALFACE] = (d) => {
    return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = (d) => {
    return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDTEXTUREMAP] = (d) => {
    return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = (d) => {
    return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINTERCEPTOR] = (d) => {
    return IfcInterceptor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINTERCEPTORTYPE] = (d) => {
    return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINTERSECTIONCURVE] = (d) => {
    return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINVENTORY] = (d) => {
    return IfcInventory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCIRREGULARTIMESERIES] = (d) => {
    return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = (d) => {
    return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCJUNCTIONBOX] = (d) => {
    return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCJUNCTIONBOXTYPE] = (d) => {
    return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLSHAPEPROFILEDEF] = (d) => {
    return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLABORRESOURCE] = (d) => {
    return IfcLaborResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLABORRESOURCETYPE] = (d) => {
    return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLAGTIME] = (d) => {
    return IfcLagTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLAMP] = (d) => {
    return IfcLamp.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLAMPTYPE] = (d) => {
    return IfcLampType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIBRARYINFORMATION] = (d) => {
    return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIBRARYREFERENCE] = (d) => {
    return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = (d) => {
    return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTFIXTURE] = (d) => {
    return IfcLightFixture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTFIXTURETYPE] = (d) => {
    return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = (d) => {
    return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCE] = (d) => {
    return IfcLightSource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEAMBIENT] = (d) => {
    return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = (d) => {
    return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = (d) => {
    return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = (d) => {
    return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCESPOT] = (d) => {
    return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINE] = (d) => {
    return IfcLine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINESEGMENT2D] = (d) => {
    return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINEARPLACEMENT] = (d) => {
    return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = (d) => {
    return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLOCALPLACEMENT] = (d) => {
    return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLOOP] = (d) => {
    return IfcLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMANIFOLDSOLIDBREP] = (d) => {
    return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMAPCONVERSION] = (d) => {
    return IfcMapConversion.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMAPPEDITEM] = (d) => {
    return IfcMappedItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIAL] = (d) => {
    return IfcMaterial.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = (d) => {
    return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALCONSTITUENT] = (d) => {
    return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALCONSTITUENTSET] = (d) => {
    return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALDEFINITION] = (d) => {
    return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = (d) => {
    return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYER] = (d) => {
    return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYERSET] = (d) => {
    return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYERSETUSAGE] = (d) => {
    return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = (d) => {
    return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLIST] = (d) => {
    return IfcMaterialList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILE] = (d) => {
    return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILESET] = (d) => {
    return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILESETUSAGE] = (d) => {
    return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = (d) => {
    return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = (d) => {
    return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROPERTIES] = (d) => {
    return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALRELATIONSHIP] = (d) => {
    return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALUSAGEDEFINITION] = (d) => {
    return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEASUREWITHUNIT] = (d) => {
    return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMECHANICALFASTENER] = (d) => {
    return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMECHANICALFASTENERTYPE] = (d) => {
    return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEDICALDEVICE] = (d) => {
    return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEDICALDEVICETYPE] = (d) => {
    return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEMBER] = (d) => {
    return IfcMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEMBERSTANDARDCASE] = (d) => {
    return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEMBERTYPE] = (d) => {
    return IfcMemberType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMETRIC] = (d) => {
    return IfcMetric.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMIRROREDPROFILEDEF] = (d) => {
    return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMONETARYUNIT] = (d) => {
    return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMOTORCONNECTION] = (d) => {
    return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMOTORCONNECTIONTYPE] = (d) => {
    return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCNAMEDUNIT] = (d) => {
    return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECT] = (d) => {
    return IfcObject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECTDEFINITION] = (d) => {
    return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECTPLACEMENT] = (d) => {
    return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECTIVE] = (d) => {
    return IfcObjective.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOCCUPANT] = (d) => {
    return IfcOccupant.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVE] = (d) => {
    return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVE2D] = (d) => {
    return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVE3D] = (d) => {
    return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = (d) => {
    return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOPENSHELL] = (d) => {
    return IfcOpenShell.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOPENINGELEMENT] = (d) => {
    return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOPENINGSTANDARDCASE] = (d) => {
    return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORGANIZATION] = (d) => {
    return IfcOrganization.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = (d) => {
    return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORIENTATIONEXPRESSION] = (d) => {
    return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORIENTEDEDGE] = (d) => {
    return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOUTERBOUNDARYCURVE] = (d) => {
    return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOUTLET] = (d) => {
    return IfcOutlet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOUTLETTYPE] = (d) => {
    return IfcOutletType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOWNERHISTORY] = (d) => {
    return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = (d) => {
    return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPATH] = (d) => {
    return IfcPath.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPCURVE] = (d) => {
    return IfcPcurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERFORMANCEHISTORY] = (d) => {
    return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = (d) => {
    return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERMIT] = (d) => {
    return IfcPermit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERSON] = (d) => {
    return IfcPerson.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERSONANDORGANIZATION] = (d) => {
    return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = (d) => {
    return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPHYSICALQUANTITY] = (d) => {
    return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = (d) => {
    return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPILE] = (d) => {
    return IfcPile.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPILETYPE] = (d) => {
    return IfcPileType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPEFITTING] = (d) => {
    return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPEFITTINGTYPE] = (d) => {
    return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPESEGMENT] = (d) => {
    return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPESEGMENTTYPE] = (d) => {
    return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIXELTEXTURE] = (d) => {
    return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLACEMENT] = (d) => {
    return IfcPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLANARBOX] = (d) => {
    return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLANAREXTENT] = (d) => {
    return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLANE] = (d) => {
    return IfcPlane.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLATE] = (d) => {
    return IfcPlate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLATESTANDARDCASE] = (d) => {
    return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLATETYPE] = (d) => {
    return IfcPlateType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOINT] = (d) => {
    return IfcPoint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOINTONCURVE] = (d) => {
    return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOINTONSURFACE] = (d) => {
    return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYLOOP] = (d) => {
    return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = (d) => {
    return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYGONALFACESET] = (d) => {
    return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYLINE] = (d) => {
    return IfcPolyline.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPORT] = (d) => {
    return IfcPort.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOSITIONINGELEMENT] = (d) => {
    return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOSTALADDRESS] = (d) => {
    return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDCOLOUR] = (d) => {
    return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDCURVEFONT] = (d) => {
    return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDITEM] = (d) => {
    return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDPROPERTIES] = (d) => {
    return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDPROPERTYSET] = (d) => {
    return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDTEXTFONT] = (d) => {
    return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONITEM] = (d) => {
    return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = (d) => {
    return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = (d) => {
    return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONSTYLE] = (d) => {
    return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = (d) => {
    return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROCEDURE] = (d) => {
    return IfcProcedure.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROCEDURETYPE] = (d) => {
    return IfcProcedureType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROCESS] = (d) => {
    return IfcProcess.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRODUCT] = (d) => {
    return IfcProduct.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = (d) => {
    return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRODUCTREPRESENTATION] = (d) => {
    return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROFILEDEF] = (d) => {
    return IfcProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROFILEPROPERTIES] = (d) => {
    return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECT] = (d) => {
    return IfcProject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTLIBRARY] = (d) => {
    return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTORDER] = (d) => {
    return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTEDCRS] = (d) => {
    return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTIONELEMENT] = (d) => {
    return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTY] = (d) => {
    return IfcProperty.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYABSTRACTION] = (d) => {
    return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = (d) => {
    return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYDEFINITION] = (d) => {
    return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = (d) => {
    return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = (d) => {
    return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYENUMERATION] = (d) => {
    return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYLISTVALUE] = (d) => {
    return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYREFERENCEVALUE] = (d) => {
    return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSET] = (d) => {
    return IfcPropertySet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSETDEFINITION] = (d) => {
    return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSETTEMPLATE] = (d) => {
    return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSINGLEVALUE] = (d) => {
    return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYTABLEVALUE] = (d) => {
    return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYTEMPLATE] = (d) => {
    return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = (d) => {
    return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICE] = (d) => {
    return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = (d) => {
    return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = (d) => {
    return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICETYPE] = (d) => {
    return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROXY] = (d) => {
    return IfcProxy.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPUMP] = (d) => {
    return IfcPump.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPUMPTYPE] = (d) => {
    return IfcPumpType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYAREA] = (d) => {
    return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYCOUNT] = (d) => {
    return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYLENGTH] = (d) => {
    return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYSET] = (d) => {
    return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYTIME] = (d) => {
    return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYVOLUME] = (d) => {
    return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYWEIGHT] = (d) => {
    return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAILING] = (d) => {
    return IfcRailing.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAILINGTYPE] = (d) => {
    return IfcRailingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMP] = (d) => {
    return IfcRamp.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMPFLIGHT] = (d) => {
    return IfcRampFlight.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMPFLIGHTTYPE] = (d) => {
    return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMPTYPE] = (d) => {
    return IfcRampType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = (d) => {
    return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = (d) => {
    return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = (d) => {
    return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGLEPROFILEDEF] = (d) => {
    return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGULARPYRAMID] = (d) => {
    return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = (d) => {
    return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECURRENCEPATTERN] = (d) => {
    return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREFERENCE] = (d) => {
    return IfcReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREFERENT] = (d) => {
    return IfcReferent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREGULARTIMESERIES] = (d) => {
    return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = (d) => {
    return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = (d) => {
    return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGBAR] = (d) => {
    return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGBARTYPE] = (d) => {
    return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGELEMENT] = (d) => {
    return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGELEMENTTYPE] = (d) => {
    return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGMESH] = (d) => {
    return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGMESHTYPE] = (d) => {
    return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELAGGREGATES] = (d) => {
    return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNS] = (d) => {
    return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOACTOR] = (d) => {
    return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOCONTROL] = (d) => {
    return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOGROUP] = (d) => {
    return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = (d) => {
    return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOPROCESS] = (d) => {
    return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOPRODUCT] = (d) => {
    return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTORESOURCE] = (d) => {
    return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATES] = (d) => {
    return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESAPPROVAL] = (d) => {
    return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = (d) => {
    return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = (d) => {
    return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESDOCUMENT] = (d) => {
    return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESLIBRARY] = (d) => {
    return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESMATERIAL] = (d) => {
    return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTS] = (d) => {
    return IfcRelConnects.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSELEMENTS] = (d) => {
    return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = (d) => {
    return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = (d) => {
    return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSPORTS] = (d) => {
    return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = (d) => {
    return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = (d) => {
    return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = (d) => {
    return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = (d) => {
    return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = (d) => {
    return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = (d) => {
    return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCOVERSSPACES] = (d) => {
    return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDECLARES] = (d) => {
    return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDECOMPOSES] = (d) => {
    return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINES] = (d) => {
    return IfcRelDefines.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYOBJECT] = (d) => {
    return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYPROPERTIES] = (d) => {
    return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYTEMPLATE] = (d) => {
    return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYTYPE] = (d) => {
    return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELFILLSELEMENT] = (d) => {
    return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = (d) => {
    return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELINTERFERESELEMENTS] = (d) => {
    return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELNESTS] = (d) => {
    return IfcRelNests.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELPOSITIONS] = (d) => {
    return IfcRelPositions.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELPROJECTSELEMENT] = (d) => {
    return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = (d) => {
    return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSEQUENCE] = (d) => {
    return IfcRelSequence.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSERVICESBUILDINGS] = (d) => {
    return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSPACEBOUNDARY] = (d) => {
    return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = (d) => {
    return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = (d) => {
    return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELVOIDSELEMENT] = (d) => {
    return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELATIONSHIP] = (d) => {
    return IfcRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = (d) => {
    return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATION] = (d) => {
    return IfcRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATIONCONTEXT] = (d) => {
    return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATIONITEM] = (d) => {
    return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATIONMAP] = (d) => {
    return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCE] = (d) => {
    return IfcResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = (d) => {
    return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = (d) => {
    return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = (d) => {
    return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCETIME] = (d) => {
    return IfcResourceTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREVOLVEDAREASOLID] = (d) => {
    return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = (d) => {
    return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRIGHTCIRCULARCONE] = (d) => {
    return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = (d) => {
    return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROOF] = (d) => {
    return IfcRoof.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROOFTYPE] = (d) => {
    return IfcRoofType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROOT] = (d) => {
    return IfcRoot.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = (d) => {
    return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSIUNIT] = (d) => {
    return IfcSIUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSANITARYTERMINAL] = (d) => {
    return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSANITARYTERMINALTYPE] = (d) => {
    return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSCHEDULINGTIME] = (d) => {
    return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSEAMCURVE] = (d) => {
    return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONPROPERTIES] = (d) => {
    return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = (d) => {
    return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONEDSOLID] = (d) => {
    return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = (d) => {
    return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONEDSPINE] = (d) => {
    return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSENSOR] = (d) => {
    return IfcSensor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSENSORTYPE] = (d) => {
    return IfcSensorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHADINGDEVICE] = (d) => {
    return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHADINGDEVICETYPE] = (d) => {
    return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHAPEASPECT] = (d) => {
    return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHAPEMODEL] = (d) => {
    return IfcShapeModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHAPEREPRESENTATION] = (d) => {
    return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = (d) => {
    return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSIMPLEPROPERTY] = (d) => {
    return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = (d) => {
    return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSITE] = (d) => {
    return IfcSite.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLAB] = (d) => {
    return IfcSlab.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLABELEMENTEDCASE] = (d) => {
    return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLABSTANDARDCASE] = (d) => {
    return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLABTYPE] = (d) => {
    return IfcSlabType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = (d) => {
    return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSOLARDEVICE] = (d) => {
    return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSOLARDEVICETYPE] = (d) => {
    return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSOLIDMODEL] = (d) => {
    return IfcSolidModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACE] = (d) => {
    return IfcSpace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACEHEATER] = (d) => {
    return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACEHEATERTYPE] = (d) => {
    return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACETYPE] = (d) => {
    return IfcSpaceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALELEMENT] = (d) => {
    return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALELEMENTTYPE] = (d) => {
    return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = (d) => {
    return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = (d) => {
    return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALZONE] = (d) => {
    return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALZONETYPE] = (d) => {
    return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPHERE] = (d) => {
    return IfcSphere.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPHERICALSURFACE] = (d) => {
    return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTACKTERMINAL] = (d) => {
    return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTACKTERMINALTYPE] = (d) => {
    return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIR] = (d) => {
    return IfcStair.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIRFLIGHT] = (d) => {
    return IfcStairFlight.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIRFLIGHTTYPE] = (d) => {
    return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIRTYPE] = (d) => {
    return IfcStairType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALACTION] = (d) => {
    return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALACTIVITY] = (d) => {
    return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = (d) => {
    return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCONNECTION] = (d) => {
    return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = (d) => {
    return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEACTION] = (d) => {
    return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = (d) => {
    return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = (d) => {
    return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = (d) => {
    return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEREACTION] = (d) => {
    return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALITEM] = (d) => {
    return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLINEARACTION] = (d) => {
    return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOAD] = (d) => {
    return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADCASE] = (d) => {
    return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = (d) => {
    return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADGROUP] = (d) => {
    return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = (d) => {
    return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADORRESULT] = (d) => {
    return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = (d) => {
    return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = (d) => {
    return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = (d) => {
    return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = (d) => {
    return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = (d) => {
    return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSTATIC] = (d) => {
    return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = (d) => {
    return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALMEMBER] = (d) => {
    return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPLANARACTION] = (d) => {
    return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPOINTACTION] = (d) => {
    return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = (d) => {
    return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPOINTREACTION] = (d) => {
    return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALREACTION] = (d) => {
    return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALRESULTGROUP] = (d) => {
    return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEACTION] = (d) => {
    return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = (d) => {
    return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = (d) => {
    return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = (d) => {
    return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = (d) => {
    return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTYLEMODEL] = (d) => {
    return IfcStyleModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTYLEDITEM] = (d) => {
    return IfcStyledItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTYLEDREPRESENTATION] = (d) => {
    return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSUBCONTRACTRESOURCE] = (d) => {
    return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = (d) => {
    return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSUBEDGE] = (d) => {
    return IfcSubedge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACE] = (d) => {
    return IfcSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACECURVE] = (d) => {
    return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = (d) => {
    return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEFEATURE] = (d) => {
    return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = (d) => {
    return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEOFREVOLUTION] = (d) => {
    return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = (d) => {
    return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLE] = (d) => {
    return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLELIGHTING] = (d) => {
    return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLEREFRACTION] = (d) => {
    return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLERENDERING] = (d) => {
    return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLESHADING] = (d) => {
    return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = (d) => {
    return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACETEXTURE] = (d) => {
    return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTAREASOLID] = (d) => {
    return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTDISKSOLID] = (d) => {
    return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = (d) => {
    return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTSURFACE] = (d) => {
    return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWITCHINGDEVICE] = (d) => {
    return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWITCHINGDEVICETYPE] = (d) => {
    return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSYSTEM] = (d) => {
    return IfcSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = (d) => {
    return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = (d) => {
    return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTSHAPEPROFILEDEF] = (d) => {
    return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTABLE] = (d) => {
    return IfcTable.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTABLECOLUMN] = (d) => {
    return IfcTableColumn.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTABLEROW] = (d) => {
    return IfcTableRow.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTANK] = (d) => {
    return IfcTank.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTANKTYPE] = (d) => {
    return IfcTankType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASK] = (d) => {
    return IfcTask.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASKTIME] = (d) => {
    return IfcTaskTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASKTIMERECURRING] = (d) => {
    return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASKTYPE] = (d) => {
    return IfcTaskType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTELECOMADDRESS] = (d) => {
    return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDON] = (d) => {
    return IfcTendon.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONANCHOR] = (d) => {
    return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONANCHORTYPE] = (d) => {
    return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONCONDUIT] = (d) => {
    return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONCONDUITTYPE] = (d) => {
    return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONTYPE] = (d) => {
    return IfcTendonType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTESSELLATEDFACESET] = (d) => {
    return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTESSELLATEDITEM] = (d) => {
    return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTLITERAL] = (d) => {
    return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTLITERALWITHEXTENT] = (d) => {
    return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLE] = (d) => {
    return IfcTextStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLEFONTMODEL] = (d) => {
    return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = (d) => {
    return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLETEXTMODEL] = (d) => {
    return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTURECOORDINATE] = (d) => {
    return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = (d) => {
    return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTUREMAP] = (d) => {
    return IfcTextureMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTUREVERTEX] = (d) => {
    return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTUREVERTEXLIST] = (d) => {
    return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTIMEPERIOD] = (d) => {
    return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTIMESERIES] = (d) => {
    return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTIMESERIESVALUE] = (d) => {
    return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = (d) => {
    return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTOPOLOGYREPRESENTATION] = (d) => {
    return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTOROIDALSURFACE] = (d) => {
    return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSFORMER] = (d) => {
    return IfcTransformer.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSFORMERTYPE] = (d) => {
    return IfcTransformerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = (d) => {
    return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSPORTELEMENT] = (d) => {
    return IfcTransportElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSPORTELEMENTTYPE] = (d) => {
    return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = (d) => {
    return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRIANGULATEDFACESET] = (d) => {
    return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = (d) => {
    return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRIMMEDCURVE] = (d) => {
    return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTUBEBUNDLE] = (d) => {
    return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTUBEBUNDLETYPE] = (d) => {
    return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPEOBJECT] = (d) => {
    return IfcTypeObject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPEPROCESS] = (d) => {
    return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPEPRODUCT] = (d) => {
    return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPERESOURCE] = (d) => {
    return IfcTypeResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUSHAPEPROFILEDEF] = (d) => {
    return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITASSIGNMENT] = (d) => {
    return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYCONTROLELEMENT] = (d) => {
    return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = (d) => {
    return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYEQUIPMENT] = (d) => {
    return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = (d) => {
    return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVALVE] = (d) => {
    return IfcValve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVALVETYPE] = (d) => {
    return IfcValveType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVECTOR] = (d) => {
    return IfcVector.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVERTEX] = (d) => {
    return IfcVertex.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVERTEXLOOP] = (d) => {
    return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVERTEXPOINT] = (d) => {
    return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONDAMPER] = (d) => {
    return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONDAMPERTYPE] = (d) => {
    return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONISOLATOR] = (d) => {
    return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONISOLATORTYPE] = (d) => {
    return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIRTUALELEMENT] = (d) => {
    return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = (d) => {
    return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVOIDINGFEATURE] = (d) => {
    return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALL] = (d) => {
    return IfcWall.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALLELEMENTEDCASE] = (d) => {
    return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALLSTANDARDCASE] = (d) => {
    return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALLTYPE] = (d) => {
    return IfcWallType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWASTETERMINAL] = (d) => {
    return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWASTETERMINALTYPE] = (d) => {
    return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOW] = (d) => {
    return IfcWindow.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWLININGPROPERTIES] = (d) => {
    return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWPANELPROPERTIES] = (d) => {
    return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWSTANDARDCASE] = (d) => {
    return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWSTYLE] = (d) => {
    return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWTYPE] = (d) => {
    return IfcWindowType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKCALENDAR] = (d) => {
    return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKCONTROL] = (d) => {
    return IfcWorkControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKPLAN] = (d) => {
    return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKSCHEDULE] = (d) => {
    return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKTIME] = (d) => {
    return IfcWorkTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCZSHAPEPROFILEDEF] = (d) => {
    return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCZONE] = (d) => {
    return IfcZone.FromTape(d.ID, d.type, d.arguments);
  };
  var IfcActionRequest = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.PredefinedType);
      args.push(this.Status);
      args.push(this.LongDescription);
      return args;
    }
  };
  var IfcActor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.TheActor = TheActor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let TheActor = tape[ptr++];
      return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.TheActor);
      return args;
    }
  };
  var IfcActorRole = class {
    constructor(expressID, type, Role, UserDefinedRole, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Role = Role;
      this.UserDefinedRole = UserDefinedRole;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Role = tape[ptr++];
      let UserDefinedRole = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Role);
      args.push(this.UserDefinedRole);
      args.push(this.Description);
      return args;
    }
  };
  var IfcActuator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcActuatorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAddress = class {
    constructor(expressID, type, Purpose, Description, UserDefinedPurpose) {
      this.expressID = expressID;
      this.type = type;
      this.Purpose = Purpose;
      this.Description = Description;
      this.UserDefinedPurpose = UserDefinedPurpose;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Purpose = tape[ptr++];
      let Description = tape[ptr++];
      let UserDefinedPurpose = tape[ptr++];
      return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose);
    }
    ToTape() {
      let args = [];
      args.push(this.Purpose);
      args.push(this.Description);
      args.push(this.UserDefinedPurpose);
      return args;
    }
  };
  var IfcAdvancedBrep = class {
    constructor(expressID, type, Outer) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      return new IfcAdvancedBrep(expressID, type, Outer);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      return args;
    }
  };
  var IfcAdvancedBrepWithVoids = class {
    constructor(expressID, type, Outer, Voids) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
      this.Voids = Voids;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      let Voids = tape[ptr++];
      return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      args.push(this.Voids);
      return args;
    }
  };
  var IfcAdvancedFace = class {
    constructor(expressID, type, Bounds, FaceSurface, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.Bounds = Bounds;
      this.FaceSurface = FaceSurface;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bounds = tape[ptr++];
      let FaceSurface = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.Bounds);
      args.push(this.FaceSurface);
      args.push(this.SameSense);
      return args;
    }
  };
  var IfcAirTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAirTerminalBox = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAirTerminalBoxType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAirTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAirToAirHeatRecovery = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAirToAirHeatRecoveryType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAlarm = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAlarmType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAlignment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Axis = Axis;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Axis = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Axis);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAlignment2DHorizontal = class {
    constructor(expressID, type, StartDistAlong, Segments) {
      this.expressID = expressID;
      this.type = type;
      this.StartDistAlong = StartDistAlong;
      this.Segments = Segments;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartDistAlong = tape[ptr++];
      let Segments = tape[ptr++];
      return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments);
    }
    ToTape() {
      let args = [];
      args.push(this.StartDistAlong);
      args.push(this.Segments);
      return args;
    }
  };
  var IfcAlignment2DHorizontalSegment = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.CurveGeometry = CurveGeometry;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let CurveGeometry = tape[ptr++];
      return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      args.push(this.StartTag);
      args.push(this.EndTag);
      args.push(this.CurveGeometry);
      return args;
    }
  };
  var IfcAlignment2DSegment = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      args.push(this.StartTag);
      args.push(this.EndTag);
      return args;
    }
  };
  var IfcAlignment2DVerSegCircularArc = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
      this.Radius = Radius;
      this.IsConvex = IsConvex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      let Radius = tape[ptr++];
      let IsConvex = tape[ptr++];
      return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      args.push(this.StartTag);
      args.push(this.EndTag);
      args.push(this.StartDistAlong);
      args.push(this.HorizontalLength);
      args.push(this.StartHeight);
      args.push(this.StartGradient);
      args.push(this.Radius);
      args.push(this.IsConvex);
      return args;
    }
  };
  var IfcAlignment2DVerSegLine = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      args.push(this.StartTag);
      args.push(this.EndTag);
      args.push(this.StartDistAlong);
      args.push(this.HorizontalLength);
      args.push(this.StartHeight);
      args.push(this.StartGradient);
      return args;
    }
  };
  var IfcAlignment2DVerSegParabolicArc = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
      this.ParabolaConstant = ParabolaConstant;
      this.IsConvex = IsConvex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      let ParabolaConstant = tape[ptr++];
      let IsConvex = tape[ptr++];
      return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      args.push(this.StartTag);
      args.push(this.EndTag);
      args.push(this.StartDistAlong);
      args.push(this.HorizontalLength);
      args.push(this.StartHeight);
      args.push(this.StartGradient);
      args.push(this.ParabolaConstant);
      args.push(this.IsConvex);
      return args;
    }
  };
  var IfcAlignment2DVertical = class {
    constructor(expressID, type, Segments) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      return new IfcAlignment2DVertical(expressID, type, Segments);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      return args;
    }
  };
  var IfcAlignment2DVerticalSegment = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      args.push(this.StartTag);
      args.push(this.EndTag);
      args.push(this.StartDistAlong);
      args.push(this.HorizontalLength);
      args.push(this.StartHeight);
      args.push(this.StartGradient);
      return args;
    }
  };
  var IfcAlignmentCurve = class {
    constructor(expressID, type, Horizontal, Vertical, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.Horizontal = Horizontal;
      this.Vertical = Vertical;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Horizontal = tape[ptr++];
      let Vertical = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.Horizontal);
      args.push(this.Vertical);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcAnnotation = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      return args;
    }
  };
  var IfcAnnotationFillArea = class {
    constructor(expressID, type, OuterBoundary, InnerBoundaries) {
      this.expressID = expressID;
      this.type = type;
      this.OuterBoundary = OuterBoundary;
      this.InnerBoundaries = InnerBoundaries;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let OuterBoundary = tape[ptr++];
      let InnerBoundaries = tape[ptr++];
      return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries);
    }
    ToTape() {
      let args = [];
      args.push(this.OuterBoundary);
      args.push(this.InnerBoundaries);
      return args;
    }
  };
  var IfcApplication = class {
    constructor(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
      this.expressID = expressID;
      this.type = type;
      this.ApplicationDeveloper = ApplicationDeveloper;
      this.Version = Version;
      this.ApplicationFullName = ApplicationFullName;
      this.ApplicationIdentifier = ApplicationIdentifier;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ApplicationDeveloper = tape[ptr++];
      let Version = tape[ptr++];
      let ApplicationFullName = tape[ptr++];
      let ApplicationIdentifier = tape[ptr++];
      return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
    }
    ToTape() {
      let args = [];
      args.push(this.ApplicationDeveloper);
      args.push(this.Version);
      args.push(this.ApplicationFullName);
      args.push(this.ApplicationIdentifier);
      return args;
    }
  };
  var IfcAppliedValue = class {
    constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AppliedValue = AppliedValue;
      this.UnitBasis = UnitBasis;
      this.ApplicableDate = ApplicableDate;
      this.FixedUntilDate = FixedUntilDate;
      this.Category = Category;
      this.Condition = Condition;
      this.ArithmeticOperator = ArithmeticOperator;
      this.Components = Components;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AppliedValue = tape[ptr++];
      let UnitBasis = tape[ptr++];
      let ApplicableDate = tape[ptr++];
      let FixedUntilDate = tape[ptr++];
      let Category = tape[ptr++];
      let Condition = tape[ptr++];
      let ArithmeticOperator = tape[ptr++];
      let Components = tape[ptr++];
      return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.AppliedValue);
      args.push(this.UnitBasis);
      args.push(this.ApplicableDate);
      args.push(this.FixedUntilDate);
      args.push(this.Category);
      args.push(this.Condition);
      args.push(this.ArithmeticOperator);
      args.push(this.Components);
      return args;
    }
  };
  var IfcApproval = class {
    constructor(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
      this.expressID = expressID;
      this.type = type;
      this.Identifier = Identifier;
      this.Name = Name;
      this.Description = Description;
      this.TimeOfApproval = TimeOfApproval;
      this.Status = Status;
      this.Level = Level;
      this.Qualifier = Qualifier;
      this.RequestingApproval = RequestingApproval;
      this.GivingApproval = GivingApproval;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identifier = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let TimeOfApproval = tape[ptr++];
      let Status = tape[ptr++];
      let Level = tape[ptr++];
      let Qualifier = tape[ptr++];
      let RequestingApproval = tape[ptr++];
      let GivingApproval = tape[ptr++];
      return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
    }
    ToTape() {
      let args = [];
      args.push(this.Identifier);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.TimeOfApproval);
      args.push(this.Status);
      args.push(this.Level);
      args.push(this.Qualifier);
      args.push(this.RequestingApproval);
      args.push(this.GivingApproval);
      return args;
    }
  };
  var IfcApprovalRelationship = class {
    constructor(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingApproval = RelatingApproval;
      this.RelatedApprovals = RelatedApprovals;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingApproval = tape[ptr++];
      let RelatedApprovals = tape[ptr++];
      return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingApproval);
      args.push(this.RelatedApprovals);
      return args;
    }
  };
  var IfcArbitraryClosedProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, OuterCurve) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.OuterCurve = OuterCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let OuterCurve = tape[ptr++];
      return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.OuterCurve);
      return args;
    }
  };
  var IfcArbitraryOpenProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Curve) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Curve = Curve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Curve = tape[ptr++];
      return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Curve);
      return args;
    }
  };
  var IfcArbitraryProfileDefWithVoids = class {
    constructor(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.OuterCurve = OuterCurve;
      this.InnerCurves = InnerCurves;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let OuterCurve = tape[ptr++];
      let InnerCurves = tape[ptr++];
      return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.OuterCurve);
      args.push(this.InnerCurves);
      return args;
    }
  };
  var IfcAsset = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.OriginalValue = OriginalValue;
      this.CurrentValue = CurrentValue;
      this.TotalReplacementCost = TotalReplacementCost;
      this.Owner = Owner;
      this.User = User;
      this.ResponsiblePerson = ResponsiblePerson;
      this.IncorporationDate = IncorporationDate;
      this.DepreciatedValue = DepreciatedValue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let OriginalValue = tape[ptr++];
      let CurrentValue = tape[ptr++];
      let TotalReplacementCost = tape[ptr++];
      let Owner = tape[ptr++];
      let User = tape[ptr++];
      let ResponsiblePerson = tape[ptr++];
      let IncorporationDate = tape[ptr++];
      let DepreciatedValue = tape[ptr++];
      return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.OriginalValue);
      args.push(this.CurrentValue);
      args.push(this.TotalReplacementCost);
      args.push(this.Owner);
      args.push(this.User);
      args.push(this.ResponsiblePerson);
      args.push(this.IncorporationDate);
      args.push(this.DepreciatedValue);
      return args;
    }
  };
  var IfcAsymmetricIShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.BottomFlangeWidth = BottomFlangeWidth;
      this.OverallDepth = OverallDepth;
      this.WebThickness = WebThickness;
      this.BottomFlangeThickness = BottomFlangeThickness;
      this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
      this.TopFlangeWidth = TopFlangeWidth;
      this.TopFlangeThickness = TopFlangeThickness;
      this.TopFlangeFilletRadius = TopFlangeFilletRadius;
      this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
      this.BottomFlangeSlope = BottomFlangeSlope;
      this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
      this.TopFlangeSlope = TopFlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let BottomFlangeWidth = tape[ptr++];
      let OverallDepth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let BottomFlangeThickness = tape[ptr++];
      let BottomFlangeFilletRadius = tape[ptr++];
      let TopFlangeWidth = tape[ptr++];
      let TopFlangeThickness = tape[ptr++];
      let TopFlangeFilletRadius = tape[ptr++];
      let BottomFlangeEdgeRadius = tape[ptr++];
      let BottomFlangeSlope = tape[ptr++];
      let TopFlangeEdgeRadius = tape[ptr++];
      let TopFlangeSlope = tape[ptr++];
      return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.BottomFlangeWidth);
      args.push(this.OverallDepth);
      args.push(this.WebThickness);
      args.push(this.BottomFlangeThickness);
      args.push(this.BottomFlangeFilletRadius);
      args.push(this.TopFlangeWidth);
      args.push(this.TopFlangeThickness);
      args.push(this.TopFlangeFilletRadius);
      args.push(this.BottomFlangeEdgeRadius);
      args.push(this.BottomFlangeSlope);
      args.push(this.TopFlangeEdgeRadius);
      args.push(this.TopFlangeSlope);
      return args;
    }
  };
  var IfcAudioVisualAppliance = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAudioVisualApplianceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcAxis1Placement = class {
    constructor(expressID, type, Location, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcAxis1Placement(expressID, type, Location, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Axis);
      return args;
    }
  };
  var IfcAxis2Placement2D = class {
    constructor(expressID, type, Location, RefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.RefDirection = RefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let RefDirection = tape[ptr++];
      return new IfcAxis2Placement2D(expressID, type, Location, RefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.RefDirection);
      return args;
    }
  };
  var IfcAxis2Placement3D = class {
    constructor(expressID, type, Location, Axis, RefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Axis = Axis;
      this.RefDirection = RefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Axis = tape[ptr++];
      let RefDirection = tape[ptr++];
      return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Axis);
      args.push(this.RefDirection);
      return args;
    }
  };
  var IfcBSplineCurve = class {
    constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Degree = Degree;
      this.ControlPointsList = ControlPointsList;
      this.CurveForm = CurveForm;
      this.ClosedCurve = ClosedCurve;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Degree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let CurveForm = tape[ptr++];
      let ClosedCurve = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Degree);
      args.push(this.ControlPointsList);
      args.push(this.CurveForm);
      args.push(this.ClosedCurve);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcBSplineCurveWithKnots = class {
    constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
      this.expressID = expressID;
      this.type = type;
      this.Degree = Degree;
      this.ControlPointsList = ControlPointsList;
      this.CurveForm = CurveForm;
      this.ClosedCurve = ClosedCurve;
      this.SelfIntersect = SelfIntersect;
      this.KnotMultiplicities = KnotMultiplicities;
      this.Knots = Knots;
      this.KnotSpec = KnotSpec;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Degree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let CurveForm = tape[ptr++];
      let ClosedCurve = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let KnotMultiplicities = tape[ptr++];
      let Knots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
    }
    ToTape() {
      let args = [];
      args.push(this.Degree);
      args.push(this.ControlPointsList);
      args.push(this.CurveForm);
      args.push(this.ClosedCurve);
      args.push(this.SelfIntersect);
      args.push(this.KnotMultiplicities);
      args.push(this.Knots);
      args.push(this.KnotSpec);
      return args;
    }
  };
  var IfcBSplineSurface = class {
    constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.UDegree = UDegree;
      this.VDegree = VDegree;
      this.ControlPointsList = ControlPointsList;
      this.SurfaceForm = SurfaceForm;
      this.UClosed = UClosed;
      this.VClosed = VClosed;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let UDegree = tape[ptr++];
      let VDegree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let SurfaceForm = tape[ptr++];
      let UClosed = tape[ptr++];
      let VClosed = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.UDegree);
      args.push(this.VDegree);
      args.push(this.ControlPointsList);
      args.push(this.SurfaceForm);
      args.push(this.UClosed);
      args.push(this.VClosed);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcBSplineSurfaceWithKnots = class {
    constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
      this.expressID = expressID;
      this.type = type;
      this.UDegree = UDegree;
      this.VDegree = VDegree;
      this.ControlPointsList = ControlPointsList;
      this.SurfaceForm = SurfaceForm;
      this.UClosed = UClosed;
      this.VClosed = VClosed;
      this.SelfIntersect = SelfIntersect;
      this.UMultiplicities = UMultiplicities;
      this.VMultiplicities = VMultiplicities;
      this.UKnots = UKnots;
      this.VKnots = VKnots;
      this.KnotSpec = KnotSpec;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let UDegree = tape[ptr++];
      let VDegree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let SurfaceForm = tape[ptr++];
      let UClosed = tape[ptr++];
      let VClosed = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let UMultiplicities = tape[ptr++];
      let VMultiplicities = tape[ptr++];
      let UKnots = tape[ptr++];
      let VKnots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
    }
    ToTape() {
      let args = [];
      args.push(this.UDegree);
      args.push(this.VDegree);
      args.push(this.ControlPointsList);
      args.push(this.SurfaceForm);
      args.push(this.UClosed);
      args.push(this.VClosed);
      args.push(this.SelfIntersect);
      args.push(this.UMultiplicities);
      args.push(this.VMultiplicities);
      args.push(this.UKnots);
      args.push(this.VKnots);
      args.push(this.KnotSpec);
      return args;
    }
  };
  var IfcBeam = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBeamStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBeamType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBearing = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBearingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBlobTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
      this.RasterFormat = RasterFormat;
      this.RasterCode = RasterCode;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      let RasterFormat = tape[ptr++];
      let RasterCode = tape[ptr++];
      return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      args.push(this.RepeatT);
      args.push(this.Mode);
      args.push(this.TextureTransform);
      args.push(this.Parameter);
      args.push(this.RasterFormat);
      args.push(this.RasterCode);
      return args;
    }
  };
  var IfcBlock = class {
    constructor(expressID, type, Position, XLength, YLength, ZLength) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.XLength = XLength;
      this.YLength = YLength;
      this.ZLength = ZLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let XLength = tape[ptr++];
      let YLength = tape[ptr++];
      let ZLength = tape[ptr++];
      return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.XLength);
      args.push(this.YLength);
      args.push(this.ZLength);
      return args;
    }
  };
  var IfcBoiler = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBoilerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBooleanClippingResult = class {
    constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
      this.expressID = expressID;
      this.type = type;
      this.Operator = Operator;
      this.FirstOperand = FirstOperand;
      this.SecondOperand = SecondOperand;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Operator = tape[ptr++];
      let FirstOperand = tape[ptr++];
      let SecondOperand = tape[ptr++];
      return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand);
    }
    ToTape() {
      let args = [];
      args.push(this.Operator);
      args.push(this.FirstOperand);
      args.push(this.SecondOperand);
      return args;
    }
  };
  var IfcBooleanResult = class {
    constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
      this.expressID = expressID;
      this.type = type;
      this.Operator = Operator;
      this.FirstOperand = FirstOperand;
      this.SecondOperand = SecondOperand;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Operator = tape[ptr++];
      let FirstOperand = tape[ptr++];
      let SecondOperand = tape[ptr++];
      return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand);
    }
    ToTape() {
      let args = [];
      args.push(this.Operator);
      args.push(this.FirstOperand);
      args.push(this.SecondOperand);
      return args;
    }
  };
  var IfcBoundaryCondition = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcBoundaryCondition(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcBoundaryCurve = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcBoundaryEdgeCondition = class {
    constructor(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
      this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
      this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
      this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
      this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
      this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessByLengthX = tape[ptr++];
      let TranslationalStiffnessByLengthY = tape[ptr++];
      let TranslationalStiffnessByLengthZ = tape[ptr++];
      let RotationalStiffnessByLengthX = tape[ptr++];
      let RotationalStiffnessByLengthY = tape[ptr++];
      let RotationalStiffnessByLengthZ = tape[ptr++];
      return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.TranslationalStiffnessByLengthX);
      args.push(this.TranslationalStiffnessByLengthY);
      args.push(this.TranslationalStiffnessByLengthZ);
      args.push(this.RotationalStiffnessByLengthX);
      args.push(this.RotationalStiffnessByLengthY);
      args.push(this.RotationalStiffnessByLengthZ);
      return args;
    }
  };
  var IfcBoundaryFaceCondition = class {
    constructor(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
      this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
      this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessByAreaX = tape[ptr++];
      let TranslationalStiffnessByAreaY = tape[ptr++];
      let TranslationalStiffnessByAreaZ = tape[ptr++];
      return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.TranslationalStiffnessByAreaX);
      args.push(this.TranslationalStiffnessByAreaY);
      args.push(this.TranslationalStiffnessByAreaZ);
      return args;
    }
  };
  var IfcBoundaryNodeCondition = class {
    constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessX = TranslationalStiffnessX;
      this.TranslationalStiffnessY = TranslationalStiffnessY;
      this.TranslationalStiffnessZ = TranslationalStiffnessZ;
      this.RotationalStiffnessX = RotationalStiffnessX;
      this.RotationalStiffnessY = RotationalStiffnessY;
      this.RotationalStiffnessZ = RotationalStiffnessZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessX = tape[ptr++];
      let TranslationalStiffnessY = tape[ptr++];
      let TranslationalStiffnessZ = tape[ptr++];
      let RotationalStiffnessX = tape[ptr++];
      let RotationalStiffnessY = tape[ptr++];
      let RotationalStiffnessZ = tape[ptr++];
      return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.TranslationalStiffnessX);
      args.push(this.TranslationalStiffnessY);
      args.push(this.TranslationalStiffnessZ);
      args.push(this.RotationalStiffnessX);
      args.push(this.RotationalStiffnessY);
      args.push(this.RotationalStiffnessZ);
      return args;
    }
  };
  var IfcBoundaryNodeConditionWarping = class {
    constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessX = TranslationalStiffnessX;
      this.TranslationalStiffnessY = TranslationalStiffnessY;
      this.TranslationalStiffnessZ = TranslationalStiffnessZ;
      this.RotationalStiffnessX = RotationalStiffnessX;
      this.RotationalStiffnessY = RotationalStiffnessY;
      this.RotationalStiffnessZ = RotationalStiffnessZ;
      this.WarpingStiffness = WarpingStiffness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessX = tape[ptr++];
      let TranslationalStiffnessY = tape[ptr++];
      let TranslationalStiffnessZ = tape[ptr++];
      let RotationalStiffnessX = tape[ptr++];
      let RotationalStiffnessY = tape[ptr++];
      let RotationalStiffnessZ = tape[ptr++];
      let WarpingStiffness = tape[ptr++];
      return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.TranslationalStiffnessX);
      args.push(this.TranslationalStiffnessY);
      args.push(this.TranslationalStiffnessZ);
      args.push(this.RotationalStiffnessX);
      args.push(this.RotationalStiffnessY);
      args.push(this.RotationalStiffnessZ);
      args.push(this.WarpingStiffness);
      return args;
    }
  };
  var IfcBoundedCurve = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcBoundedCurve(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcBoundedSurface = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcBoundedSurface(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcBoundingBox = class {
    constructor(expressID, type, Corner, XDim, YDim, ZDim) {
      this.expressID = expressID;
      this.type = type;
      this.Corner = Corner;
      this.XDim = XDim;
      this.YDim = YDim;
      this.ZDim = ZDim;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Corner = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      let ZDim = tape[ptr++];
      return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim);
    }
    ToTape() {
      let args = [];
      args.push(this.Corner);
      args.push(this.XDim);
      args.push(this.YDim);
      args.push(this.ZDim);
      return args;
    }
  };
  var IfcBoxedHalfSpace = class {
    constructor(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
      this.expressID = expressID;
      this.type = type;
      this.BaseSurface = BaseSurface;
      this.AgreementFlag = AgreementFlag;
      this.Enclosure = Enclosure;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BaseSurface = tape[ptr++];
      let AgreementFlag = tape[ptr++];
      let Enclosure = tape[ptr++];
      return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure);
    }
    ToTape() {
      let args = [];
      args.push(this.BaseSurface);
      args.push(this.AgreementFlag);
      args.push(this.Enclosure);
      return args;
    }
  };
  var IfcBridge = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBridgePart = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBuilding = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.ElevationOfRefHeight = ElevationOfRefHeight;
      this.ElevationOfTerrain = ElevationOfTerrain;
      this.BuildingAddress = BuildingAddress;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let ElevationOfRefHeight = tape[ptr++];
      let ElevationOfTerrain = tape[ptr++];
      let BuildingAddress = tape[ptr++];
      return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      args.push(this.ElevationOfRefHeight);
      args.push(this.ElevationOfTerrain);
      args.push(this.BuildingAddress);
      return args;
    }
  };
  var IfcBuildingElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcBuildingElementPart = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBuildingElementPartType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBuildingElementProxy = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBuildingElementProxyType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBuildingElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcBuildingStorey = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.Elevation = Elevation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let Elevation = tape[ptr++];
      return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      args.push(this.Elevation);
      return args;
    }
  };
  var IfcBuildingSystem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.PredefinedType);
      args.push(this.LongName);
      return args;
    }
  };
  var IfcBurner = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcBurnerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.Width = Width;
      this.WallThickness = WallThickness;
      this.Girth = Girth;
      this.InternalFilletRadius = InternalFilletRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let Width = tape[ptr++];
      let WallThickness = tape[ptr++];
      let Girth = tape[ptr++];
      let InternalFilletRadius = tape[ptr++];
      return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Depth);
      args.push(this.Width);
      args.push(this.WallThickness);
      args.push(this.Girth);
      args.push(this.InternalFilletRadius);
      return args;
    }
  };
  var IfcCableCarrierFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableCarrierFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableCarrierSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableCarrierSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCableSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCaissonFoundation = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCaissonFoundationType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCartesianPoint = class {
    constructor(expressID, type, Coordinates) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      return new IfcCartesianPoint(expressID, type, Coordinates);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      return args;
    }
  };
  var IfcCartesianPointList = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcCartesianPointList(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcCartesianPointList2D = class {
    constructor(expressID, type, CoordList, TagList) {
      this.expressID = expressID;
      this.type = type;
      this.CoordList = CoordList;
      this.TagList = TagList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordList = tape[ptr++];
      let TagList = tape[ptr++];
      return new IfcCartesianPointList2D(expressID, type, CoordList, TagList);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordList);
      args.push(this.TagList);
      return args;
    }
  };
  var IfcCartesianPointList3D = class {
    constructor(expressID, type, CoordList, TagList) {
      this.expressID = expressID;
      this.type = type;
      this.CoordList = CoordList;
      this.TagList = TagList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordList = tape[ptr++];
      let TagList = tape[ptr++];
      return new IfcCartesianPointList3D(expressID, type, CoordList, TagList);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordList);
      args.push(this.TagList);
      return args;
    }
  };
  var IfcCartesianTransformationOperator = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      args.push(this.Axis2);
      args.push(this.LocalOrigin);
      args.push(this.Scale);
      return args;
    }
  };
  var IfcCartesianTransformationOperator2D = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      args.push(this.Axis2);
      args.push(this.LocalOrigin);
      args.push(this.Scale);
      return args;
    }
  };
  var IfcCartesianTransformationOperator2DnonUniform = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
      this.Scale2 = Scale2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      let Scale2 = tape[ptr++];
      return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      args.push(this.Axis2);
      args.push(this.LocalOrigin);
      args.push(this.Scale);
      args.push(this.Scale2);
      return args;
    }
  };
  var IfcCartesianTransformationOperator3D = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
      this.Axis3 = Axis3;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      let Axis3 = tape[ptr++];
      return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      args.push(this.Axis2);
      args.push(this.LocalOrigin);
      args.push(this.Scale);
      args.push(this.Axis3);
      return args;
    }
  };
  var IfcCartesianTransformationOperator3DnonUniform = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
      this.Axis3 = Axis3;
      this.Scale2 = Scale2;
      this.Scale3 = Scale3;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      let Axis3 = tape[ptr++];
      let Scale2 = tape[ptr++];
      let Scale3 = tape[ptr++];
      return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      args.push(this.Axis2);
      args.push(this.LocalOrigin);
      args.push(this.Scale);
      args.push(this.Axis3);
      args.push(this.Scale2);
      args.push(this.Scale3);
      return args;
    }
  };
  var IfcCenterLineProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Curve, Thickness) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Curve = Curve;
      this.Thickness = Thickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Curve = tape[ptr++];
      let Thickness = tape[ptr++];
      return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Curve);
      args.push(this.Thickness);
      return args;
    }
  };
  var IfcChiller = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcChillerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcChimney = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcChimneyType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCircle = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcCircle(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.Radius);
      return args;
    }
  };
  var IfcCircleHollowProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Radius = Radius;
      this.WallThickness = WallThickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      let WallThickness = tape[ptr++];
      return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Radius);
      args.push(this.WallThickness);
      return args;
    }
  };
  var IfcCircleProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Radius);
      return args;
    }
  };
  var IfcCircularArcSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
      this.Radius = Radius;
      this.IsCCW = IsCCW;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      let Radius = tape[ptr++];
      let IsCCW = tape[ptr++];
      return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      args.push(this.StartDirection);
      args.push(this.SegmentLength);
      args.push(this.Radius);
      args.push(this.IsCCW);
      return args;
    }
  };
  var IfcCivilElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcCivilElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcClassification = class {
    constructor(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
      this.expressID = expressID;
      this.type = type;
      this.Source = Source;
      this.Edition = Edition;
      this.EditionDate = EditionDate;
      this.Name = Name;
      this.Description = Description;
      this.Location = Location;
      this.ReferenceTokens = ReferenceTokens;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Source = tape[ptr++];
      let Edition = tape[ptr++];
      let EditionDate = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Location = tape[ptr++];
      let ReferenceTokens = tape[ptr++];
      return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
    }
    ToTape() {
      let args = [];
      args.push(this.Source);
      args.push(this.Edition);
      args.push(this.EditionDate);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Location);
      args.push(this.ReferenceTokens);
      return args;
    }
  };
  var IfcClassificationReference = class {
    constructor(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
      this.ReferencedSource = ReferencedSource;
      this.Description = Description;
      this.Sort = Sort;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let ReferencedSource = tape[ptr++];
      let Description = tape[ptr++];
      let Sort = tape[ptr++];
      return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      args.push(this.ReferencedSource);
      args.push(this.Description);
      args.push(this.Sort);
      return args;
    }
  };
  var IfcClosedShell = class {
    constructor(expressID, type, CfsFaces) {
      this.expressID = expressID;
      this.type = type;
      this.CfsFaces = CfsFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CfsFaces = tape[ptr++];
      return new IfcClosedShell(expressID, type, CfsFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.CfsFaces);
      return args;
    }
  };
  var IfcCoil = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCoilType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcColourRgb = class {
    constructor(expressID, type, Name, Red, Green, Blue) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Red = Red;
      this.Green = Green;
      this.Blue = Blue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Red = tape[ptr++];
      let Green = tape[ptr++];
      let Blue = tape[ptr++];
      return new IfcColourRgb(expressID, type, Name, Red, Green, Blue);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Red);
      args.push(this.Green);
      args.push(this.Blue);
      return args;
    }
  };
  var IfcColourRgbList = class {
    constructor(expressID, type, ColourList) {
      this.expressID = expressID;
      this.type = type;
      this.ColourList = ColourList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ColourList = tape[ptr++];
      return new IfcColourRgbList(expressID, type, ColourList);
    }
    ToTape() {
      let args = [];
      args.push(this.ColourList);
      return args;
    }
  };
  var IfcColourSpecification = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcColourSpecification(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcColumn = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcColumnStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcColumnType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCommunicationsAppliance = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCommunicationsApplianceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcComplexProperty = class {
    constructor(expressID, type, Name, Description, UsageName, HasProperties) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.UsageName = UsageName;
      this.HasProperties = HasProperties;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UsageName = tape[ptr++];
      let HasProperties = tape[ptr++];
      return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.UsageName);
      args.push(this.HasProperties);
      return args;
    }
  };
  var IfcComplexPropertyTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.UsageName = UsageName;
      this.TemplateType = TemplateType;
      this.HasPropertyTemplates = HasPropertyTemplates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UsageName = tape[ptr++];
      let TemplateType = tape[ptr++];
      let HasPropertyTemplates = tape[ptr++];
      return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.UsageName);
      args.push(this.TemplateType);
      args.push(this.HasPropertyTemplates);
      return args;
    }
  };
  var IfcCompositeCurve = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcCompositeCurveOnSurface = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcCompositeCurveSegment = class {
    constructor(expressID, type, Transition, SameSense, ParentCurve) {
      this.expressID = expressID;
      this.type = type;
      this.Transition = Transition;
      this.SameSense = SameSense;
      this.ParentCurve = ParentCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Transition = tape[ptr++];
      let SameSense = tape[ptr++];
      let ParentCurve = tape[ptr++];
      return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.Transition);
      args.push(this.SameSense);
      args.push(this.ParentCurve);
      return args;
    }
  };
  var IfcCompositeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Profiles, Label) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Profiles = Profiles;
      this.Label = Label;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Profiles = tape[ptr++];
      let Label = tape[ptr++];
      return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Profiles);
      args.push(this.Label);
      return args;
    }
  };
  var IfcCompressor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCompressorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCondenser = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCondenserType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConic = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcConic(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      return args;
    }
  };
  var IfcConnectedFaceSet = class {
    constructor(expressID, type, CfsFaces) {
      this.expressID = expressID;
      this.type = type;
      this.CfsFaces = CfsFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CfsFaces = tape[ptr++];
      return new IfcConnectedFaceSet(expressID, type, CfsFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.CfsFaces);
      return args;
    }
  };
  var IfcConnectionCurveGeometry = class {
    constructor(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.CurveOnRelatingElement = CurveOnRelatingElement;
      this.CurveOnRelatedElement = CurveOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CurveOnRelatingElement = tape[ptr++];
      let CurveOnRelatedElement = tape[ptr++];
      return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.CurveOnRelatingElement);
      args.push(this.CurveOnRelatedElement);
      return args;
    }
  };
  var IfcConnectionGeometry = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcConnectionGeometry(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcConnectionPointEccentricity = class {
    constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
      this.expressID = expressID;
      this.type = type;
      this.PointOnRelatingElement = PointOnRelatingElement;
      this.PointOnRelatedElement = PointOnRelatedElement;
      this.EccentricityInX = EccentricityInX;
      this.EccentricityInY = EccentricityInY;
      this.EccentricityInZ = EccentricityInZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PointOnRelatingElement = tape[ptr++];
      let PointOnRelatedElement = tape[ptr++];
      let EccentricityInX = tape[ptr++];
      let EccentricityInY = tape[ptr++];
      let EccentricityInZ = tape[ptr++];
      return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
    }
    ToTape() {
      let args = [];
      args.push(this.PointOnRelatingElement);
      args.push(this.PointOnRelatedElement);
      args.push(this.EccentricityInX);
      args.push(this.EccentricityInY);
      args.push(this.EccentricityInZ);
      return args;
    }
  };
  var IfcConnectionPointGeometry = class {
    constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.PointOnRelatingElement = PointOnRelatingElement;
      this.PointOnRelatedElement = PointOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PointOnRelatingElement = tape[ptr++];
      let PointOnRelatedElement = tape[ptr++];
      return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.PointOnRelatingElement);
      args.push(this.PointOnRelatedElement);
      return args;
    }
  };
  var IfcConnectionSurfaceGeometry = class {
    constructor(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
      this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SurfaceOnRelatingElement = tape[ptr++];
      let SurfaceOnRelatedElement = tape[ptr++];
      return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.SurfaceOnRelatingElement);
      args.push(this.SurfaceOnRelatedElement);
      return args;
    }
  };
  var IfcConnectionVolumeGeometry = class {
    constructor(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.VolumeOnRelatingElement = VolumeOnRelatingElement;
      this.VolumeOnRelatedElement = VolumeOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let VolumeOnRelatingElement = tape[ptr++];
      let VolumeOnRelatedElement = tape[ptr++];
      return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.VolumeOnRelatingElement);
      args.push(this.VolumeOnRelatedElement);
      return args;
    }
  };
  var IfcConstraint = class {
    constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ConstraintGrade = ConstraintGrade;
      this.ConstraintSource = ConstraintSource;
      this.CreatingActor = CreatingActor;
      this.CreationTime = CreationTime;
      this.UserDefinedGrade = UserDefinedGrade;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConstraintGrade = tape[ptr++];
      let ConstraintSource = tape[ptr++];
      let CreatingActor = tape[ptr++];
      let CreationTime = tape[ptr++];
      let UserDefinedGrade = tape[ptr++];
      return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ConstraintGrade);
      args.push(this.ConstraintSource);
      args.push(this.CreatingActor);
      args.push(this.CreationTime);
      args.push(this.UserDefinedGrade);
      return args;
    }
  };
  var IfcConstructionEquipmentResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConstructionEquipmentResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConstructionMaterialResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConstructionMaterialResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConstructionProductResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConstructionProductResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConstructionResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      return args;
    }
  };
  var IfcConstructionResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      return args;
    }
  };
  var IfcContext = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.Phase = Phase;
      this.RepresentationContexts = RepresentationContexts;
      this.UnitsInContext = UnitsInContext;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let Phase = tape[ptr++];
      let RepresentationContexts = tape[ptr++];
      let UnitsInContext = tape[ptr++];
      return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.LongName);
      args.push(this.Phase);
      args.push(this.RepresentationContexts);
      args.push(this.UnitsInContext);
      return args;
    }
  };
  var IfcContextDependentUnit = class {
    constructor(expressID, type, Dimensions, UnitType, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      args.push(this.UnitType);
      args.push(this.Name);
      return args;
    }
  };
  var IfcControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      return args;
    }
  };
  var IfcController = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcControllerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcConversionBasedUnit = class {
    constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Name = Name;
      this.ConversionFactor = ConversionFactor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Name = tape[ptr++];
      let ConversionFactor = tape[ptr++];
      return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      args.push(this.UnitType);
      args.push(this.Name);
      args.push(this.ConversionFactor);
      return args;
    }
  };
  var IfcConversionBasedUnitWithOffset = class {
    constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Name = Name;
      this.ConversionFactor = ConversionFactor;
      this.ConversionOffset = ConversionOffset;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Name = tape[ptr++];
      let ConversionFactor = tape[ptr++];
      let ConversionOffset = tape[ptr++];
      return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      args.push(this.UnitType);
      args.push(this.Name);
      args.push(this.ConversionFactor);
      args.push(this.ConversionOffset);
      return args;
    }
  };
  var IfcCooledBeam = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCooledBeamType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCoolingTower = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCoolingTowerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCoordinateOperation = class {
    constructor(expressID, type, SourceCRS, TargetCRS) {
      this.expressID = expressID;
      this.type = type;
      this.SourceCRS = SourceCRS;
      this.TargetCRS = TargetCRS;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SourceCRS = tape[ptr++];
      let TargetCRS = tape[ptr++];
      return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS);
    }
    ToTape() {
      let args = [];
      args.push(this.SourceCRS);
      args.push(this.TargetCRS);
      return args;
    }
  };
  var IfcCoordinateReferenceSystem = class {
    constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.GeodeticDatum = GeodeticDatum;
      this.VerticalDatum = VerticalDatum;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let GeodeticDatum = tape[ptr++];
      let VerticalDatum = tape[ptr++];
      return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.GeodeticDatum);
      args.push(this.VerticalDatum);
      return args;
    }
  };
  var IfcCostItem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.CostValues = CostValues;
      this.CostQuantities = CostQuantities;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let CostValues = tape[ptr++];
      let CostQuantities = tape[ptr++];
      return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.PredefinedType);
      args.push(this.CostValues);
      args.push(this.CostQuantities);
      return args;
    }
  };
  var IfcCostSchedule = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.SubmittedOn = SubmittedOn;
      this.UpdateDate = UpdateDate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let SubmittedOn = tape[ptr++];
      let UpdateDate = tape[ptr++];
      return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.PredefinedType);
      args.push(this.Status);
      args.push(this.SubmittedOn);
      args.push(this.UpdateDate);
      return args;
    }
  };
  var IfcCostValue = class {
    constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AppliedValue = AppliedValue;
      this.UnitBasis = UnitBasis;
      this.ApplicableDate = ApplicableDate;
      this.FixedUntilDate = FixedUntilDate;
      this.Category = Category;
      this.Condition = Condition;
      this.ArithmeticOperator = ArithmeticOperator;
      this.Components = Components;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AppliedValue = tape[ptr++];
      let UnitBasis = tape[ptr++];
      let ApplicableDate = tape[ptr++];
      let FixedUntilDate = tape[ptr++];
      let Category = tape[ptr++];
      let Condition = tape[ptr++];
      let ArithmeticOperator = tape[ptr++];
      let Components = tape[ptr++];
      return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.AppliedValue);
      args.push(this.UnitBasis);
      args.push(this.ApplicableDate);
      args.push(this.FixedUntilDate);
      args.push(this.Category);
      args.push(this.Condition);
      args.push(this.ArithmeticOperator);
      args.push(this.Components);
      return args;
    }
  };
  var IfcCovering = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCoveringType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCrewResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCrewResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCsgPrimitive3D = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcCsgPrimitive3D(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      return args;
    }
  };
  var IfcCsgSolid = class {
    constructor(expressID, type, TreeRootExpression) {
      this.expressID = expressID;
      this.type = type;
      this.TreeRootExpression = TreeRootExpression;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TreeRootExpression = tape[ptr++];
      return new IfcCsgSolid(expressID, type, TreeRootExpression);
    }
    ToTape() {
      let args = [];
      args.push(this.TreeRootExpression);
      return args;
    }
  };
  var IfcCurrencyRelationship = class {
    constructor(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingMonetaryUnit = RelatingMonetaryUnit;
      this.RelatedMonetaryUnit = RelatedMonetaryUnit;
      this.ExchangeRate = ExchangeRate;
      this.RateDateTime = RateDateTime;
      this.RateSource = RateSource;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingMonetaryUnit = tape[ptr++];
      let RelatedMonetaryUnit = tape[ptr++];
      let ExchangeRate = tape[ptr++];
      let RateDateTime = tape[ptr++];
      let RateSource = tape[ptr++];
      return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingMonetaryUnit);
      args.push(this.RelatedMonetaryUnit);
      args.push(this.ExchangeRate);
      args.push(this.RateDateTime);
      args.push(this.RateSource);
      return args;
    }
  };
  var IfcCurtainWall = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCurtainWallType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcCurve = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcCurve(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcCurveBoundedPlane = class {
    constructor(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.OuterBoundary = OuterBoundary;
      this.InnerBoundaries = InnerBoundaries;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let OuterBoundary = tape[ptr++];
      let InnerBoundaries = tape[ptr++];
      return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      args.push(this.OuterBoundary);
      args.push(this.InnerBoundaries);
      return args;
    }
  };
  var IfcCurveBoundedSurface = class {
    constructor(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.Boundaries = Boundaries;
      this.ImplicitOuter = ImplicitOuter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let Boundaries = tape[ptr++];
      let ImplicitOuter = tape[ptr++];
      return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      args.push(this.Boundaries);
      args.push(this.ImplicitOuter);
      return args;
    }
  };
  var IfcCurveSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      args.push(this.StartDirection);
      args.push(this.SegmentLength);
      return args;
    }
  };
  var IfcCurveStyle = class {
    constructor(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.CurveFont = CurveFont;
      this.CurveWidth = CurveWidth;
      this.CurveColour = CurveColour;
      this.ModelOrDraughting = ModelOrDraughting;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let CurveFont = tape[ptr++];
      let CurveWidth = tape[ptr++];
      let CurveColour = tape[ptr++];
      let ModelOrDraughting = tape[ptr++];
      return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.CurveFont);
      args.push(this.CurveWidth);
      args.push(this.CurveColour);
      args.push(this.ModelOrDraughting);
      return args;
    }
  };
  var IfcCurveStyleFont = class {
    constructor(expressID, type, Name, PatternList) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.PatternList = PatternList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let PatternList = tape[ptr++];
      return new IfcCurveStyleFont(expressID, type, Name, PatternList);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.PatternList);
      return args;
    }
  };
  var IfcCurveStyleFontAndScaling = class {
    constructor(expressID, type, Name, CurveFont, CurveFontScaling) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.CurveFont = CurveFont;
      this.CurveFontScaling = CurveFontScaling;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let CurveFont = tape[ptr++];
      let CurveFontScaling = tape[ptr++];
      return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.CurveFont);
      args.push(this.CurveFontScaling);
      return args;
    }
  };
  var IfcCurveStyleFontPattern = class {
    constructor(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
      this.expressID = expressID;
      this.type = type;
      this.VisibleSegmentLength = VisibleSegmentLength;
      this.InvisibleSegmentLength = InvisibleSegmentLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let VisibleSegmentLength = tape[ptr++];
      let InvisibleSegmentLength = tape[ptr++];
      return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength);
    }
    ToTape() {
      let args = [];
      args.push(this.VisibleSegmentLength);
      args.push(this.InvisibleSegmentLength);
      return args;
    }
  };
  var IfcCylindricalSurface = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcCylindricalSurface(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.Radius);
      return args;
    }
  };
  var IfcDamper = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDamperType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDeepFoundation = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcDeepFoundationType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcDerivedProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.ParentProfile = ParentProfile;
      this.Operator = Operator;
      this.Label = Label;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let ParentProfile = tape[ptr++];
      let Operator = tape[ptr++];
      let Label = tape[ptr++];
      return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.ParentProfile);
      args.push(this.Operator);
      args.push(this.Label);
      return args;
    }
  };
  var IfcDerivedUnit = class {
    constructor(expressID, type, Elements, UnitType, UserDefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.Elements = Elements;
      this.UnitType = UnitType;
      this.UserDefinedType = UserDefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Elements = tape[ptr++];
      let UnitType = tape[ptr++];
      let UserDefinedType = tape[ptr++];
      return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.Elements);
      args.push(this.UnitType);
      args.push(this.UserDefinedType);
      return args;
    }
  };
  var IfcDerivedUnitElement = class {
    constructor(expressID, type, Unit, Exponent) {
      this.expressID = expressID;
      this.type = type;
      this.Unit = Unit;
      this.Exponent = Exponent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Unit = tape[ptr++];
      let Exponent = tape[ptr++];
      return new IfcDerivedUnitElement(expressID, type, Unit, Exponent);
    }
    ToTape() {
      let args = [];
      args.push(this.Unit);
      args.push(this.Exponent);
      return args;
    }
  };
  var IfcDimensionalExponents = class {
    constructor(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
      this.expressID = expressID;
      this.type = type;
      this.LengthExponent = LengthExponent;
      this.MassExponent = MassExponent;
      this.TimeExponent = TimeExponent;
      this.ElectricCurrentExponent = ElectricCurrentExponent;
      this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
      this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
      this.LuminousIntensityExponent = LuminousIntensityExponent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LengthExponent = tape[ptr++];
      let MassExponent = tape[ptr++];
      let TimeExponent = tape[ptr++];
      let ElectricCurrentExponent = tape[ptr++];
      let ThermodynamicTemperatureExponent = tape[ptr++];
      let AmountOfSubstanceExponent = tape[ptr++];
      let LuminousIntensityExponent = tape[ptr++];
      return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
    }
    ToTape() {
      let args = [];
      args.push(this.LengthExponent);
      args.push(this.MassExponent);
      args.push(this.TimeExponent);
      args.push(this.ElectricCurrentExponent);
      args.push(this.ThermodynamicTemperatureExponent);
      args.push(this.AmountOfSubstanceExponent);
      args.push(this.LuminousIntensityExponent);
      return args;
    }
  };
  var IfcDirection = class {
    constructor(expressID, type, DirectionRatios) {
      this.expressID = expressID;
      this.type = type;
      this.DirectionRatios = DirectionRatios;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let DirectionRatios = tape[ptr++];
      return new IfcDirection(expressID, type, DirectionRatios);
    }
    ToTape() {
      let args = [];
      args.push(this.DirectionRatios);
      return args;
    }
  };
  var IfcDiscreteAccessory = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDiscreteAccessoryType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDistanceExpression = class {
    constructor(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
      this.expressID = expressID;
      this.type = type;
      this.DistanceAlong = DistanceAlong;
      this.OffsetLateral = OffsetLateral;
      this.OffsetVertical = OffsetVertical;
      this.OffsetLongitudinal = OffsetLongitudinal;
      this.AlongHorizontal = AlongHorizontal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let DistanceAlong = tape[ptr++];
      let OffsetLateral = tape[ptr++];
      let OffsetVertical = tape[ptr++];
      let OffsetLongitudinal = tape[ptr++];
      let AlongHorizontal = tape[ptr++];
      return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
    }
    ToTape() {
      let args = [];
      args.push(this.DistanceAlong);
      args.push(this.OffsetLateral);
      args.push(this.OffsetVertical);
      args.push(this.OffsetLongitudinal);
      args.push(this.AlongHorizontal);
      return args;
    }
  };
  var IfcDistributionChamberElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDistributionChamberElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDistributionCircuit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.LongName);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDistributionControlElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcDistributionControlElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcDistributionElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcDistributionElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcDistributionFlowElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcDistributionFlowElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcDistributionPort = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.FlowDirection = FlowDirection;
      this.PredefinedType = PredefinedType;
      this.SystemType = SystemType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let FlowDirection = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let SystemType = tape[ptr++];
      return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.FlowDirection);
      args.push(this.PredefinedType);
      args.push(this.SystemType);
      return args;
    }
  };
  var IfcDistributionSystem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.LongName);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDocumentInformation = class {
    constructor(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
      this.expressID = expressID;
      this.type = type;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.Location = Location;
      this.Purpose = Purpose;
      this.IntendedUse = IntendedUse;
      this.Scope = Scope;
      this.Revision = Revision;
      this.DocumentOwner = DocumentOwner;
      this.Editors = Editors;
      this.CreationTime = CreationTime;
      this.LastRevisionTime = LastRevisionTime;
      this.ElectronicFormat = ElectronicFormat;
      this.ValidFrom = ValidFrom;
      this.ValidUntil = ValidUntil;
      this.Confidentiality = Confidentiality;
      this.Status = Status;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Location = tape[ptr++];
      let Purpose = tape[ptr++];
      let IntendedUse = tape[ptr++];
      let Scope = tape[ptr++];
      let Revision = tape[ptr++];
      let DocumentOwner = tape[ptr++];
      let Editors = tape[ptr++];
      let CreationTime = tape[ptr++];
      let LastRevisionTime = tape[ptr++];
      let ElectronicFormat = tape[ptr++];
      let ValidFrom = tape[ptr++];
      let ValidUntil = tape[ptr++];
      let Confidentiality = tape[ptr++];
      let Status = tape[ptr++];
      return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
    }
    ToTape() {
      let args = [];
      args.push(this.Identification);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Location);
      args.push(this.Purpose);
      args.push(this.IntendedUse);
      args.push(this.Scope);
      args.push(this.Revision);
      args.push(this.DocumentOwner);
      args.push(this.Editors);
      args.push(this.CreationTime);
      args.push(this.LastRevisionTime);
      args.push(this.ElectronicFormat);
      args.push(this.ValidFrom);
      args.push(this.ValidUntil);
      args.push(this.Confidentiality);
      args.push(this.Status);
      return args;
    }
  };
  var IfcDocumentInformationRelationship = class {
    constructor(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingDocument = RelatingDocument;
      this.RelatedDocuments = RelatedDocuments;
      this.RelationshipType = RelationshipType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingDocument = tape[ptr++];
      let RelatedDocuments = tape[ptr++];
      let RelationshipType = tape[ptr++];
      return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingDocument);
      args.push(this.RelatedDocuments);
      args.push(this.RelationshipType);
      return args;
    }
  };
  var IfcDocumentReference = class {
    constructor(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.ReferencedDocument = ReferencedDocument;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ReferencedDocument = tape[ptr++];
      return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ReferencedDocument);
      return args;
    }
  };
  var IfcDoor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.OperationType = OperationType;
      this.UserDefinedOperationType = UserDefinedOperationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OperationType = tape[ptr++];
      let UserDefinedOperationType = tape[ptr++];
      return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.OverallHeight);
      args.push(this.OverallWidth);
      args.push(this.PredefinedType);
      args.push(this.OperationType);
      args.push(this.UserDefinedOperationType);
      return args;
    }
  };
  var IfcDoorLiningProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.LiningDepth = LiningDepth;
      this.LiningThickness = LiningThickness;
      this.ThresholdDepth = ThresholdDepth;
      this.ThresholdThickness = ThresholdThickness;
      this.TransomThickness = TransomThickness;
      this.TransomOffset = TransomOffset;
      this.LiningOffset = LiningOffset;
      this.ThresholdOffset = ThresholdOffset;
      this.CasingThickness = CasingThickness;
      this.CasingDepth = CasingDepth;
      this.ShapeAspectStyle = ShapeAspectStyle;
      this.LiningToPanelOffsetX = LiningToPanelOffsetX;
      this.LiningToPanelOffsetY = LiningToPanelOffsetY;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let LiningDepth = tape[ptr++];
      let LiningThickness = tape[ptr++];
      let ThresholdDepth = tape[ptr++];
      let ThresholdThickness = tape[ptr++];
      let TransomThickness = tape[ptr++];
      let TransomOffset = tape[ptr++];
      let LiningOffset = tape[ptr++];
      let ThresholdOffset = tape[ptr++];
      let CasingThickness = tape[ptr++];
      let CasingDepth = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      let LiningToPanelOffsetX = tape[ptr++];
      let LiningToPanelOffsetY = tape[ptr++];
      return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.LiningDepth);
      args.push(this.LiningThickness);
      args.push(this.ThresholdDepth);
      args.push(this.ThresholdThickness);
      args.push(this.TransomThickness);
      args.push(this.TransomOffset);
      args.push(this.LiningOffset);
      args.push(this.ThresholdOffset);
      args.push(this.CasingThickness);
      args.push(this.CasingDepth);
      args.push(this.ShapeAspectStyle);
      args.push(this.LiningToPanelOffsetX);
      args.push(this.LiningToPanelOffsetY);
      return args;
    }
  };
  var IfcDoorPanelProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.PanelDepth = PanelDepth;
      this.PanelOperation = PanelOperation;
      this.PanelWidth = PanelWidth;
      this.PanelPosition = PanelPosition;
      this.ShapeAspectStyle = ShapeAspectStyle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let PanelDepth = tape[ptr++];
      let PanelOperation = tape[ptr++];
      let PanelWidth = tape[ptr++];
      let PanelPosition = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.PanelDepth);
      args.push(this.PanelOperation);
      args.push(this.PanelWidth);
      args.push(this.PanelPosition);
      args.push(this.ShapeAspectStyle);
      return args;
    }
  };
  var IfcDoorStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.OperationType = OperationType;
      this.UserDefinedOperationType = UserDefinedOperationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OperationType = tape[ptr++];
      let UserDefinedOperationType = tape[ptr++];
      return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.OverallHeight);
      args.push(this.OverallWidth);
      args.push(this.PredefinedType);
      args.push(this.OperationType);
      args.push(this.UserDefinedOperationType);
      return args;
    }
  };
  var IfcDoorStyle = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.OperationType = OperationType;
      this.ConstructionType = ConstructionType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.Sizeable = Sizeable;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let OperationType = tape[ptr++];
      let ConstructionType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let Sizeable = tape[ptr++];
      return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.OperationType);
      args.push(this.ConstructionType);
      args.push(this.ParameterTakesPrecedence);
      args.push(this.Sizeable);
      return args;
    }
  };
  var IfcDoorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.OperationType = OperationType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.UserDefinedOperationType = UserDefinedOperationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OperationType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let UserDefinedOperationType = tape[ptr++];
      return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.OperationType);
      args.push(this.ParameterTakesPrecedence);
      args.push(this.UserDefinedOperationType);
      return args;
    }
  };
  var IfcDraughtingPreDefinedColour = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcDraughtingPreDefinedColour(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcDraughtingPreDefinedCurveFont = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcDuctFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDuctFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDuctSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDuctSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDuctSilencer = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcDuctSilencerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEdge = class {
    constructor(expressID, type, EdgeStart, EdgeEnd) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      return new IfcEdge(expressID, type, EdgeStart, EdgeEnd);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      args.push(this.EdgeEnd);
      return args;
    }
  };
  var IfcEdgeCurve = class {
    constructor(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
      this.EdgeGeometry = EdgeGeometry;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      let EdgeGeometry = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      args.push(this.EdgeEnd);
      args.push(this.EdgeGeometry);
      args.push(this.SameSense);
      return args;
    }
  };
  var IfcEdgeLoop = class {
    constructor(expressID, type, EdgeList) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeList = EdgeList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeList = tape[ptr++];
      return new IfcEdgeLoop(expressID, type, EdgeList);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeList);
      return args;
    }
  };
  var IfcElectricAppliance = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricApplianceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricDistributionBoard = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricDistributionBoardType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricFlowStorageDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricFlowStorageDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricGenerator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricGeneratorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricMotor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricMotorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricTimeControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElectricTimeControlType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcElementAssembly = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.AssemblyPlace = AssemblyPlace;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let AssemblyPlace = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.AssemblyPlace);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElementAssemblyType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcElementComponent = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcElementComponentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcElementQuantity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.MethodOfMeasurement = MethodOfMeasurement;
      this.Quantities = Quantities;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let MethodOfMeasurement = tape[ptr++];
      let Quantities = tape[ptr++];
      return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.MethodOfMeasurement);
      args.push(this.Quantities);
      return args;
    }
  };
  var IfcElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcElementarySurface = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcElementarySurface(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      return args;
    }
  };
  var IfcEllipse = class {
    constructor(expressID, type, Position, SemiAxis1, SemiAxis2) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.SemiAxis1 = SemiAxis1;
      this.SemiAxis2 = SemiAxis2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let SemiAxis1 = tape[ptr++];
      let SemiAxis2 = tape[ptr++];
      return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.SemiAxis1);
      args.push(this.SemiAxis2);
      return args;
    }
  };
  var IfcEllipseProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.SemiAxis1 = SemiAxis1;
      this.SemiAxis2 = SemiAxis2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let SemiAxis1 = tape[ptr++];
      let SemiAxis2 = tape[ptr++];
      return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.SemiAxis1);
      args.push(this.SemiAxis2);
      return args;
    }
  };
  var IfcEnergyConversionDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcEnergyConversionDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcEngine = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEngineType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEvaporativeCooler = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEvaporativeCoolerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEvaporator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEvaporatorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcEvent = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.PredefinedType = PredefinedType;
      this.EventTriggerType = EventTriggerType;
      this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
      this.EventOccurenceTime = EventOccurenceTime;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let EventTriggerType = tape[ptr++];
      let UserDefinedEventTriggerType = tape[ptr++];
      let EventOccurenceTime = tape[ptr++];
      return new IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.PredefinedType);
      args.push(this.EventTriggerType);
      args.push(this.UserDefinedEventTriggerType);
      args.push(this.EventOccurenceTime);
      return args;
    }
  };
  var IfcEventTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.ActualDate = ActualDate;
      this.EarlyDate = EarlyDate;
      this.LateDate = LateDate;
      this.ScheduleDate = ScheduleDate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let ActualDate = tape[ptr++];
      let EarlyDate = tape[ptr++];
      let LateDate = tape[ptr++];
      let ScheduleDate = tape[ptr++];
      return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.ActualDate);
      args.push(this.EarlyDate);
      args.push(this.LateDate);
      args.push(this.ScheduleDate);
      return args;
    }
  };
  var IfcEventType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
      this.PredefinedType = PredefinedType;
      this.EventTriggerType = EventTriggerType;
      this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let EventTriggerType = tape[ptr++];
      let UserDefinedEventTriggerType = tape[ptr++];
      return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ProcessType);
      args.push(this.PredefinedType);
      args.push(this.EventTriggerType);
      args.push(this.UserDefinedEventTriggerType);
      return args;
    }
  };
  var IfcExtendedProperties = class {
    constructor(expressID, type, Name, Description, Properties2) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Properties = Properties2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Properties2 = tape[ptr++];
      return new IfcExtendedProperties(expressID, type, Name, Description, Properties2);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Properties);
      return args;
    }
  };
  var IfcExternalInformation = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcExternalInformation(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcExternalReference = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternalReference(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      return args;
    }
  };
  var IfcExternalReferenceRelationship = class {
    constructor(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingReference = RelatingReference;
      this.RelatedResourceObjects = RelatedResourceObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingReference = tape[ptr++];
      let RelatedResourceObjects = tape[ptr++];
      return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingReference);
      args.push(this.RelatedResourceObjects);
      return args;
    }
  };
  var IfcExternalSpatialElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcExternalSpatialStructureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      return args;
    }
  };
  var IfcExternallyDefinedHatchStyle = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      return args;
    }
  };
  var IfcExternallyDefinedSurfaceStyle = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      return args;
    }
  };
  var IfcExternallyDefinedTextFont = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      return args;
    }
  };
  var IfcExtrudedAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.ExtrudedDirection = ExtrudedDirection;
      this.Depth = Depth;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let ExtrudedDirection = tape[ptr++];
      let Depth = tape[ptr++];
      return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      args.push(this.ExtrudedDirection);
      args.push(this.Depth);
      return args;
    }
  };
  var IfcExtrudedAreaSolidTapered = class {
    constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.ExtrudedDirection = ExtrudedDirection;
      this.Depth = Depth;
      this.EndSweptArea = EndSweptArea;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let ExtrudedDirection = tape[ptr++];
      let Depth = tape[ptr++];
      let EndSweptArea = tape[ptr++];
      return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      args.push(this.ExtrudedDirection);
      args.push(this.Depth);
      args.push(this.EndSweptArea);
      return args;
    }
  };
  var IfcFace = class {
    constructor(expressID, type, Bounds) {
      this.expressID = expressID;
      this.type = type;
      this.Bounds = Bounds;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bounds = tape[ptr++];
      return new IfcFace(expressID, type, Bounds);
    }
    ToTape() {
      let args = [];
      args.push(this.Bounds);
      return args;
    }
  };
  var IfcFaceBasedSurfaceModel = class {
    constructor(expressID, type, FbsmFaces) {
      this.expressID = expressID;
      this.type = type;
      this.FbsmFaces = FbsmFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let FbsmFaces = tape[ptr++];
      return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.FbsmFaces);
      return args;
    }
  };
  var IfcFaceBound = class {
    constructor(expressID, type, Bound, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.Bound = Bound;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bound = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcFaceBound(expressID, type, Bound, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.Bound);
      args.push(this.Orientation);
      return args;
    }
  };
  var IfcFaceOuterBound = class {
    constructor(expressID, type, Bound, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.Bound = Bound;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bound = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcFaceOuterBound(expressID, type, Bound, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.Bound);
      args.push(this.Orientation);
      return args;
    }
  };
  var IfcFaceSurface = class {
    constructor(expressID, type, Bounds, FaceSurface, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.Bounds = Bounds;
      this.FaceSurface = FaceSurface;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bounds = tape[ptr++];
      let FaceSurface = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.Bounds);
      args.push(this.FaceSurface);
      args.push(this.SameSense);
      return args;
    }
  };
  var IfcFacetedBrep = class {
    constructor(expressID, type, Outer) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      return new IfcFacetedBrep(expressID, type, Outer);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      return args;
    }
  };
  var IfcFacetedBrepWithVoids = class {
    constructor(expressID, type, Outer, Voids) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
      this.Voids = Voids;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      let Voids = tape[ptr++];
      return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      args.push(this.Voids);
      return args;
    }
  };
  var IfcFacility = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      return args;
    }
  };
  var IfcFacilityPart = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      return args;
    }
  };
  var IfcFailureConnectionCondition = class {
    constructor(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TensionFailureX = TensionFailureX;
      this.TensionFailureY = TensionFailureY;
      this.TensionFailureZ = TensionFailureZ;
      this.CompressionFailureX = CompressionFailureX;
      this.CompressionFailureY = CompressionFailureY;
      this.CompressionFailureZ = CompressionFailureZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TensionFailureX = tape[ptr++];
      let TensionFailureY = tape[ptr++];
      let TensionFailureZ = tape[ptr++];
      let CompressionFailureX = tape[ptr++];
      let CompressionFailureY = tape[ptr++];
      let CompressionFailureZ = tape[ptr++];
      return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.TensionFailureX);
      args.push(this.TensionFailureY);
      args.push(this.TensionFailureZ);
      args.push(this.CompressionFailureX);
      args.push(this.CompressionFailureY);
      args.push(this.CompressionFailureZ);
      return args;
    }
  };
  var IfcFan = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFanType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFastener = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFastenerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFeatureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFeatureElementAddition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFeatureElementSubtraction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFillAreaStyle = class {
    constructor(expressID, type, Name, FillStyles, ModelorDraughting) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.FillStyles = FillStyles;
      this.ModelorDraughting = ModelorDraughting;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let FillStyles = tape[ptr++];
      let ModelorDraughting = tape[ptr++];
      return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.FillStyles);
      args.push(this.ModelorDraughting);
      return args;
    }
  };
  var IfcFillAreaStyleHatching = class {
    constructor(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
      this.expressID = expressID;
      this.type = type;
      this.HatchLineAppearance = HatchLineAppearance;
      this.StartOfNextHatchLine = StartOfNextHatchLine;
      this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
      this.PatternStart = PatternStart;
      this.HatchLineAngle = HatchLineAngle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let HatchLineAppearance = tape[ptr++];
      let StartOfNextHatchLine = tape[ptr++];
      let PointOfReferenceHatchLine = tape[ptr++];
      let PatternStart = tape[ptr++];
      let HatchLineAngle = tape[ptr++];
      return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
    }
    ToTape() {
      let args = [];
      args.push(this.HatchLineAppearance);
      args.push(this.StartOfNextHatchLine);
      args.push(this.PointOfReferenceHatchLine);
      args.push(this.PatternStart);
      args.push(this.HatchLineAngle);
      return args;
    }
  };
  var IfcFillAreaStyleTiles = class {
    constructor(expressID, type, TilingPattern, Tiles, TilingScale) {
      this.expressID = expressID;
      this.type = type;
      this.TilingPattern = TilingPattern;
      this.Tiles = Tiles;
      this.TilingScale = TilingScale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TilingPattern = tape[ptr++];
      let Tiles = tape[ptr++];
      let TilingScale = tape[ptr++];
      return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale);
    }
    ToTape() {
      let args = [];
      args.push(this.TilingPattern);
      args.push(this.Tiles);
      args.push(this.TilingScale);
      return args;
    }
  };
  var IfcFilter = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFilterType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFireSuppressionTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFireSuppressionTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFixedReferenceSweptAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Directrix = Directrix;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
      this.FixedReference = FixedReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Directrix = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      let FixedReference = tape[ptr++];
      return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      args.push(this.Directrix);
      args.push(this.StartParam);
      args.push(this.EndParam);
      args.push(this.FixedReference);
      return args;
    }
  };
  var IfcFlowController = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowControllerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFlowFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFlowInstrument = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFlowInstrumentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFlowMeter = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFlowMeterType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFlowMovingDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowMovingDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFlowSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFlowStorageDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowStorageDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFlowTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFlowTreatmentDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFlowTreatmentDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFooting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFootingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFurnishingElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcFurnishingElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcFurniture = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcFurnitureType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.AssemblyPlace = AssemblyPlace;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let AssemblyPlace = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.AssemblyPlace);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcGeographicElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcGeographicElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcGeometricCurveSet = class {
    constructor(expressID, type, Elements) {
      this.expressID = expressID;
      this.type = type;
      this.Elements = Elements;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Elements = tape[ptr++];
      return new IfcGeometricCurveSet(expressID, type, Elements);
    }
    ToTape() {
      let args = [];
      args.push(this.Elements);
      return args;
    }
  };
  var IfcGeometricRepresentationContext = class {
    constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
      this.expressID = expressID;
      this.type = type;
      this.ContextIdentifier = ContextIdentifier;
      this.ContextType = ContextType;
      this.CoordinateSpaceDimension = CoordinateSpaceDimension;
      this.Precision = Precision;
      this.WorldCoordinateSystem = WorldCoordinateSystem;
      this.TrueNorth = TrueNorth;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextIdentifier = tape[ptr++];
      let ContextType = tape[ptr++];
      let CoordinateSpaceDimension = tape[ptr++];
      let Precision = tape[ptr++];
      let WorldCoordinateSystem = tape[ptr++];
      let TrueNorth = tape[ptr++];
      return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextIdentifier);
      args.push(this.ContextType);
      args.push(this.CoordinateSpaceDimension);
      args.push(this.Precision);
      args.push(this.WorldCoordinateSystem);
      args.push(this.TrueNorth);
      return args;
    }
  };
  var IfcGeometricRepresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcGeometricRepresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcGeometricRepresentationSubContext = class {
    constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
      this.expressID = expressID;
      this.type = type;
      this.ContextIdentifier = ContextIdentifier;
      this.ContextType = ContextType;
      this.CoordinateSpaceDimension = CoordinateSpaceDimension;
      this.Precision = Precision;
      this.WorldCoordinateSystem = WorldCoordinateSystem;
      this.TrueNorth = TrueNorth;
      this.ParentContext = ParentContext;
      this.TargetScale = TargetScale;
      this.TargetView = TargetView;
      this.UserDefinedTargetView = UserDefinedTargetView;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextIdentifier = tape[ptr++];
      let ContextType = tape[ptr++];
      let CoordinateSpaceDimension = tape[ptr++];
      let Precision = tape[ptr++];
      let WorldCoordinateSystem = tape[ptr++];
      let TrueNorth = tape[ptr++];
      let ParentContext = tape[ptr++];
      let TargetScale = tape[ptr++];
      let TargetView = tape[ptr++];
      let UserDefinedTargetView = tape[ptr++];
      return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextIdentifier);
      args.push(this.ContextType);
      args.push(this.CoordinateSpaceDimension);
      args.push(this.Precision);
      args.push(this.WorldCoordinateSystem);
      args.push(this.TrueNorth);
      args.push(this.ParentContext);
      args.push(this.TargetScale);
      args.push(this.TargetView);
      args.push(this.UserDefinedTargetView);
      return args;
    }
  };
  var IfcGeometricSet = class {
    constructor(expressID, type, Elements) {
      this.expressID = expressID;
      this.type = type;
      this.Elements = Elements;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Elements = tape[ptr++];
      return new IfcGeometricSet(expressID, type, Elements);
    }
    ToTape() {
      let args = [];
      args.push(this.Elements);
      return args;
    }
  };
  var IfcGrid = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.UAxes = UAxes;
      this.VAxes = VAxes;
      this.WAxes = WAxes;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let UAxes = tape[ptr++];
      let VAxes = tape[ptr++];
      let WAxes = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.UAxes);
      args.push(this.VAxes);
      args.push(this.WAxes);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcGridAxis = class {
    constructor(expressID, type, AxisTag, AxisCurve, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.AxisTag = AxisTag;
      this.AxisCurve = AxisCurve;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let AxisTag = tape[ptr++];
      let AxisCurve = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.AxisTag);
      args.push(this.AxisCurve);
      args.push(this.SameSense);
      return args;
    }
  };
  var IfcGridPlacement = class {
    constructor(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
      this.PlacementLocation = PlacementLocation;
      this.PlacementRefDirection = PlacementRefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      let PlacementLocation = tape[ptr++];
      let PlacementRefDirection = tape[ptr++];
      return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      args.push(this.PlacementLocation);
      args.push(this.PlacementRefDirection);
      return args;
    }
  };
  var IfcGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      return args;
    }
  };
  var IfcHalfSpaceSolid = class {
    constructor(expressID, type, BaseSurface, AgreementFlag) {
      this.expressID = expressID;
      this.type = type;
      this.BaseSurface = BaseSurface;
      this.AgreementFlag = AgreementFlag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BaseSurface = tape[ptr++];
      let AgreementFlag = tape[ptr++];
      return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag);
    }
    ToTape() {
      let args = [];
      args.push(this.BaseSurface);
      args.push(this.AgreementFlag);
      return args;
    }
  };
  var IfcHeatExchanger = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcHeatExchangerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcHumidifier = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcHumidifierType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcIShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.OverallWidth = OverallWidth;
      this.OverallDepth = OverallDepth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.FlangeEdgeRadius = FlangeEdgeRadius;
      this.FlangeSlope = FlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let OverallDepth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let FlangeEdgeRadius = tape[ptr++];
      let FlangeSlope = tape[ptr++];
      return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.OverallWidth);
      args.push(this.OverallDepth);
      args.push(this.WebThickness);
      args.push(this.FlangeThickness);
      args.push(this.FilletRadius);
      args.push(this.FlangeEdgeRadius);
      args.push(this.FlangeSlope);
      return args;
    }
  };
  var IfcImageTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
      this.URLReference = URLReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      let URLReference = tape[ptr++];
      return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      args.push(this.RepeatT);
      args.push(this.Mode);
      args.push(this.TextureTransform);
      args.push(this.Parameter);
      args.push(this.URLReference);
      return args;
    }
  };
  var IfcIndexedColourMap = class {
    constructor(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
      this.expressID = expressID;
      this.type = type;
      this.MappedTo = MappedTo;
      this.Opacity = Opacity;
      this.Colours = Colours;
      this.ColourIndex = ColourIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MappedTo = tape[ptr++];
      let Opacity = tape[ptr++];
      let Colours = tape[ptr++];
      let ColourIndex = tape[ptr++];
      return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.MappedTo);
      args.push(this.Opacity);
      args.push(this.Colours);
      args.push(this.ColourIndex);
      return args;
    }
  };
  var IfcIndexedPolyCurve = class {
    constructor(expressID, type, Points, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Points = Points;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Points = tape[ptr++];
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Points);
      args.push(this.Segments);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcIndexedPolygonalFace = class {
    constructor(expressID, type, CoordIndex) {
      this.expressID = expressID;
      this.type = type;
      this.CoordIndex = CoordIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordIndex = tape[ptr++];
      return new IfcIndexedPolygonalFace(expressID, type, CoordIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordIndex);
      return args;
    }
  };
  var IfcIndexedPolygonalFaceWithVoids = class {
    constructor(expressID, type, CoordIndex, InnerCoordIndices) {
      this.expressID = expressID;
      this.type = type;
      this.CoordIndex = CoordIndex;
      this.InnerCoordIndices = InnerCoordIndices;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordIndex = tape[ptr++];
      let InnerCoordIndices = tape[ptr++];
      return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordIndex);
      args.push(this.InnerCoordIndices);
      return args;
    }
  };
  var IfcIndexedTextureMap = class {
    constructor(expressID, type, Maps, MappedTo, TexCoords) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.MappedTo = MappedTo;
      this.TexCoords = TexCoords;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let MappedTo = tape[ptr++];
      let TexCoords = tape[ptr++];
      return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      args.push(this.MappedTo);
      args.push(this.TexCoords);
      return args;
    }
  };
  var IfcIndexedTriangleTextureMap = class {
    constructor(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.MappedTo = MappedTo;
      this.TexCoords = TexCoords;
      this.TexCoordIndex = TexCoordIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let MappedTo = tape[ptr++];
      let TexCoords = tape[ptr++];
      let TexCoordIndex = tape[ptr++];
      return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      args.push(this.MappedTo);
      args.push(this.TexCoords);
      args.push(this.TexCoordIndex);
      return args;
    }
  };
  var IfcInterceptor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcInterceptorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcIntersectionCurve = class {
    constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.Curve3D = Curve3D;
      this.AssociatedGeometry = AssociatedGeometry;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Curve3D = tape[ptr++];
      let AssociatedGeometry = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.Curve3D);
      args.push(this.AssociatedGeometry);
      args.push(this.MasterRepresentation);
      return args;
    }
  };
  var IfcInventory = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.Jurisdiction = Jurisdiction;
      this.ResponsiblePersons = ResponsiblePersons;
      this.LastUpdateDate = LastUpdateDate;
      this.CurrentValue = CurrentValue;
      this.OriginalValue = OriginalValue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Jurisdiction = tape[ptr++];
      let ResponsiblePersons = tape[ptr++];
      let LastUpdateDate = tape[ptr++];
      let CurrentValue = tape[ptr++];
      let OriginalValue = tape[ptr++];
      return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.PredefinedType);
      args.push(this.Jurisdiction);
      args.push(this.ResponsiblePersons);
      args.push(this.LastUpdateDate);
      args.push(this.CurrentValue);
      args.push(this.OriginalValue);
      return args;
    }
  };
  var IfcIrregularTimeSeries = class {
    constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
      this.TimeSeriesDataType = TimeSeriesDataType;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.Unit = Unit;
      this.Values = Values;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      let TimeSeriesDataType = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let Unit = tape[ptr++];
      let Values = tape[ptr++];
      return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.StartTime);
      args.push(this.EndTime);
      args.push(this.TimeSeriesDataType);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.Unit);
      args.push(this.Values);
      return args;
    }
  };
  var IfcIrregularTimeSeriesValue = class {
    constructor(expressID, type, TimeStamp, ListValues) {
      this.expressID = expressID;
      this.type = type;
      this.TimeStamp = TimeStamp;
      this.ListValues = ListValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TimeStamp = tape[ptr++];
      let ListValues = tape[ptr++];
      return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues);
    }
    ToTape() {
      let args = [];
      args.push(this.TimeStamp);
      args.push(this.ListValues);
      return args;
    }
  };
  var IfcJunctionBox = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcJunctionBoxType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.Width = Width;
      this.Thickness = Thickness;
      this.FilletRadius = FilletRadius;
      this.EdgeRadius = EdgeRadius;
      this.LegSlope = LegSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let Width = tape[ptr++];
      let Thickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let EdgeRadius = tape[ptr++];
      let LegSlope = tape[ptr++];
      return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Depth);
      args.push(this.Width);
      args.push(this.Thickness);
      args.push(this.FilletRadius);
      args.push(this.EdgeRadius);
      args.push(this.LegSlope);
      return args;
    }
  };
  var IfcLaborResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLaborResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLagTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.LagValue = LagValue;
      this.DurationType = DurationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let LagValue = tape[ptr++];
      let DurationType = tape[ptr++];
      return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.LagValue);
      args.push(this.DurationType);
      return args;
    }
  };
  var IfcLamp = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLampType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLibraryInformation = class {
    constructor(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Version = Version;
      this.Publisher = Publisher;
      this.VersionDate = VersionDate;
      this.Location = Location;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Version = tape[ptr++];
      let Publisher = tape[ptr++];
      let VersionDate = tape[ptr++];
      let Location = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Version);
      args.push(this.Publisher);
      args.push(this.VersionDate);
      args.push(this.Location);
      args.push(this.Description);
      return args;
    }
  };
  var IfcLibraryReference = class {
    constructor(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.Language = Language;
      this.ReferencedLibrary = ReferencedLibrary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Language = tape[ptr++];
      let ReferencedLibrary = tape[ptr++];
      return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      args.push(this.Identification);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Language);
      args.push(this.ReferencedLibrary);
      return args;
    }
  };
  var IfcLightDistributionData = class {
    constructor(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
      this.expressID = expressID;
      this.type = type;
      this.MainPlaneAngle = MainPlaneAngle;
      this.SecondaryPlaneAngle = SecondaryPlaneAngle;
      this.LuminousIntensity = LuminousIntensity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MainPlaneAngle = tape[ptr++];
      let SecondaryPlaneAngle = tape[ptr++];
      let LuminousIntensity = tape[ptr++];
      return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
    }
    ToTape() {
      let args = [];
      args.push(this.MainPlaneAngle);
      args.push(this.SecondaryPlaneAngle);
      args.push(this.LuminousIntensity);
      return args;
    }
  };
  var IfcLightFixture = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLightFixtureType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcLightIntensityDistribution = class {
    constructor(expressID, type, LightDistributionCurve, DistributionData) {
      this.expressID = expressID;
      this.type = type;
      this.LightDistributionCurve = LightDistributionCurve;
      this.DistributionData = DistributionData;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LightDistributionCurve = tape[ptr++];
      let DistributionData = tape[ptr++];
      return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData);
    }
    ToTape() {
      let args = [];
      args.push(this.LightDistributionCurve);
      args.push(this.DistributionData);
      return args;
    }
  };
  var IfcLightSource = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LightColour);
      args.push(this.AmbientIntensity);
      args.push(this.Intensity);
      return args;
    }
  };
  var IfcLightSourceAmbient = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LightColour);
      args.push(this.AmbientIntensity);
      args.push(this.Intensity);
      return args;
    }
  };
  var IfcLightSourceDirectional = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LightColour);
      args.push(this.AmbientIntensity);
      args.push(this.Intensity);
      args.push(this.Orientation);
      return args;
    }
  };
  var IfcLightSourceGoniometric = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Position = Position;
      this.ColourAppearance = ColourAppearance;
      this.ColourTemperature = ColourTemperature;
      this.LuminousFlux = LuminousFlux;
      this.LightEmissionSource = LightEmissionSource;
      this.LightDistributionDataSource = LightDistributionDataSource;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Position = tape[ptr++];
      let ColourAppearance = tape[ptr++];
      let ColourTemperature = tape[ptr++];
      let LuminousFlux = tape[ptr++];
      let LightEmissionSource = tape[ptr++];
      let LightDistributionDataSource = tape[ptr++];
      return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LightColour);
      args.push(this.AmbientIntensity);
      args.push(this.Intensity);
      args.push(this.Position);
      args.push(this.ColourAppearance);
      args.push(this.ColourTemperature);
      args.push(this.LuminousFlux);
      args.push(this.LightEmissionSource);
      args.push(this.LightDistributionDataSource);
      return args;
    }
  };
  var IfcLightSourcePositional = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Position = Position;
      this.Radius = Radius;
      this.ConstantAttenuation = ConstantAttenuation;
      this.DistanceAttenuation = DistanceAttenuation;
      this.QuadricAttenuation = QuadricAttenuation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      let ConstantAttenuation = tape[ptr++];
      let DistanceAttenuation = tape[ptr++];
      let QuadricAttenuation = tape[ptr++];
      return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LightColour);
      args.push(this.AmbientIntensity);
      args.push(this.Intensity);
      args.push(this.Position);
      args.push(this.Radius);
      args.push(this.ConstantAttenuation);
      args.push(this.DistanceAttenuation);
      args.push(this.QuadricAttenuation);
      return args;
    }
  };
  var IfcLightSourceSpot = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Position = Position;
      this.Radius = Radius;
      this.ConstantAttenuation = ConstantAttenuation;
      this.DistanceAttenuation = DistanceAttenuation;
      this.QuadricAttenuation = QuadricAttenuation;
      this.Orientation = Orientation;
      this.ConcentrationExponent = ConcentrationExponent;
      this.SpreadAngle = SpreadAngle;
      this.BeamWidthAngle = BeamWidthAngle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      let ConstantAttenuation = tape[ptr++];
      let DistanceAttenuation = tape[ptr++];
      let QuadricAttenuation = tape[ptr++];
      let Orientation = tape[ptr++];
      let ConcentrationExponent = tape[ptr++];
      let SpreadAngle = tape[ptr++];
      let BeamWidthAngle = tape[ptr++];
      return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LightColour);
      args.push(this.AmbientIntensity);
      args.push(this.Intensity);
      args.push(this.Position);
      args.push(this.Radius);
      args.push(this.ConstantAttenuation);
      args.push(this.DistanceAttenuation);
      args.push(this.QuadricAttenuation);
      args.push(this.Orientation);
      args.push(this.ConcentrationExponent);
      args.push(this.SpreadAngle);
      args.push(this.BeamWidthAngle);
      return args;
    }
  };
  var IfcLine = class {
    constructor(expressID, type, Pnt, Dir) {
      this.expressID = expressID;
      this.type = type;
      this.Pnt = Pnt;
      this.Dir = Dir;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Pnt = tape[ptr++];
      let Dir = tape[ptr++];
      return new IfcLine(expressID, type, Pnt, Dir);
    }
    ToTape() {
      let args = [];
      args.push(this.Pnt);
      args.push(this.Dir);
      return args;
    }
  };
  var IfcLineSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      args.push(this.StartDirection);
      args.push(this.SegmentLength);
      return args;
    }
  };
  var IfcLinearPlacement = class {
    constructor(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
      this.PlacementMeasuredAlong = PlacementMeasuredAlong;
      this.Distance = Distance;
      this.Orientation = Orientation;
      this.CartesianPosition = CartesianPosition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      let PlacementMeasuredAlong = tape[ptr++];
      let Distance = tape[ptr++];
      let Orientation = tape[ptr++];
      let CartesianPosition = tape[ptr++];
      return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      args.push(this.PlacementMeasuredAlong);
      args.push(this.Distance);
      args.push(this.Orientation);
      args.push(this.CartesianPosition);
      return args;
    }
  };
  var IfcLinearPositioningElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Axis);
      return args;
    }
  };
  var IfcLocalPlacement = class {
    constructor(expressID, type, PlacementRelTo, RelativePlacement) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
      this.RelativePlacement = RelativePlacement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      let RelativePlacement = tape[ptr++];
      return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      args.push(this.RelativePlacement);
      return args;
    }
  };
  var IfcLoop = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcLoop(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcManifoldSolidBrep = class {
    constructor(expressID, type, Outer) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      return new IfcManifoldSolidBrep(expressID, type, Outer);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      return args;
    }
  };
  var IfcMapConversion = class {
    constructor(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
      this.expressID = expressID;
      this.type = type;
      this.SourceCRS = SourceCRS;
      this.TargetCRS = TargetCRS;
      this.Eastings = Eastings;
      this.Northings = Northings;
      this.OrthogonalHeight = OrthogonalHeight;
      this.XAxisAbscissa = XAxisAbscissa;
      this.XAxisOrdinate = XAxisOrdinate;
      this.Scale = Scale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SourceCRS = tape[ptr++];
      let TargetCRS = tape[ptr++];
      let Eastings = tape[ptr++];
      let Northings = tape[ptr++];
      let OrthogonalHeight = tape[ptr++];
      let XAxisAbscissa = tape[ptr++];
      let XAxisOrdinate = tape[ptr++];
      let Scale = tape[ptr++];
      return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
    }
    ToTape() {
      let args = [];
      args.push(this.SourceCRS);
      args.push(this.TargetCRS);
      args.push(this.Eastings);
      args.push(this.Northings);
      args.push(this.OrthogonalHeight);
      args.push(this.XAxisAbscissa);
      args.push(this.XAxisOrdinate);
      args.push(this.Scale);
      return args;
    }
  };
  var IfcMappedItem = class {
    constructor(expressID, type, MappingSource, MappingTarget) {
      this.expressID = expressID;
      this.type = type;
      this.MappingSource = MappingSource;
      this.MappingTarget = MappingTarget;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MappingSource = tape[ptr++];
      let MappingTarget = tape[ptr++];
      return new IfcMappedItem(expressID, type, MappingSource, MappingTarget);
    }
    ToTape() {
      let args = [];
      args.push(this.MappingSource);
      args.push(this.MappingTarget);
      return args;
    }
  };
  var IfcMaterial = class {
    constructor(expressID, type, Name, Description, Category) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Category = Category;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Category = tape[ptr++];
      return new IfcMaterial(expressID, type, Name, Description, Category);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Category);
      return args;
    }
  };
  var IfcMaterialClassificationRelationship = class {
    constructor(expressID, type, MaterialClassifications, ClassifiedMaterial) {
      this.expressID = expressID;
      this.type = type;
      this.MaterialClassifications = MaterialClassifications;
      this.ClassifiedMaterial = ClassifiedMaterial;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MaterialClassifications = tape[ptr++];
      let ClassifiedMaterial = tape[ptr++];
      return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial);
    }
    ToTape() {
      let args = [];
      args.push(this.MaterialClassifications);
      args.push(this.ClassifiedMaterial);
      return args;
    }
  };
  var IfcMaterialConstituent = class {
    constructor(expressID, type, Name, Description, Material, Fraction, Category) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Material = Material;
      this.Fraction = Fraction;
      this.Category = Category;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Material = tape[ptr++];
      let Fraction = tape[ptr++];
      let Category = tape[ptr++];
      return new IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Material);
      args.push(this.Fraction);
      args.push(this.Category);
      return args;
    }
  };
  var IfcMaterialConstituentSet = class {
    constructor(expressID, type, Name, Description, MaterialConstituents) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.MaterialConstituents = MaterialConstituents;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let MaterialConstituents = tape[ptr++];
      return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.MaterialConstituents);
      return args;
    }
  };
  var IfcMaterialDefinition = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcMaterialDefinition(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcMaterialDefinitionRepresentation = class {
    constructor(expressID, type, Name, Description, Representations, RepresentedMaterial) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Representations = Representations;
      this.RepresentedMaterial = RepresentedMaterial;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Representations = tape[ptr++];
      let RepresentedMaterial = tape[ptr++];
      return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Representations);
      args.push(this.RepresentedMaterial);
      return args;
    }
  };
  var IfcMaterialLayer = class {
    constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
      this.expressID = expressID;
      this.type = type;
      this.Material = Material;
      this.LayerThickness = LayerThickness;
      this.IsVentilated = IsVentilated;
      this.Name = Name;
      this.Description = Description;
      this.Category = Category;
      this.Priority = Priority;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Material = tape[ptr++];
      let LayerThickness = tape[ptr++];
      let IsVentilated = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Category = tape[ptr++];
      let Priority = tape[ptr++];
      return new IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority);
    }
    ToTape() {
      let args = [];
      args.push(this.Material);
      args.push(this.LayerThickness);
      args.push(this.IsVentilated);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Category);
      args.push(this.Priority);
      return args;
    }
  };
  var IfcMaterialLayerSet = class {
    constructor(expressID, type, MaterialLayers, LayerSetName, Description) {
      this.expressID = expressID;
      this.type = type;
      this.MaterialLayers = MaterialLayers;
      this.LayerSetName = LayerSetName;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MaterialLayers = tape[ptr++];
      let LayerSetName = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.MaterialLayers);
      args.push(this.LayerSetName);
      args.push(this.Description);
      return args;
    }
  };
  var IfcMaterialLayerSetUsage = class {
    constructor(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
      this.expressID = expressID;
      this.type = type;
      this.ForLayerSet = ForLayerSet;
      this.LayerSetDirection = LayerSetDirection;
      this.DirectionSense = DirectionSense;
      this.OffsetFromReferenceLine = OffsetFromReferenceLine;
      this.ReferenceExtent = ReferenceExtent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ForLayerSet = tape[ptr++];
      let LayerSetDirection = tape[ptr++];
      let DirectionSense = tape[ptr++];
      let OffsetFromReferenceLine = tape[ptr++];
      let ReferenceExtent = tape[ptr++];
      return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
    }
    ToTape() {
      let args = [];
      args.push(this.ForLayerSet);
      args.push(this.LayerSetDirection);
      args.push(this.DirectionSense);
      args.push(this.OffsetFromReferenceLine);
      args.push(this.ReferenceExtent);
      return args;
    }
  };
  var IfcMaterialLayerWithOffsets = class {
    constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
      this.expressID = expressID;
      this.type = type;
      this.Material = Material;
      this.LayerThickness = LayerThickness;
      this.IsVentilated = IsVentilated;
      this.Name = Name;
      this.Description = Description;
      this.Category = Category;
      this.Priority = Priority;
      this.OffsetDirection = OffsetDirection;
      this.OffsetValues = OffsetValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Material = tape[ptr++];
      let LayerThickness = tape[ptr++];
      let IsVentilated = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Category = tape[ptr++];
      let Priority = tape[ptr++];
      let OffsetDirection = tape[ptr++];
      let OffsetValues = tape[ptr++];
      return new IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
    }
    ToTape() {
      let args = [];
      args.push(this.Material);
      args.push(this.LayerThickness);
      args.push(this.IsVentilated);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Category);
      args.push(this.Priority);
      args.push(this.OffsetDirection);
      args.push(this.OffsetValues);
      return args;
    }
  };
  var IfcMaterialList = class {
    constructor(expressID, type, Materials) {
      this.expressID = expressID;
      this.type = type;
      this.Materials = Materials;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Materials = tape[ptr++];
      return new IfcMaterialList(expressID, type, Materials);
    }
    ToTape() {
      let args = [];
      args.push(this.Materials);
      return args;
    }
  };
  var IfcMaterialProfile = class {
    constructor(expressID, type, Name, Description, Material, Profile, Priority, Category) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Material = Material;
      this.Profile = Profile;
      this.Priority = Priority;
      this.Category = Category;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Material = tape[ptr++];
      let Profile = tape[ptr++];
      let Priority = tape[ptr++];
      let Category = tape[ptr++];
      return new IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Material);
      args.push(this.Profile);
      args.push(this.Priority);
      args.push(this.Category);
      return args;
    }
  };
  var IfcMaterialProfileSet = class {
    constructor(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.MaterialProfiles = MaterialProfiles;
      this.CompositeProfile = CompositeProfile;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let MaterialProfiles = tape[ptr++];
      let CompositeProfile = tape[ptr++];
      return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.MaterialProfiles);
      args.push(this.CompositeProfile);
      return args;
    }
  };
  var IfcMaterialProfileSetUsage = class {
    constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
      this.expressID = expressID;
      this.type = type;
      this.ForProfileSet = ForProfileSet;
      this.CardinalPoint = CardinalPoint;
      this.ReferenceExtent = ReferenceExtent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ForProfileSet = tape[ptr++];
      let CardinalPoint = tape[ptr++];
      let ReferenceExtent = tape[ptr++];
      return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent);
    }
    ToTape() {
      let args = [];
      args.push(this.ForProfileSet);
      args.push(this.CardinalPoint);
      args.push(this.ReferenceExtent);
      return args;
    }
  };
  var IfcMaterialProfileSetUsageTapering = class {
    constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
      this.expressID = expressID;
      this.type = type;
      this.ForProfileSet = ForProfileSet;
      this.CardinalPoint = CardinalPoint;
      this.ReferenceExtent = ReferenceExtent;
      this.ForProfileEndSet = ForProfileEndSet;
      this.CardinalEndPoint = CardinalEndPoint;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ForProfileSet = tape[ptr++];
      let CardinalPoint = tape[ptr++];
      let ReferenceExtent = tape[ptr++];
      let ForProfileEndSet = tape[ptr++];
      let CardinalEndPoint = tape[ptr++];
      return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
    }
    ToTape() {
      let args = [];
      args.push(this.ForProfileSet);
      args.push(this.CardinalPoint);
      args.push(this.ReferenceExtent);
      args.push(this.ForProfileEndSet);
      args.push(this.CardinalEndPoint);
      return args;
    }
  };
  var IfcMaterialProfileWithOffsets = class {
    constructor(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Material = Material;
      this.Profile = Profile;
      this.Priority = Priority;
      this.Category = Category;
      this.OffsetValues = OffsetValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Material = tape[ptr++];
      let Profile = tape[ptr++];
      let Priority = tape[ptr++];
      let Category = tape[ptr++];
      let OffsetValues = tape[ptr++];
      return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Material);
      args.push(this.Profile);
      args.push(this.Priority);
      args.push(this.Category);
      args.push(this.OffsetValues);
      return args;
    }
  };
  var IfcMaterialProperties = class {
    constructor(expressID, type, Name, Description, Properties2, Material) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Properties = Properties2;
      this.Material = Material;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Properties2 = tape[ptr++];
      let Material = tape[ptr++];
      return new IfcMaterialProperties(expressID, type, Name, Description, Properties2, Material);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Properties);
      args.push(this.Material);
      return args;
    }
  };
  var IfcMaterialRelationship = class {
    constructor(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingMaterial = RelatingMaterial;
      this.RelatedMaterials = RelatedMaterials;
      this.Expression = Expression;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingMaterial = tape[ptr++];
      let RelatedMaterials = tape[ptr++];
      let Expression = tape[ptr++];
      return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingMaterial);
      args.push(this.RelatedMaterials);
      args.push(this.Expression);
      return args;
    }
  };
  var IfcMaterialUsageDefinition = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcMaterialUsageDefinition(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcMeasureWithUnit = class {
    constructor(expressID, type, ValueComponent, UnitComponent) {
      this.expressID = expressID;
      this.type = type;
      this.ValueComponent = ValueComponent;
      this.UnitComponent = UnitComponent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ValueComponent = tape[ptr++];
      let UnitComponent = tape[ptr++];
      return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent);
    }
    ToTape() {
      let args = [];
      args.push(this.ValueComponent);
      args.push(this.UnitComponent);
      return args;
    }
  };
  var IfcMechanicalFastener = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.NominalDiameter = NominalDiameter;
      this.NominalLength = NominalLength;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let NominalLength = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.NominalDiameter);
      args.push(this.NominalLength);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMechanicalFastenerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.NominalLength = NominalLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let NominalLength = tape[ptr++];
      return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.NominalDiameter);
      args.push(this.NominalLength);
      return args;
    }
  };
  var IfcMedicalDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMedicalDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMemberStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMemberType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMetric = class {
    constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ConstraintGrade = ConstraintGrade;
      this.ConstraintSource = ConstraintSource;
      this.CreatingActor = CreatingActor;
      this.CreationTime = CreationTime;
      this.UserDefinedGrade = UserDefinedGrade;
      this.Benchmark = Benchmark;
      this.ValueSource = ValueSource;
      this.DataValue = DataValue;
      this.ReferencePath = ReferencePath;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConstraintGrade = tape[ptr++];
      let ConstraintSource = tape[ptr++];
      let CreatingActor = tape[ptr++];
      let CreationTime = tape[ptr++];
      let UserDefinedGrade = tape[ptr++];
      let Benchmark = tape[ptr++];
      let ValueSource = tape[ptr++];
      let DataValue = tape[ptr++];
      let ReferencePath = tape[ptr++];
      return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ConstraintGrade);
      args.push(this.ConstraintSource);
      args.push(this.CreatingActor);
      args.push(this.CreationTime);
      args.push(this.UserDefinedGrade);
      args.push(this.Benchmark);
      args.push(this.ValueSource);
      args.push(this.DataValue);
      args.push(this.ReferencePath);
      return args;
    }
  };
  var IfcMirroredProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.ParentProfile = ParentProfile;
      this.Operator = Operator;
      this.Label = Label;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let ParentProfile = tape[ptr++];
      let Operator = tape[ptr++];
      let Label = tape[ptr++];
      return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.ParentProfile);
      args.push(this.Operator);
      args.push(this.Label);
      return args;
    }
  };
  var IfcMonetaryUnit = class {
    constructor(expressID, type, Currency) {
      this.expressID = expressID;
      this.type = type;
      this.Currency = Currency;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Currency = tape[ptr++];
      return new IfcMonetaryUnit(expressID, type, Currency);
    }
    ToTape() {
      let args = [];
      args.push(this.Currency);
      return args;
    }
  };
  var IfcMotorConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcMotorConnectionType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcNamedUnit = class {
    constructor(expressID, type, Dimensions, UnitType) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      return new IfcNamedUnit(expressID, type, Dimensions, UnitType);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      args.push(this.UnitType);
      return args;
    }
  };
  var IfcObject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      return args;
    }
  };
  var IfcObjectDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcObjectPlacement = class {
    constructor(expressID, type, PlacementRelTo) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      return new IfcObjectPlacement(expressID, type, PlacementRelTo);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      return args;
    }
  };
  var IfcObjective = class {
    constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ConstraintGrade = ConstraintGrade;
      this.ConstraintSource = ConstraintSource;
      this.CreatingActor = CreatingActor;
      this.CreationTime = CreationTime;
      this.UserDefinedGrade = UserDefinedGrade;
      this.BenchmarkValues = BenchmarkValues;
      this.LogicalAggregator = LogicalAggregator;
      this.ObjectiveQualifier = ObjectiveQualifier;
      this.UserDefinedQualifier = UserDefinedQualifier;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConstraintGrade = tape[ptr++];
      let ConstraintSource = tape[ptr++];
      let CreatingActor = tape[ptr++];
      let CreationTime = tape[ptr++];
      let UserDefinedGrade = tape[ptr++];
      let BenchmarkValues = tape[ptr++];
      let LogicalAggregator = tape[ptr++];
      let ObjectiveQualifier = tape[ptr++];
      let UserDefinedQualifier = tape[ptr++];
      return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ConstraintGrade);
      args.push(this.ConstraintSource);
      args.push(this.CreatingActor);
      args.push(this.CreationTime);
      args.push(this.UserDefinedGrade);
      args.push(this.BenchmarkValues);
      args.push(this.LogicalAggregator);
      args.push(this.ObjectiveQualifier);
      args.push(this.UserDefinedQualifier);
      return args;
    }
  };
  var IfcOccupant = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.TheActor = TheActor;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let TheActor = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.TheActor);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcOffsetCurve = class {
    constructor(expressID, type, BasisCurve) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      return new IfcOffsetCurve(expressID, type, BasisCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      return args;
    }
  };
  var IfcOffsetCurve2D = class {
    constructor(expressID, type, BasisCurve, Distance, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.Distance = Distance;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let Distance = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      args.push(this.Distance);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcOffsetCurve3D = class {
    constructor(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.Distance = Distance;
      this.SelfIntersect = SelfIntersect;
      this.RefDirection = RefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let Distance = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let RefDirection = tape[ptr++];
      return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      args.push(this.Distance);
      args.push(this.SelfIntersect);
      args.push(this.RefDirection);
      return args;
    }
  };
  var IfcOffsetCurveByDistances = class {
    constructor(expressID, type, BasisCurve, OffsetValues, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.OffsetValues = OffsetValues;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let OffsetValues = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      args.push(this.OffsetValues);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcOpenShell = class {
    constructor(expressID, type, CfsFaces) {
      this.expressID = expressID;
      this.type = type;
      this.CfsFaces = CfsFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CfsFaces = tape[ptr++];
      return new IfcOpenShell(expressID, type, CfsFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.CfsFaces);
      return args;
    }
  };
  var IfcOpeningElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcOpeningStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcOrganization = class {
    constructor(expressID, type, Identification, Name, Description, Roles, Addresses) {
      this.expressID = expressID;
      this.type = type;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.Roles = Roles;
      this.Addresses = Addresses;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Roles = tape[ptr++];
      let Addresses = tape[ptr++];
      return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses);
    }
    ToTape() {
      let args = [];
      args.push(this.Identification);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Roles);
      args.push(this.Addresses);
      return args;
    }
  };
  var IfcOrganizationRelationship = class {
    constructor(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingOrganization = RelatingOrganization;
      this.RelatedOrganizations = RelatedOrganizations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingOrganization = tape[ptr++];
      let RelatedOrganizations = tape[ptr++];
      return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingOrganization);
      args.push(this.RelatedOrganizations);
      return args;
    }
  };
  var IfcOrientationExpression = class {
    constructor(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
      this.expressID = expressID;
      this.type = type;
      this.LateralAxisDirection = LateralAxisDirection;
      this.VerticalAxisDirection = VerticalAxisDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LateralAxisDirection = tape[ptr++];
      let VerticalAxisDirection = tape[ptr++];
      return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.LateralAxisDirection);
      args.push(this.VerticalAxisDirection);
      return args;
    }
  };
  var IfcOrientedEdge = class {
    constructor(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
      this.EdgeElement = EdgeElement;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      let EdgeElement = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      args.push(this.EdgeEnd);
      args.push(this.EdgeElement);
      args.push(this.Orientation);
      return args;
    }
  };
  var IfcOuterBoundaryCurve = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      args.push(this.SelfIntersect);
      return args;
    }
  };
  var IfcOutlet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcOutletType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcOwnerHistory = class {
    constructor(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
      this.expressID = expressID;
      this.type = type;
      this.OwningUser = OwningUser;
      this.OwningApplication = OwningApplication;
      this.State = State;
      this.ChangeAction = ChangeAction;
      this.LastModifiedDate = LastModifiedDate;
      this.LastModifyingUser = LastModifyingUser;
      this.LastModifyingApplication = LastModifyingApplication;
      this.CreationDate = CreationDate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let OwningUser = tape[ptr++];
      let OwningApplication = tape[ptr++];
      let State = tape[ptr++];
      let ChangeAction = tape[ptr++];
      let LastModifiedDate = tape[ptr++];
      let LastModifyingUser = tape[ptr++];
      let LastModifyingApplication = tape[ptr++];
      let CreationDate = tape[ptr++];
      return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
    }
    ToTape() {
      let args = [];
      args.push(this.OwningUser);
      args.push(this.OwningApplication);
      args.push(this.State);
      args.push(this.ChangeAction);
      args.push(this.LastModifiedDate);
      args.push(this.LastModifyingUser);
      args.push(this.LastModifyingApplication);
      args.push(this.CreationDate);
      return args;
    }
  };
  var IfcParameterizedProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      return args;
    }
  };
  var IfcPath = class {
    constructor(expressID, type, EdgeList) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeList = EdgeList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeList = tape[ptr++];
      return new IfcPath(expressID, type, EdgeList);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeList);
      return args;
    }
  };
  var IfcPcurve = class {
    constructor(expressID, type, BasisSurface, ReferenceCurve) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.ReferenceCurve = ReferenceCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let ReferenceCurve = tape[ptr++];
      return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      args.push(this.ReferenceCurve);
      return args;
    }
  };
  var IfcPerformanceHistory = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LifeCyclePhase = LifeCyclePhase;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LifeCyclePhase = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LifeCyclePhase);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPermeableCoveringProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.OperationType = OperationType;
      this.PanelPosition = PanelPosition;
      this.FrameDepth = FrameDepth;
      this.FrameThickness = FrameThickness;
      this.ShapeAspectStyle = ShapeAspectStyle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let OperationType = tape[ptr++];
      let PanelPosition = tape[ptr++];
      let FrameDepth = tape[ptr++];
      let FrameThickness = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.OperationType);
      args.push(this.PanelPosition);
      args.push(this.FrameDepth);
      args.push(this.FrameThickness);
      args.push(this.ShapeAspectStyle);
      return args;
    }
  };
  var IfcPermit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.PredefinedType);
      args.push(this.Status);
      args.push(this.LongDescription);
      return args;
    }
  };
  var IfcPerson = class {
    constructor(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
      this.expressID = expressID;
      this.type = type;
      this.Identification = Identification;
      this.FamilyName = FamilyName;
      this.GivenName = GivenName;
      this.MiddleNames = MiddleNames;
      this.PrefixTitles = PrefixTitles;
      this.SuffixTitles = SuffixTitles;
      this.Roles = Roles;
      this.Addresses = Addresses;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identification = tape[ptr++];
      let FamilyName = tape[ptr++];
      let GivenName = tape[ptr++];
      let MiddleNames = tape[ptr++];
      let PrefixTitles = tape[ptr++];
      let SuffixTitles = tape[ptr++];
      let Roles = tape[ptr++];
      let Addresses = tape[ptr++];
      return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
    }
    ToTape() {
      let args = [];
      args.push(this.Identification);
      args.push(this.FamilyName);
      args.push(this.GivenName);
      args.push(this.MiddleNames);
      args.push(this.PrefixTitles);
      args.push(this.SuffixTitles);
      args.push(this.Roles);
      args.push(this.Addresses);
      return args;
    }
  };
  var IfcPersonAndOrganization = class {
    constructor(expressID, type, ThePerson, TheOrganization, Roles) {
      this.expressID = expressID;
      this.type = type;
      this.ThePerson = ThePerson;
      this.TheOrganization = TheOrganization;
      this.Roles = Roles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ThePerson = tape[ptr++];
      let TheOrganization = tape[ptr++];
      let Roles = tape[ptr++];
      return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles);
    }
    ToTape() {
      let args = [];
      args.push(this.ThePerson);
      args.push(this.TheOrganization);
      args.push(this.Roles);
      return args;
    }
  };
  var IfcPhysicalComplexQuantity = class {
    constructor(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.HasQuantities = HasQuantities;
      this.Discrimination = Discrimination;
      this.Quality = Quality;
      this.Usage = Usage;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let HasQuantities = tape[ptr++];
      let Discrimination = tape[ptr++];
      let Quality = tape[ptr++];
      let Usage = tape[ptr++];
      return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.HasQuantities);
      args.push(this.Discrimination);
      args.push(this.Quality);
      args.push(this.Usage);
      return args;
    }
  };
  var IfcPhysicalQuantity = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPhysicalQuantity(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcPhysicalSimpleQuantity = class {
    constructor(expressID, type, Name, Description, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      return args;
    }
  };
  var IfcPile = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
      this.ConstructionType = ConstructionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ConstructionType = tape[ptr++];
      return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      args.push(this.ConstructionType);
      return args;
    }
  };
  var IfcPileType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPipeFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPipeFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPipeSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPipeSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPixelTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
      this.Width = Width;
      this.Height = Height;
      this.ColourComponents = ColourComponents;
      this.Pixel = Pixel;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      let Width = tape[ptr++];
      let Height = tape[ptr++];
      let ColourComponents = tape[ptr++];
      let Pixel = tape[ptr++];
      return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      args.push(this.RepeatT);
      args.push(this.Mode);
      args.push(this.TextureTransform);
      args.push(this.Parameter);
      args.push(this.Width);
      args.push(this.Height);
      args.push(this.ColourComponents);
      args.push(this.Pixel);
      return args;
    }
  };
  var IfcPlacement = class {
    constructor(expressID, type, Location) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      return new IfcPlacement(expressID, type, Location);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      return args;
    }
  };
  var IfcPlanarBox = class {
    constructor(expressID, type, SizeInX, SizeInY, Placement) {
      this.expressID = expressID;
      this.type = type;
      this.SizeInX = SizeInX;
      this.SizeInY = SizeInY;
      this.Placement = Placement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SizeInX = tape[ptr++];
      let SizeInY = tape[ptr++];
      let Placement = tape[ptr++];
      return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement);
    }
    ToTape() {
      let args = [];
      args.push(this.SizeInX);
      args.push(this.SizeInY);
      args.push(this.Placement);
      return args;
    }
  };
  var IfcPlanarExtent = class {
    constructor(expressID, type, SizeInX, SizeInY) {
      this.expressID = expressID;
      this.type = type;
      this.SizeInX = SizeInX;
      this.SizeInY = SizeInY;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SizeInX = tape[ptr++];
      let SizeInY = tape[ptr++];
      return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY);
    }
    ToTape() {
      let args = [];
      args.push(this.SizeInX);
      args.push(this.SizeInY);
      return args;
    }
  };
  var IfcPlane = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcPlane(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      return args;
    }
  };
  var IfcPlate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPlateStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPlateType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPoint = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcPoint(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPointOnCurve = class {
    constructor(expressID, type, BasisCurve, PointParameter) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.PointParameter = PointParameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let PointParameter = tape[ptr++];
      return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      args.push(this.PointParameter);
      return args;
    }
  };
  var IfcPointOnSurface = class {
    constructor(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.PointParameterU = PointParameterU;
      this.PointParameterV = PointParameterV;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let PointParameterU = tape[ptr++];
      let PointParameterV = tape[ptr++];
      return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      args.push(this.PointParameterU);
      args.push(this.PointParameterV);
      return args;
    }
  };
  var IfcPolyLoop = class {
    constructor(expressID, type, Polygon) {
      this.expressID = expressID;
      this.type = type;
      this.Polygon = Polygon;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Polygon = tape[ptr++];
      return new IfcPolyLoop(expressID, type, Polygon);
    }
    ToTape() {
      let args = [];
      args.push(this.Polygon);
      return args;
    }
  };
  var IfcPolygonalBoundedHalfSpace = class {
    constructor(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.BaseSurface = BaseSurface;
      this.AgreementFlag = AgreementFlag;
      this.Position = Position;
      this.PolygonalBoundary = PolygonalBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BaseSurface = tape[ptr++];
      let AgreementFlag = tape[ptr++];
      let Position = tape[ptr++];
      let PolygonalBoundary = tape[ptr++];
      return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.BaseSurface);
      args.push(this.AgreementFlag);
      args.push(this.Position);
      args.push(this.PolygonalBoundary);
      return args;
    }
  };
  var IfcPolygonalFaceSet = class {
    constructor(expressID, type, Coordinates, Closed, Faces, PnIndex) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
      this.Closed = Closed;
      this.Faces = Faces;
      this.PnIndex = PnIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      let Closed = tape[ptr++];
      let Faces = tape[ptr++];
      let PnIndex = tape[ptr++];
      return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      args.push(this.Closed);
      args.push(this.Faces);
      args.push(this.PnIndex);
      return args;
    }
  };
  var IfcPolyline = class {
    constructor(expressID, type, Points) {
      this.expressID = expressID;
      this.type = type;
      this.Points = Points;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Points = tape[ptr++];
      return new IfcPolyline(expressID, type, Points);
    }
    ToTape() {
      let args = [];
      args.push(this.Points);
      return args;
    }
  };
  var IfcPort = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      return args;
    }
  };
  var IfcPositioningElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      return args;
    }
  };
  var IfcPostalAddress = class {
    constructor(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
      this.expressID = expressID;
      this.type = type;
      this.Purpose = Purpose;
      this.Description = Description;
      this.UserDefinedPurpose = UserDefinedPurpose;
      this.InternalLocation = InternalLocation;
      this.AddressLines = AddressLines;
      this.PostalBox = PostalBox;
      this.Town = Town;
      this.Region = Region;
      this.PostalCode = PostalCode;
      this.Country = Country;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Purpose = tape[ptr++];
      let Description = tape[ptr++];
      let UserDefinedPurpose = tape[ptr++];
      let InternalLocation = tape[ptr++];
      let AddressLines = tape[ptr++];
      let PostalBox = tape[ptr++];
      let Town = tape[ptr++];
      let Region = tape[ptr++];
      let PostalCode = tape[ptr++];
      let Country = tape[ptr++];
      return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
    }
    ToTape() {
      let args = [];
      args.push(this.Purpose);
      args.push(this.Description);
      args.push(this.UserDefinedPurpose);
      args.push(this.InternalLocation);
      args.push(this.AddressLines);
      args.push(this.PostalBox);
      args.push(this.Town);
      args.push(this.Region);
      args.push(this.PostalCode);
      args.push(this.Country);
      return args;
    }
  };
  var IfcPreDefinedColour = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedColour(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcPreDefinedCurveFont = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedCurveFont(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcPreDefinedItem = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedItem(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcPreDefinedProperties = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcPreDefinedProperties(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPreDefinedPropertySet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcPreDefinedTextFont = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedTextFont(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcPresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcPresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPresentationLayerAssignment = class {
    constructor(expressID, type, Name, Description, AssignedItems, Identifier) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AssignedItems = AssignedItems;
      this.Identifier = Identifier;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AssignedItems = tape[ptr++];
      let Identifier = tape[ptr++];
      return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.AssignedItems);
      args.push(this.Identifier);
      return args;
    }
  };
  var IfcPresentationLayerWithStyle = class {
    constructor(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AssignedItems = AssignedItems;
      this.Identifier = Identifier;
      this.LayerOn = LayerOn;
      this.LayerFrozen = LayerFrozen;
      this.LayerBlocked = LayerBlocked;
      this.LayerStyles = LayerStyles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AssignedItems = tape[ptr++];
      let Identifier = tape[ptr++];
      let LayerOn = tape[ptr++];
      let LayerFrozen = tape[ptr++];
      let LayerBlocked = tape[ptr++];
      let LayerStyles = tape[ptr++];
      return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.AssignedItems);
      args.push(this.Identifier);
      args.push(this.LayerOn);
      args.push(this.LayerFrozen);
      args.push(this.LayerBlocked);
      args.push(this.LayerStyles);
      return args;
    }
  };
  var IfcPresentationStyle = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPresentationStyle(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcPresentationStyleAssignment = class {
    constructor(expressID, type, Styles) {
      this.expressID = expressID;
      this.type = type;
      this.Styles = Styles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Styles = tape[ptr++];
      return new IfcPresentationStyleAssignment(expressID, type, Styles);
    }
    ToTape() {
      let args = [];
      args.push(this.Styles);
      return args;
    }
  };
  var IfcProcedure = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProcedureType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ProcessType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProcess = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      return args;
    }
  };
  var IfcProduct = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      return args;
    }
  };
  var IfcProductDefinitionShape = class {
    constructor(expressID, type, Name, Description, Representations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Representations = Representations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Representations = tape[ptr++];
      return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Representations);
      return args;
    }
  };
  var IfcProductRepresentation = class {
    constructor(expressID, type, Name, Description, Representations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Representations = Representations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Representations = tape[ptr++];
      return new IfcProductRepresentation(expressID, type, Name, Description, Representations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Representations);
      return args;
    }
  };
  var IfcProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      return new IfcProfileDef(expressID, type, ProfileType, ProfileName);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      return args;
    }
  };
  var IfcProfileProperties = class {
    constructor(expressID, type, Name, Description, Properties2, ProfileDefinition) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Properties = Properties2;
      this.ProfileDefinition = ProfileDefinition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Properties2 = tape[ptr++];
      let ProfileDefinition = tape[ptr++];
      return new IfcProfileProperties(expressID, type, Name, Description, Properties2, ProfileDefinition);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Properties);
      args.push(this.ProfileDefinition);
      return args;
    }
  };
  var IfcProject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.Phase = Phase;
      this.RepresentationContexts = RepresentationContexts;
      this.UnitsInContext = UnitsInContext;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let Phase = tape[ptr++];
      let RepresentationContexts = tape[ptr++];
      let UnitsInContext = tape[ptr++];
      return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.LongName);
      args.push(this.Phase);
      args.push(this.RepresentationContexts);
      args.push(this.UnitsInContext);
      return args;
    }
  };
  var IfcProjectLibrary = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.Phase = Phase;
      this.RepresentationContexts = RepresentationContexts;
      this.UnitsInContext = UnitsInContext;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let Phase = tape[ptr++];
      let RepresentationContexts = tape[ptr++];
      let UnitsInContext = tape[ptr++];
      return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.LongName);
      args.push(this.Phase);
      args.push(this.RepresentationContexts);
      args.push(this.UnitsInContext);
      return args;
    }
  };
  var IfcProjectOrder = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.PredefinedType);
      args.push(this.Status);
      args.push(this.LongDescription);
      return args;
    }
  };
  var IfcProjectedCRS = class {
    constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.GeodeticDatum = GeodeticDatum;
      this.VerticalDatum = VerticalDatum;
      this.MapProjection = MapProjection;
      this.MapZone = MapZone;
      this.MapUnit = MapUnit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let GeodeticDatum = tape[ptr++];
      let VerticalDatum = tape[ptr++];
      let MapProjection = tape[ptr++];
      let MapZone = tape[ptr++];
      let MapUnit = tape[ptr++];
      return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.GeodeticDatum);
      args.push(this.VerticalDatum);
      args.push(this.MapProjection);
      args.push(this.MapZone);
      args.push(this.MapUnit);
      return args;
    }
  };
  var IfcProjectionElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProperty = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcProperty(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcPropertyAbstraction = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcPropertyAbstraction(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPropertyBoundedValue = class {
    constructor(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.UpperBoundValue = UpperBoundValue;
      this.LowerBoundValue = LowerBoundValue;
      this.Unit = Unit;
      this.SetPointValue = SetPointValue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UpperBoundValue = tape[ptr++];
      let LowerBoundValue = tape[ptr++];
      let Unit = tape[ptr++];
      let SetPointValue = tape[ptr++];
      return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.UpperBoundValue);
      args.push(this.LowerBoundValue);
      args.push(this.Unit);
      args.push(this.SetPointValue);
      return args;
    }
  };
  var IfcPropertyDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcPropertyDependencyRelationship = class {
    constructor(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.DependingProperty = DependingProperty;
      this.DependantProperty = DependantProperty;
      this.Expression = Expression;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let DependingProperty = tape[ptr++];
      let DependantProperty = tape[ptr++];
      let Expression = tape[ptr++];
      return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.DependingProperty);
      args.push(this.DependantProperty);
      args.push(this.Expression);
      return args;
    }
  };
  var IfcPropertyEnumeratedValue = class {
    constructor(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.EnumerationValues = EnumerationValues;
      this.EnumerationReference = EnumerationReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let EnumerationValues = tape[ptr++];
      let EnumerationReference = tape[ptr++];
      return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.EnumerationValues);
      args.push(this.EnumerationReference);
      return args;
    }
  };
  var IfcPropertyEnumeration = class {
    constructor(expressID, type, Name, EnumerationValues, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.EnumerationValues = EnumerationValues;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let EnumerationValues = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.EnumerationValues);
      args.push(this.Unit);
      return args;
    }
  };
  var IfcPropertyListValue = class {
    constructor(expressID, type, Name, Description, ListValues, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ListValues = ListValues;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ListValues = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ListValues);
      args.push(this.Unit);
      return args;
    }
  };
  var IfcPropertyReferenceValue = class {
    constructor(expressID, type, Name, Description, UsageName, PropertyReference) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.UsageName = UsageName;
      this.PropertyReference = PropertyReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UsageName = tape[ptr++];
      let PropertyReference = tape[ptr++];
      return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.UsageName);
      args.push(this.PropertyReference);
      return args;
    }
  };
  var IfcPropertySet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.HasProperties = HasProperties;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let HasProperties = tape[ptr++];
      return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.HasProperties);
      return args;
    }
  };
  var IfcPropertySetDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcPropertySetTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.TemplateType = TemplateType;
      this.ApplicableEntity = ApplicableEntity;
      this.HasPropertyTemplates = HasPropertyTemplates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let TemplateType = tape[ptr++];
      let ApplicableEntity = tape[ptr++];
      let HasPropertyTemplates = tape[ptr++];
      return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.TemplateType);
      args.push(this.ApplicableEntity);
      args.push(this.HasPropertyTemplates);
      return args;
    }
  };
  var IfcPropertySingleValue = class {
    constructor(expressID, type, Name, Description, NominalValue, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.NominalValue = NominalValue;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let NominalValue = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.NominalValue);
      args.push(this.Unit);
      return args;
    }
  };
  var IfcPropertyTableValue = class {
    constructor(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.DefiningValues = DefiningValues;
      this.DefinedValues = DefinedValues;
      this.Expression = Expression;
      this.DefiningUnit = DefiningUnit;
      this.DefinedUnit = DefinedUnit;
      this.CurveInterpolation = CurveInterpolation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let DefiningValues = tape[ptr++];
      let DefinedValues = tape[ptr++];
      let Expression = tape[ptr++];
      let DefiningUnit = tape[ptr++];
      let DefinedUnit = tape[ptr++];
      let CurveInterpolation = tape[ptr++];
      return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.DefiningValues);
      args.push(this.DefinedValues);
      args.push(this.Expression);
      args.push(this.DefiningUnit);
      args.push(this.DefinedUnit);
      args.push(this.CurveInterpolation);
      return args;
    }
  };
  var IfcPropertyTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcPropertyTemplateDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcProtectiveDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProtectiveDeviceTrippingUnit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProtectiveDeviceTrippingUnitType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProtectiveDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcProxy = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.ProxyType = ProxyType;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let ProxyType = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.ProxyType);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcPump = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcPumpType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcQuantityArea = class {
    constructor(expressID, type, Name, Description, Unit, AreaValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.AreaValue = AreaValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let AreaValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.AreaValue);
      args.push(this.Formula);
      return args;
    }
  };
  var IfcQuantityCount = class {
    constructor(expressID, type, Name, Description, Unit, CountValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.CountValue = CountValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let CountValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.CountValue);
      args.push(this.Formula);
      return args;
    }
  };
  var IfcQuantityLength = class {
    constructor(expressID, type, Name, Description, Unit, LengthValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.LengthValue = LengthValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let LengthValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.LengthValue);
      args.push(this.Formula);
      return args;
    }
  };
  var IfcQuantitySet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcQuantityTime = class {
    constructor(expressID, type, Name, Description, Unit, TimeValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.TimeValue = TimeValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let TimeValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.TimeValue);
      args.push(this.Formula);
      return args;
    }
  };
  var IfcQuantityVolume = class {
    constructor(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.VolumeValue = VolumeValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let VolumeValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.VolumeValue);
      args.push(this.Formula);
      return args;
    }
  };
  var IfcQuantityWeight = class {
    constructor(expressID, type, Name, Description, Unit, WeightValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.WeightValue = WeightValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let WeightValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.WeightValue);
      args.push(this.Formula);
      return args;
    }
  };
  var IfcRailing = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRailingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRamp = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRampFlight = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRampFlightType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRampType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRationalBSplineCurveWithKnots = class {
    constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
      this.expressID = expressID;
      this.type = type;
      this.Degree = Degree;
      this.ControlPointsList = ControlPointsList;
      this.CurveForm = CurveForm;
      this.ClosedCurve = ClosedCurve;
      this.SelfIntersect = SelfIntersect;
      this.KnotMultiplicities = KnotMultiplicities;
      this.Knots = Knots;
      this.KnotSpec = KnotSpec;
      this.WeightsData = WeightsData;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Degree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let CurveForm = tape[ptr++];
      let ClosedCurve = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let KnotMultiplicities = tape[ptr++];
      let Knots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      let WeightsData = tape[ptr++];
      return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
    }
    ToTape() {
      let args = [];
      args.push(this.Degree);
      args.push(this.ControlPointsList);
      args.push(this.CurveForm);
      args.push(this.ClosedCurve);
      args.push(this.SelfIntersect);
      args.push(this.KnotMultiplicities);
      args.push(this.Knots);
      args.push(this.KnotSpec);
      args.push(this.WeightsData);
      return args;
    }
  };
  var IfcRationalBSplineSurfaceWithKnots = class {
    constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
      this.expressID = expressID;
      this.type = type;
      this.UDegree = UDegree;
      this.VDegree = VDegree;
      this.ControlPointsList = ControlPointsList;
      this.SurfaceForm = SurfaceForm;
      this.UClosed = UClosed;
      this.VClosed = VClosed;
      this.SelfIntersect = SelfIntersect;
      this.UMultiplicities = UMultiplicities;
      this.VMultiplicities = VMultiplicities;
      this.UKnots = UKnots;
      this.VKnots = VKnots;
      this.KnotSpec = KnotSpec;
      this.WeightsData = WeightsData;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let UDegree = tape[ptr++];
      let VDegree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let SurfaceForm = tape[ptr++];
      let UClosed = tape[ptr++];
      let VClosed = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let UMultiplicities = tape[ptr++];
      let VMultiplicities = tape[ptr++];
      let UKnots = tape[ptr++];
      let VKnots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      let WeightsData = tape[ptr++];
      return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
    }
    ToTape() {
      let args = [];
      args.push(this.UDegree);
      args.push(this.VDegree);
      args.push(this.ControlPointsList);
      args.push(this.SurfaceForm);
      args.push(this.UClosed);
      args.push(this.VClosed);
      args.push(this.SelfIntersect);
      args.push(this.UMultiplicities);
      args.push(this.VMultiplicities);
      args.push(this.UKnots);
      args.push(this.VKnots);
      args.push(this.KnotSpec);
      args.push(this.WeightsData);
      return args;
    }
  };
  var IfcRectangleHollowProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.XDim = XDim;
      this.YDim = YDim;
      this.WallThickness = WallThickness;
      this.InnerFilletRadius = InnerFilletRadius;
      this.OuterFilletRadius = OuterFilletRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      let WallThickness = tape[ptr++];
      let InnerFilletRadius = tape[ptr++];
      let OuterFilletRadius = tape[ptr++];
      return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.XDim);
      args.push(this.YDim);
      args.push(this.WallThickness);
      args.push(this.InnerFilletRadius);
      args.push(this.OuterFilletRadius);
      return args;
    }
  };
  var IfcRectangleProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.XDim = XDim;
      this.YDim = YDim;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.XDim);
      args.push(this.YDim);
      return args;
    }
  };
  var IfcRectangularPyramid = class {
    constructor(expressID, type, Position, XLength, YLength, Height) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.XLength = XLength;
      this.YLength = YLength;
      this.Height = Height;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let XLength = tape[ptr++];
      let YLength = tape[ptr++];
      let Height = tape[ptr++];
      return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.XLength);
      args.push(this.YLength);
      args.push(this.Height);
      return args;
    }
  };
  var IfcRectangularTrimmedSurface = class {
    constructor(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.U1 = U1;
      this.V1 = V1;
      this.U2 = U2;
      this.V2 = V2;
      this.Usense = Usense;
      this.Vsense = Vsense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let U1 = tape[ptr++];
      let V1 = tape[ptr++];
      let U2 = tape[ptr++];
      let V2 = tape[ptr++];
      let Usense = tape[ptr++];
      let Vsense = tape[ptr++];
      return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      args.push(this.U1);
      args.push(this.V1);
      args.push(this.U2);
      args.push(this.V2);
      args.push(this.Usense);
      args.push(this.Vsense);
      return args;
    }
  };
  var IfcRecurrencePattern = class {
    constructor(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
      this.expressID = expressID;
      this.type = type;
      this.RecurrenceType = RecurrenceType;
      this.DayComponent = DayComponent;
      this.WeekdayComponent = WeekdayComponent;
      this.MonthComponent = MonthComponent;
      this.Position = Position;
      this.Interval = Interval;
      this.Occurrences = Occurrences;
      this.TimePeriods = TimePeriods;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RecurrenceType = tape[ptr++];
      let DayComponent = tape[ptr++];
      let WeekdayComponent = tape[ptr++];
      let MonthComponent = tape[ptr++];
      let Position = tape[ptr++];
      let Interval = tape[ptr++];
      let Occurrences = tape[ptr++];
      let TimePeriods = tape[ptr++];
      return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
    }
    ToTape() {
      let args = [];
      args.push(this.RecurrenceType);
      args.push(this.DayComponent);
      args.push(this.WeekdayComponent);
      args.push(this.MonthComponent);
      args.push(this.Position);
      args.push(this.Interval);
      args.push(this.Occurrences);
      args.push(this.TimePeriods);
      return args;
    }
  };
  var IfcReference = class {
    constructor(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
      this.expressID = expressID;
      this.type = type;
      this.TypeIdentifier = TypeIdentifier;
      this.AttributeIdentifier = AttributeIdentifier;
      this.InstanceName = InstanceName;
      this.ListPositions = ListPositions;
      this.InnerReference = InnerReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TypeIdentifier = tape[ptr++];
      let AttributeIdentifier = tape[ptr++];
      let InstanceName = tape[ptr++];
      let ListPositions = tape[ptr++];
      let InnerReference = tape[ptr++];
      return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
    }
    ToTape() {
      let args = [];
      args.push(this.TypeIdentifier);
      args.push(this.AttributeIdentifier);
      args.push(this.InstanceName);
      args.push(this.ListPositions);
      args.push(this.InnerReference);
      return args;
    }
  };
  var IfcReferent = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.RestartDistance = RestartDistance;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let RestartDistance = tape[ptr++];
      return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.PredefinedType);
      args.push(this.RestartDistance);
      return args;
    }
  };
  var IfcRegularTimeSeries = class {
    constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
      this.TimeSeriesDataType = TimeSeriesDataType;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.Unit = Unit;
      this.TimeStep = TimeStep;
      this.Values = Values;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      let TimeSeriesDataType = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let Unit = tape[ptr++];
      let TimeStep = tape[ptr++];
      let Values = tape[ptr++];
      return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.StartTime);
      args.push(this.EndTime);
      args.push(this.TimeSeriesDataType);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.Unit);
      args.push(this.TimeStep);
      args.push(this.Values);
      return args;
    }
  };
  var IfcReinforcementBarProperties = class {
    constructor(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
      this.expressID = expressID;
      this.type = type;
      this.TotalCrossSectionArea = TotalCrossSectionArea;
      this.SteelGrade = SteelGrade;
      this.BarSurface = BarSurface;
      this.EffectiveDepth = EffectiveDepth;
      this.NominalBarDiameter = NominalBarDiameter;
      this.BarCount = BarCount;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TotalCrossSectionArea = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let BarSurface = tape[ptr++];
      let EffectiveDepth = tape[ptr++];
      let NominalBarDiameter = tape[ptr++];
      let BarCount = tape[ptr++];
      return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
    }
    ToTape() {
      let args = [];
      args.push(this.TotalCrossSectionArea);
      args.push(this.SteelGrade);
      args.push(this.BarSurface);
      args.push(this.EffectiveDepth);
      args.push(this.NominalBarDiameter);
      args.push(this.BarCount);
      return args;
    }
  };
  var IfcReinforcementDefinitionProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.DefinitionType = DefinitionType;
      this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let DefinitionType = tape[ptr++];
      let ReinforcementSectionDefinitions = tape[ptr++];
      return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.DefinitionType);
      args.push(this.ReinforcementSectionDefinitions);
      return args;
    }
  };
  var IfcReinforcingBar = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.BarLength = BarLength;
      this.PredefinedType = PredefinedType;
      this.BarSurface = BarSurface;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let BarLength = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let BarSurface = tape[ptr++];
      return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.SteelGrade);
      args.push(this.NominalDiameter);
      args.push(this.CrossSectionArea);
      args.push(this.BarLength);
      args.push(this.PredefinedType);
      args.push(this.BarSurface);
      return args;
    }
  };
  var IfcReinforcingBarType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.BarLength = BarLength;
      this.BarSurface = BarSurface;
      this.BendingShapeCode = BendingShapeCode;
      this.BendingParameters = BendingParameters;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let BarLength = tape[ptr++];
      let BarSurface = tape[ptr++];
      let BendingShapeCode = tape[ptr++];
      let BendingParameters = tape[ptr++];
      return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.NominalDiameter);
      args.push(this.CrossSectionArea);
      args.push(this.BarLength);
      args.push(this.BarSurface);
      args.push(this.BendingShapeCode);
      args.push(this.BendingParameters);
      return args;
    }
  };
  var IfcReinforcingElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.SteelGrade);
      return args;
    }
  };
  var IfcReinforcingElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcReinforcingMesh = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.MeshLength = MeshLength;
      this.MeshWidth = MeshWidth;
      this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
      this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
      this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
      this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
      this.LongitudinalBarSpacing = LongitudinalBarSpacing;
      this.TransverseBarSpacing = TransverseBarSpacing;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let MeshLength = tape[ptr++];
      let MeshWidth = tape[ptr++];
      let LongitudinalBarNominalDiameter = tape[ptr++];
      let TransverseBarNominalDiameter = tape[ptr++];
      let LongitudinalBarCrossSectionArea = tape[ptr++];
      let TransverseBarCrossSectionArea = tape[ptr++];
      let LongitudinalBarSpacing = tape[ptr++];
      let TransverseBarSpacing = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.SteelGrade);
      args.push(this.MeshLength);
      args.push(this.MeshWidth);
      args.push(this.LongitudinalBarNominalDiameter);
      args.push(this.TransverseBarNominalDiameter);
      args.push(this.LongitudinalBarCrossSectionArea);
      args.push(this.TransverseBarCrossSectionArea);
      args.push(this.LongitudinalBarSpacing);
      args.push(this.TransverseBarSpacing);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcReinforcingMeshType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.MeshLength = MeshLength;
      this.MeshWidth = MeshWidth;
      this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
      this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
      this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
      this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
      this.LongitudinalBarSpacing = LongitudinalBarSpacing;
      this.TransverseBarSpacing = TransverseBarSpacing;
      this.BendingShapeCode = BendingShapeCode;
      this.BendingParameters = BendingParameters;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let MeshLength = tape[ptr++];
      let MeshWidth = tape[ptr++];
      let LongitudinalBarNominalDiameter = tape[ptr++];
      let TransverseBarNominalDiameter = tape[ptr++];
      let LongitudinalBarCrossSectionArea = tape[ptr++];
      let TransverseBarCrossSectionArea = tape[ptr++];
      let LongitudinalBarSpacing = tape[ptr++];
      let TransverseBarSpacing = tape[ptr++];
      let BendingShapeCode = tape[ptr++];
      let BendingParameters = tape[ptr++];
      return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.MeshLength);
      args.push(this.MeshWidth);
      args.push(this.LongitudinalBarNominalDiameter);
      args.push(this.TransverseBarNominalDiameter);
      args.push(this.LongitudinalBarCrossSectionArea);
      args.push(this.TransverseBarCrossSectionArea);
      args.push(this.LongitudinalBarSpacing);
      args.push(this.TransverseBarSpacing);
      args.push(this.BendingShapeCode);
      args.push(this.BendingParameters);
      return args;
    }
  };
  var IfcRelAggregates = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingObject = RelatingObject;
      this.RelatedObjects = RelatedObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingObject = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingObject);
      args.push(this.RelatedObjects);
      return args;
    }
  };
  var IfcRelAssigns = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      return args;
    }
  };
  var IfcRelAssignsToActor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingActor = RelatingActor;
      this.ActingRole = ActingRole;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingActor = tape[ptr++];
      let ActingRole = tape[ptr++];
      return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingActor);
      args.push(this.ActingRole);
      return args;
    }
  };
  var IfcRelAssignsToControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingControl = RelatingControl;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingControl = tape[ptr++];
      return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingControl);
      return args;
    }
  };
  var IfcRelAssignsToGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingGroup = RelatingGroup;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingGroup = tape[ptr++];
      return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingGroup);
      return args;
    }
  };
  var IfcRelAssignsToGroupByFactor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingGroup = RelatingGroup;
      this.Factor = Factor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingGroup = tape[ptr++];
      let Factor = tape[ptr++];
      return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingGroup);
      args.push(this.Factor);
      return args;
    }
  };
  var IfcRelAssignsToProcess = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingProcess = RelatingProcess;
      this.QuantityInProcess = QuantityInProcess;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingProcess = tape[ptr++];
      let QuantityInProcess = tape[ptr++];
      return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingProcess);
      args.push(this.QuantityInProcess);
      return args;
    }
  };
  var IfcRelAssignsToProduct = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingProduct = RelatingProduct;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingProduct = tape[ptr++];
      return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingProduct);
      return args;
    }
  };
  var IfcRelAssignsToResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingResource = RelatingResource;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingResource = tape[ptr++];
      return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatedObjectsType);
      args.push(this.RelatingResource);
      return args;
    }
  };
  var IfcRelAssociates = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      return args;
    }
  };
  var IfcRelAssociatesApproval = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingApproval = RelatingApproval;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingApproval = tape[ptr++];
      return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingApproval);
      return args;
    }
  };
  var IfcRelAssociatesClassification = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingClassification = RelatingClassification;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingClassification = tape[ptr++];
      return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingClassification);
      return args;
    }
  };
  var IfcRelAssociatesConstraint = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.Intent = Intent;
      this.RelatingConstraint = RelatingConstraint;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let Intent = tape[ptr++];
      let RelatingConstraint = tape[ptr++];
      return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.Intent);
      args.push(this.RelatingConstraint);
      return args;
    }
  };
  var IfcRelAssociatesDocument = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingDocument = RelatingDocument;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingDocument = tape[ptr++];
      return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingDocument);
      return args;
    }
  };
  var IfcRelAssociatesLibrary = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingLibrary = RelatingLibrary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingLibrary = tape[ptr++];
      return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingLibrary);
      return args;
    }
  };
  var IfcRelAssociatesMaterial = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingMaterial = RelatingMaterial;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingMaterial = tape[ptr++];
      return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingMaterial);
      return args;
    }
  };
  var IfcRelConnects = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcRelConnectsElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ConnectionGeometry = ConnectionGeometry;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ConnectionGeometry);
      args.push(this.RelatingElement);
      args.push(this.RelatedElement);
      return args;
    }
  };
  var IfcRelConnectsPathElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ConnectionGeometry = ConnectionGeometry;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
      this.RelatingPriorities = RelatingPriorities;
      this.RelatedPriorities = RelatedPriorities;
      this.RelatedConnectionType = RelatedConnectionType;
      this.RelatingConnectionType = RelatingConnectionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      let RelatingPriorities = tape[ptr++];
      let RelatedPriorities = tape[ptr++];
      let RelatedConnectionType = tape[ptr++];
      let RelatingConnectionType = tape[ptr++];
      return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ConnectionGeometry);
      args.push(this.RelatingElement);
      args.push(this.RelatedElement);
      args.push(this.RelatingPriorities);
      args.push(this.RelatedPriorities);
      args.push(this.RelatedConnectionType);
      args.push(this.RelatingConnectionType);
      return args;
    }
  };
  var IfcRelConnectsPortToElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingPort = RelatingPort;
      this.RelatedElement = RelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingPort = tape[ptr++];
      let RelatedElement = tape[ptr++];
      return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingPort);
      args.push(this.RelatedElement);
      return args;
    }
  };
  var IfcRelConnectsPorts = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingPort = RelatingPort;
      this.RelatedPort = RelatedPort;
      this.RealizingElement = RealizingElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingPort = tape[ptr++];
      let RelatedPort = tape[ptr++];
      let RealizingElement = tape[ptr++];
      return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingPort);
      args.push(this.RelatedPort);
      args.push(this.RealizingElement);
      return args;
    }
  };
  var IfcRelConnectsStructuralActivity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingElement = RelatingElement;
      this.RelatedStructuralActivity = RelatedStructuralActivity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedStructuralActivity = tape[ptr++];
      return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingElement);
      args.push(this.RelatedStructuralActivity);
      return args;
    }
  };
  var IfcRelConnectsStructuralMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingStructuralMember = RelatingStructuralMember;
      this.RelatedStructuralConnection = RelatedStructuralConnection;
      this.AppliedCondition = AppliedCondition;
      this.AdditionalConditions = AdditionalConditions;
      this.SupportedLength = SupportedLength;
      this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingStructuralMember = tape[ptr++];
      let RelatedStructuralConnection = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let AdditionalConditions = tape[ptr++];
      let SupportedLength = tape[ptr++];
      let ConditionCoordinateSystem = tape[ptr++];
      return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingStructuralMember);
      args.push(this.RelatedStructuralConnection);
      args.push(this.AppliedCondition);
      args.push(this.AdditionalConditions);
      args.push(this.SupportedLength);
      args.push(this.ConditionCoordinateSystem);
      return args;
    }
  };
  var IfcRelConnectsWithEccentricity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingStructuralMember = RelatingStructuralMember;
      this.RelatedStructuralConnection = RelatedStructuralConnection;
      this.AppliedCondition = AppliedCondition;
      this.AdditionalConditions = AdditionalConditions;
      this.SupportedLength = SupportedLength;
      this.ConditionCoordinateSystem = ConditionCoordinateSystem;
      this.ConnectionConstraint = ConnectionConstraint;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingStructuralMember = tape[ptr++];
      let RelatedStructuralConnection = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let AdditionalConditions = tape[ptr++];
      let SupportedLength = tape[ptr++];
      let ConditionCoordinateSystem = tape[ptr++];
      let ConnectionConstraint = tape[ptr++];
      return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingStructuralMember);
      args.push(this.RelatedStructuralConnection);
      args.push(this.AppliedCondition);
      args.push(this.AdditionalConditions);
      args.push(this.SupportedLength);
      args.push(this.ConditionCoordinateSystem);
      args.push(this.ConnectionConstraint);
      return args;
    }
  };
  var IfcRelConnectsWithRealizingElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ConnectionGeometry = ConnectionGeometry;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
      this.RealizingElements = RealizingElements;
      this.ConnectionType = ConnectionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      let RealizingElements = tape[ptr++];
      let ConnectionType = tape[ptr++];
      return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ConnectionGeometry);
      args.push(this.RelatingElement);
      args.push(this.RelatedElement);
      args.push(this.RealizingElements);
      args.push(this.ConnectionType);
      return args;
    }
  };
  var IfcRelContainedInSpatialStructure = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedElements = RelatedElements;
      this.RelatingStructure = RelatingStructure;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedElements = tape[ptr++];
      let RelatingStructure = tape[ptr++];
      return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedElements);
      args.push(this.RelatingStructure);
      return args;
    }
  };
  var IfcRelCoversBldgElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingBuildingElement = RelatingBuildingElement;
      this.RelatedCoverings = RelatedCoverings;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingBuildingElement = tape[ptr++];
      let RelatedCoverings = tape[ptr++];
      return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingBuildingElement);
      args.push(this.RelatedCoverings);
      return args;
    }
  };
  var IfcRelCoversSpaces = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedCoverings = RelatedCoverings;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedCoverings = tape[ptr++];
      return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingSpace);
      args.push(this.RelatedCoverings);
      return args;
    }
  };
  var IfcRelDeclares = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingContext = RelatingContext;
      this.RelatedDefinitions = RelatedDefinitions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingContext = tape[ptr++];
      let RelatedDefinitions = tape[ptr++];
      return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingContext);
      args.push(this.RelatedDefinitions);
      return args;
    }
  };
  var IfcRelDecomposes = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcRelDefines = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcRelDefinesByObject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingObject = RelatingObject;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingObject = tape[ptr++];
      return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingObject);
      return args;
    }
  };
  var IfcRelDefinesByProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingPropertyDefinition = RelatingPropertyDefinition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingPropertyDefinition = tape[ptr++];
      return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingPropertyDefinition);
      return args;
    }
  };
  var IfcRelDefinesByTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedPropertySets = RelatedPropertySets;
      this.RelatingTemplate = RelatingTemplate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedPropertySets = tape[ptr++];
      let RelatingTemplate = tape[ptr++];
      return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedPropertySets);
      args.push(this.RelatingTemplate);
      return args;
    }
  };
  var IfcRelDefinesByType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingType = RelatingType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingType = tape[ptr++];
      return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedObjects);
      args.push(this.RelatingType);
      return args;
    }
  };
  var IfcRelFillsElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingOpeningElement = RelatingOpeningElement;
      this.RelatedBuildingElement = RelatedBuildingElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingOpeningElement = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingOpeningElement);
      args.push(this.RelatedBuildingElement);
      return args;
    }
  };
  var IfcRelFlowControlElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedControlElements = RelatedControlElements;
      this.RelatingFlowElement = RelatingFlowElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedControlElements = tape[ptr++];
      let RelatingFlowElement = tape[ptr++];
      return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedControlElements);
      args.push(this.RelatingFlowElement);
      return args;
    }
  };
  var IfcRelInterferesElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
      this.InterferenceGeometry = InterferenceGeometry;
      this.InterferenceType = InterferenceType;
      this.ImpliedOrder = ImpliedOrder;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      let InterferenceGeometry = tape[ptr++];
      let InterferenceType = tape[ptr++];
      let ImpliedOrder = tape[ptr++];
      return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingElement);
      args.push(this.RelatedElement);
      args.push(this.InterferenceGeometry);
      args.push(this.InterferenceType);
      args.push(this.ImpliedOrder);
      return args;
    }
  };
  var IfcRelNests = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingObject = RelatingObject;
      this.RelatedObjects = RelatedObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingObject = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingObject);
      args.push(this.RelatedObjects);
      return args;
    }
  };
  var IfcRelPositions = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingPositioningElement = RelatingPositioningElement;
      this.RelatedProducts = RelatedProducts;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingPositioningElement = tape[ptr++];
      let RelatedProducts = tape[ptr++];
      return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingPositioningElement);
      args.push(this.RelatedProducts);
      return args;
    }
  };
  var IfcRelProjectsElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingElement = RelatingElement;
      this.RelatedFeatureElement = RelatedFeatureElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedFeatureElement = tape[ptr++];
      return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingElement);
      args.push(this.RelatedFeatureElement);
      return args;
    }
  };
  var IfcRelReferencedInSpatialStructure = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedElements = RelatedElements;
      this.RelatingStructure = RelatingStructure;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedElements = tape[ptr++];
      let RelatingStructure = tape[ptr++];
      return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedElements);
      args.push(this.RelatingStructure);
      return args;
    }
  };
  var IfcRelSequence = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingProcess = RelatingProcess;
      this.RelatedProcess = RelatedProcess;
      this.TimeLag = TimeLag;
      this.SequenceType = SequenceType;
      this.UserDefinedSequenceType = UserDefinedSequenceType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingProcess = tape[ptr++];
      let RelatedProcess = tape[ptr++];
      let TimeLag = tape[ptr++];
      let SequenceType = tape[ptr++];
      let UserDefinedSequenceType = tape[ptr++];
      return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingProcess);
      args.push(this.RelatedProcess);
      args.push(this.TimeLag);
      args.push(this.SequenceType);
      args.push(this.UserDefinedSequenceType);
      return args;
    }
  };
  var IfcRelServicesBuildings = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSystem = RelatingSystem;
      this.RelatedBuildings = RelatedBuildings;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSystem = tape[ptr++];
      let RelatedBuildings = tape[ptr++];
      return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingSystem);
      args.push(this.RelatedBuildings);
      return args;
    }
  };
  var IfcRelSpaceBoundary = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedBuildingElement = RelatedBuildingElement;
      this.ConnectionGeometry = ConnectionGeometry;
      this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
      this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let PhysicalOrVirtualBoundary = tape[ptr++];
      let InternalOrExternalBoundary = tape[ptr++];
      return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingSpace);
      args.push(this.RelatedBuildingElement);
      args.push(this.ConnectionGeometry);
      args.push(this.PhysicalOrVirtualBoundary);
      args.push(this.InternalOrExternalBoundary);
      return args;
    }
  };
  var IfcRelSpaceBoundary1stLevel = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedBuildingElement = RelatedBuildingElement;
      this.ConnectionGeometry = ConnectionGeometry;
      this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
      this.InternalOrExternalBoundary = InternalOrExternalBoundary;
      this.ParentBoundary = ParentBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let PhysicalOrVirtualBoundary = tape[ptr++];
      let InternalOrExternalBoundary = tape[ptr++];
      let ParentBoundary = tape[ptr++];
      return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingSpace);
      args.push(this.RelatedBuildingElement);
      args.push(this.ConnectionGeometry);
      args.push(this.PhysicalOrVirtualBoundary);
      args.push(this.InternalOrExternalBoundary);
      args.push(this.ParentBoundary);
      return args;
    }
  };
  var IfcRelSpaceBoundary2ndLevel = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedBuildingElement = RelatedBuildingElement;
      this.ConnectionGeometry = ConnectionGeometry;
      this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
      this.InternalOrExternalBoundary = InternalOrExternalBoundary;
      this.ParentBoundary = ParentBoundary;
      this.CorrespondingBoundary = CorrespondingBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let PhysicalOrVirtualBoundary = tape[ptr++];
      let InternalOrExternalBoundary = tape[ptr++];
      let ParentBoundary = tape[ptr++];
      let CorrespondingBoundary = tape[ptr++];
      return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingSpace);
      args.push(this.RelatedBuildingElement);
      args.push(this.ConnectionGeometry);
      args.push(this.PhysicalOrVirtualBoundary);
      args.push(this.InternalOrExternalBoundary);
      args.push(this.ParentBoundary);
      args.push(this.CorrespondingBoundary);
      return args;
    }
  };
  var IfcRelVoidsElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingBuildingElement = RelatingBuildingElement;
      this.RelatedOpeningElement = RelatedOpeningElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingBuildingElement = tape[ptr++];
      let RelatedOpeningElement = tape[ptr++];
      return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingBuildingElement);
      args.push(this.RelatedOpeningElement);
      return args;
    }
  };
  var IfcRelationship = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcReparametrisedCompositeCurveSegment = class {
    constructor(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
      this.expressID = expressID;
      this.type = type;
      this.Transition = Transition;
      this.SameSense = SameSense;
      this.ParentCurve = ParentCurve;
      this.ParamLength = ParamLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Transition = tape[ptr++];
      let SameSense = tape[ptr++];
      let ParentCurve = tape[ptr++];
      let ParamLength = tape[ptr++];
      return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength);
    }
    ToTape() {
      let args = [];
      args.push(this.Transition);
      args.push(this.SameSense);
      args.push(this.ParentCurve);
      args.push(this.ParamLength);
      return args;
    }
  };
  var IfcRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      args.push(this.RepresentationIdentifier);
      args.push(this.RepresentationType);
      args.push(this.Items);
      return args;
    }
  };
  var IfcRepresentationContext = class {
    constructor(expressID, type, ContextIdentifier, ContextType) {
      this.expressID = expressID;
      this.type = type;
      this.ContextIdentifier = ContextIdentifier;
      this.ContextType = ContextType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextIdentifier = tape[ptr++];
      let ContextType = tape[ptr++];
      return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextIdentifier);
      args.push(this.ContextType);
      return args;
    }
  };
  var IfcRepresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcRepresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcRepresentationMap = class {
    constructor(expressID, type, MappingOrigin, MappedRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.MappingOrigin = MappingOrigin;
      this.MappedRepresentation = MappedRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MappingOrigin = tape[ptr++];
      let MappedRepresentation = tape[ptr++];
      return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.MappingOrigin);
      args.push(this.MappedRepresentation);
      return args;
    }
  };
  var IfcResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      return args;
    }
  };
  var IfcResourceApprovalRelationship = class {
    constructor(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatedResourceObjects = RelatedResourceObjects;
      this.RelatingApproval = RelatingApproval;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedResourceObjects = tape[ptr++];
      let RelatingApproval = tape[ptr++];
      return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatedResourceObjects);
      args.push(this.RelatingApproval);
      return args;
    }
  };
  var IfcResourceConstraintRelationship = class {
    constructor(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingConstraint = RelatingConstraint;
      this.RelatedResourceObjects = RelatedResourceObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingConstraint = tape[ptr++];
      let RelatedResourceObjects = tape[ptr++];
      return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.RelatingConstraint);
      args.push(this.RelatedResourceObjects);
      return args;
    }
  };
  var IfcResourceLevelRelationship = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcResourceLevelRelationship(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcResourceTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.ScheduleWork = ScheduleWork;
      this.ScheduleUsage = ScheduleUsage;
      this.ScheduleStart = ScheduleStart;
      this.ScheduleFinish = ScheduleFinish;
      this.ScheduleContour = ScheduleContour;
      this.LevelingDelay = LevelingDelay;
      this.IsOverAllocated = IsOverAllocated;
      this.StatusTime = StatusTime;
      this.ActualWork = ActualWork;
      this.ActualUsage = ActualUsage;
      this.ActualStart = ActualStart;
      this.ActualFinish = ActualFinish;
      this.RemainingWork = RemainingWork;
      this.RemainingUsage = RemainingUsage;
      this.Completion = Completion;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let ScheduleWork = tape[ptr++];
      let ScheduleUsage = tape[ptr++];
      let ScheduleStart = tape[ptr++];
      let ScheduleFinish = tape[ptr++];
      let ScheduleContour = tape[ptr++];
      let LevelingDelay = tape[ptr++];
      let IsOverAllocated = tape[ptr++];
      let StatusTime = tape[ptr++];
      let ActualWork = tape[ptr++];
      let ActualUsage = tape[ptr++];
      let ActualStart = tape[ptr++];
      let ActualFinish = tape[ptr++];
      let RemainingWork = tape[ptr++];
      let RemainingUsage = tape[ptr++];
      let Completion = tape[ptr++];
      return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.ScheduleWork);
      args.push(this.ScheduleUsage);
      args.push(this.ScheduleStart);
      args.push(this.ScheduleFinish);
      args.push(this.ScheduleContour);
      args.push(this.LevelingDelay);
      args.push(this.IsOverAllocated);
      args.push(this.StatusTime);
      args.push(this.ActualWork);
      args.push(this.ActualUsage);
      args.push(this.ActualStart);
      args.push(this.ActualFinish);
      args.push(this.RemainingWork);
      args.push(this.RemainingUsage);
      args.push(this.Completion);
      return args;
    }
  };
  var IfcRevolvedAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, Axis, Angle) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Axis = Axis;
      this.Angle = Angle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Axis = tape[ptr++];
      let Angle = tape[ptr++];
      return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      args.push(this.Axis);
      args.push(this.Angle);
      return args;
    }
  };
  var IfcRevolvedAreaSolidTapered = class {
    constructor(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Axis = Axis;
      this.Angle = Angle;
      this.EndSweptArea = EndSweptArea;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Axis = tape[ptr++];
      let Angle = tape[ptr++];
      let EndSweptArea = tape[ptr++];
      return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      args.push(this.Axis);
      args.push(this.Angle);
      args.push(this.EndSweptArea);
      return args;
    }
  };
  var IfcRightCircularCone = class {
    constructor(expressID, type, Position, Height, BottomRadius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Height = Height;
      this.BottomRadius = BottomRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Height = tape[ptr++];
      let BottomRadius = tape[ptr++];
      return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.Height);
      args.push(this.BottomRadius);
      return args;
    }
  };
  var IfcRightCircularCylinder = class {
    constructor(expressID, type, Position, Height, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Height = Height;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Height = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.Height);
      args.push(this.Radius);
      return args;
    }
  };
  var IfcRoof = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRoofType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcRoot = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcRoundedRectangleProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.XDim = XDim;
      this.YDim = YDim;
      this.RoundingRadius = RoundingRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      let RoundingRadius = tape[ptr++];
      return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.XDim);
      args.push(this.YDim);
      args.push(this.RoundingRadius);
      return args;
    }
  };
  var IfcSIUnit = class {
    constructor(expressID, type, Dimensions, UnitType, Prefix, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Prefix = Prefix;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Prefix = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      args.push(this.UnitType);
      args.push(this.Prefix);
      args.push(this.Name);
      return args;
    }
  };
  var IfcSanitaryTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSanitaryTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSchedulingTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      return args;
    }
  };
  var IfcSeamCurve = class {
    constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.Curve3D = Curve3D;
      this.AssociatedGeometry = AssociatedGeometry;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Curve3D = tape[ptr++];
      let AssociatedGeometry = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.Curve3D);
      args.push(this.AssociatedGeometry);
      args.push(this.MasterRepresentation);
      return args;
    }
  };
  var IfcSectionProperties = class {
    constructor(expressID, type, SectionType, StartProfile, EndProfile) {
      this.expressID = expressID;
      this.type = type;
      this.SectionType = SectionType;
      this.StartProfile = StartProfile;
      this.EndProfile = EndProfile;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SectionType = tape[ptr++];
      let StartProfile = tape[ptr++];
      let EndProfile = tape[ptr++];
      return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile);
    }
    ToTape() {
      let args = [];
      args.push(this.SectionType);
      args.push(this.StartProfile);
      args.push(this.EndProfile);
      return args;
    }
  };
  var IfcSectionReinforcementProperties = class {
    constructor(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
      this.expressID = expressID;
      this.type = type;
      this.LongitudinalStartPosition = LongitudinalStartPosition;
      this.LongitudinalEndPosition = LongitudinalEndPosition;
      this.TransversePosition = TransversePosition;
      this.ReinforcementRole = ReinforcementRole;
      this.SectionDefinition = SectionDefinition;
      this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LongitudinalStartPosition = tape[ptr++];
      let LongitudinalEndPosition = tape[ptr++];
      let TransversePosition = tape[ptr++];
      let ReinforcementRole = tape[ptr++];
      let SectionDefinition = tape[ptr++];
      let CrossSectionReinforcementDefinitions = tape[ptr++];
      return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
    }
    ToTape() {
      let args = [];
      args.push(this.LongitudinalStartPosition);
      args.push(this.LongitudinalEndPosition);
      args.push(this.TransversePosition);
      args.push(this.ReinforcementRole);
      args.push(this.SectionDefinition);
      args.push(this.CrossSectionReinforcementDefinitions);
      return args;
    }
  };
  var IfcSectionedSolid = class {
    constructor(expressID, type, Directrix, CrossSections) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.CrossSections = CrossSections;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let CrossSections = tape[ptr++];
      return new IfcSectionedSolid(expressID, type, Directrix, CrossSections);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      args.push(this.CrossSections);
      return args;
    }
  };
  var IfcSectionedSolidHorizontal = class {
    constructor(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.CrossSections = CrossSections;
      this.CrossSectionPositions = CrossSectionPositions;
      this.FixedAxisVertical = FixedAxisVertical;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let CrossSections = tape[ptr++];
      let CrossSectionPositions = tape[ptr++];
      let FixedAxisVertical = tape[ptr++];
      return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      args.push(this.CrossSections);
      args.push(this.CrossSectionPositions);
      args.push(this.FixedAxisVertical);
      return args;
    }
  };
  var IfcSectionedSpine = class {
    constructor(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
      this.expressID = expressID;
      this.type = type;
      this.SpineCurve = SpineCurve;
      this.CrossSections = CrossSections;
      this.CrossSectionPositions = CrossSectionPositions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SpineCurve = tape[ptr++];
      let CrossSections = tape[ptr++];
      let CrossSectionPositions = tape[ptr++];
      return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions);
    }
    ToTape() {
      let args = [];
      args.push(this.SpineCurve);
      args.push(this.CrossSections);
      args.push(this.CrossSectionPositions);
      return args;
    }
  };
  var IfcSensor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSensorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcShadingDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcShadingDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcShapeAspect = class {
    constructor(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
      this.expressID = expressID;
      this.type = type;
      this.ShapeRepresentations = ShapeRepresentations;
      this.Name = Name;
      this.Description = Description;
      this.ProductDefinitional = ProductDefinitional;
      this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ShapeRepresentations = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ProductDefinitional = tape[ptr++];
      let PartOfProductDefinitionShape = tape[ptr++];
      return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
    }
    ToTape() {
      let args = [];
      args.push(this.ShapeRepresentations);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ProductDefinitional);
      args.push(this.PartOfProductDefinitionShape);
      return args;
    }
  };
  var IfcShapeModel = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      args.push(this.RepresentationIdentifier);
      args.push(this.RepresentationType);
      args.push(this.Items);
      return args;
    }
  };
  var IfcShapeRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      args.push(this.RepresentationIdentifier);
      args.push(this.RepresentationType);
      args.push(this.Items);
      return args;
    }
  };
  var IfcShellBasedSurfaceModel = class {
    constructor(expressID, type, SbsmBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.SbsmBoundary = SbsmBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SbsmBoundary = tape[ptr++];
      return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.SbsmBoundary);
      return args;
    }
  };
  var IfcSimpleProperty = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcSimpleProperty(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      return args;
    }
  };
  var IfcSimplePropertyTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.TemplateType = TemplateType;
      this.PrimaryMeasureType = PrimaryMeasureType;
      this.SecondaryMeasureType = SecondaryMeasureType;
      this.Enumerators = Enumerators;
      this.PrimaryUnit = PrimaryUnit;
      this.SecondaryUnit = SecondaryUnit;
      this.Expression = Expression;
      this.AccessState = AccessState;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let TemplateType = tape[ptr++];
      let PrimaryMeasureType = tape[ptr++];
      let SecondaryMeasureType = tape[ptr++];
      let Enumerators = tape[ptr++];
      let PrimaryUnit = tape[ptr++];
      let SecondaryUnit = tape[ptr++];
      let Expression = tape[ptr++];
      let AccessState = tape[ptr++];
      return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.TemplateType);
      args.push(this.PrimaryMeasureType);
      args.push(this.SecondaryMeasureType);
      args.push(this.Enumerators);
      args.push(this.PrimaryUnit);
      args.push(this.SecondaryUnit);
      args.push(this.Expression);
      args.push(this.AccessState);
      return args;
    }
  };
  var IfcSite = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.RefLatitude = RefLatitude;
      this.RefLongitude = RefLongitude;
      this.RefElevation = RefElevation;
      this.LandTitleNumber = LandTitleNumber;
      this.SiteAddress = SiteAddress;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let RefLatitude = tape[ptr++];
      let RefLongitude = tape[ptr++];
      let RefElevation = tape[ptr++];
      let LandTitleNumber = tape[ptr++];
      let SiteAddress = tape[ptr++];
      return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      args.push(this.RefLatitude);
      args.push(this.RefLongitude);
      args.push(this.RefElevation);
      args.push(this.LandTitleNumber);
      args.push(this.SiteAddress);
      return args;
    }
  };
  var IfcSlab = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSlabElementedCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSlabStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSlabType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSlippageConnectionCondition = class {
    constructor(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.SlippageX = SlippageX;
      this.SlippageY = SlippageY;
      this.SlippageZ = SlippageZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let SlippageX = tape[ptr++];
      let SlippageY = tape[ptr++];
      let SlippageZ = tape[ptr++];
      return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.SlippageX);
      args.push(this.SlippageY);
      args.push(this.SlippageZ);
      return args;
    }
  };
  var IfcSolarDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSolarDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSolidModel = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcSolidModel(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcSpace = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.PredefinedType = PredefinedType;
      this.ElevationWithFlooring = ElevationWithFlooring;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ElevationWithFlooring = tape[ptr++];
      return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      args.push(this.PredefinedType);
      args.push(this.ElevationWithFlooring);
      return args;
    }
  };
  var IfcSpaceHeater = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSpaceHeaterType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSpaceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.LongName);
      return args;
    }
  };
  var IfcSpatialElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      return args;
    }
  };
  var IfcSpatialElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcSpatialStructureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.CompositionType);
      return args;
    }
  };
  var IfcSpatialStructureElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      return args;
    }
  };
  var IfcSpatialZone = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.LongName);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSpatialZoneType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.LongName);
      return args;
    }
  };
  var IfcSphere = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcSphere(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.Radius);
      return args;
    }
  };
  var IfcSphericalSurface = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcSphericalSurface(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.Radius);
      return args;
    }
  };
  var IfcStackTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStackTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStair = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStairFlight = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.NumberOfRisers = NumberOfRisers;
      this.NumberOfTreads = NumberOfTreads;
      this.RiserHeight = RiserHeight;
      this.TreadLength = TreadLength;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let NumberOfRisers = tape[ptr++];
      let NumberOfTreads = tape[ptr++];
      let RiserHeight = tape[ptr++];
      let TreadLength = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.NumberOfRisers);
      args.push(this.NumberOfTreads);
      args.push(this.RiserHeight);
      args.push(this.TreadLength);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStairFlightType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStairType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStructuralAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.DestabilizingLoad);
      return args;
    }
  };
  var IfcStructuralActivity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      return args;
    }
  };
  var IfcStructuralAnalysisModel = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.OrientationOf2DPlane = OrientationOf2DPlane;
      this.LoadedBy = LoadedBy;
      this.HasResults = HasResults;
      this.SharedPlacement = SharedPlacement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OrientationOf2DPlane = tape[ptr++];
      let LoadedBy = tape[ptr++];
      let HasResults = tape[ptr++];
      let SharedPlacement = tape[ptr++];
      return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.PredefinedType);
      args.push(this.OrientationOf2DPlane);
      args.push(this.LoadedBy);
      args.push(this.HasResults);
      args.push(this.SharedPlacement);
      return args;
    }
  };
  var IfcStructuralConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedCondition);
      return args;
    }
  };
  var IfcStructuralConnectionCondition = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralConnectionCondition(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcStructuralCurveAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.DestabilizingLoad);
      args.push(this.ProjectedOrTrue);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStructuralCurveConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedCondition);
      args.push(this.Axis);
      return args;
    }
  };
  var IfcStructuralCurveMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.PredefinedType);
      args.push(this.Axis);
      return args;
    }
  };
  var IfcStructuralCurveMemberVarying = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.PredefinedType);
      args.push(this.Axis);
      return args;
    }
  };
  var IfcStructuralCurveReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStructuralItem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      return args;
    }
  };
  var IfcStructuralLinearAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.DestabilizingLoad);
      args.push(this.ProjectedOrTrue);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStructuralLoad = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralLoad(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcStructuralLoadCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.ActionType = ActionType;
      this.ActionSource = ActionSource;
      this.Coefficient = Coefficient;
      this.Purpose = Purpose;
      this.SelfWeightCoefficients = SelfWeightCoefficients;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ActionType = tape[ptr++];
      let ActionSource = tape[ptr++];
      let Coefficient = tape[ptr++];
      let Purpose = tape[ptr++];
      let SelfWeightCoefficients = tape[ptr++];
      return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.PredefinedType);
      args.push(this.ActionType);
      args.push(this.ActionSource);
      args.push(this.Coefficient);
      args.push(this.Purpose);
      args.push(this.SelfWeightCoefficients);
      return args;
    }
  };
  var IfcStructuralLoadConfiguration = class {
    constructor(expressID, type, Name, Values, Locations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Values = Values;
      this.Locations = Locations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Values = tape[ptr++];
      let Locations = tape[ptr++];
      return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Values);
      args.push(this.Locations);
      return args;
    }
  };
  var IfcStructuralLoadGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.ActionType = ActionType;
      this.ActionSource = ActionSource;
      this.Coefficient = Coefficient;
      this.Purpose = Purpose;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ActionType = tape[ptr++];
      let ActionSource = tape[ptr++];
      let Coefficient = tape[ptr++];
      let Purpose = tape[ptr++];
      return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.PredefinedType);
      args.push(this.ActionType);
      args.push(this.ActionSource);
      args.push(this.Coefficient);
      args.push(this.Purpose);
      return args;
    }
  };
  var IfcStructuralLoadLinearForce = class {
    constructor(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LinearForceX = LinearForceX;
      this.LinearForceY = LinearForceY;
      this.LinearForceZ = LinearForceZ;
      this.LinearMomentX = LinearMomentX;
      this.LinearMomentY = LinearMomentY;
      this.LinearMomentZ = LinearMomentZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LinearForceX = tape[ptr++];
      let LinearForceY = tape[ptr++];
      let LinearForceZ = tape[ptr++];
      let LinearMomentX = tape[ptr++];
      let LinearMomentY = tape[ptr++];
      let LinearMomentZ = tape[ptr++];
      return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.LinearForceX);
      args.push(this.LinearForceY);
      args.push(this.LinearForceZ);
      args.push(this.LinearMomentX);
      args.push(this.LinearMomentY);
      args.push(this.LinearMomentZ);
      return args;
    }
  };
  var IfcStructuralLoadOrResult = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralLoadOrResult(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcStructuralLoadPlanarForce = class {
    constructor(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.PlanarForceX = PlanarForceX;
      this.PlanarForceY = PlanarForceY;
      this.PlanarForceZ = PlanarForceZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let PlanarForceX = tape[ptr++];
      let PlanarForceY = tape[ptr++];
      let PlanarForceZ = tape[ptr++];
      return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.PlanarForceX);
      args.push(this.PlanarForceY);
      args.push(this.PlanarForceZ);
      return args;
    }
  };
  var IfcStructuralLoadSingleDisplacement = class {
    constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DisplacementX = DisplacementX;
      this.DisplacementY = DisplacementY;
      this.DisplacementZ = DisplacementZ;
      this.RotationalDisplacementRX = RotationalDisplacementRX;
      this.RotationalDisplacementRY = RotationalDisplacementRY;
      this.RotationalDisplacementRZ = RotationalDisplacementRZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DisplacementX = tape[ptr++];
      let DisplacementY = tape[ptr++];
      let DisplacementZ = tape[ptr++];
      let RotationalDisplacementRX = tape[ptr++];
      let RotationalDisplacementRY = tape[ptr++];
      let RotationalDisplacementRZ = tape[ptr++];
      return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DisplacementX);
      args.push(this.DisplacementY);
      args.push(this.DisplacementZ);
      args.push(this.RotationalDisplacementRX);
      args.push(this.RotationalDisplacementRY);
      args.push(this.RotationalDisplacementRZ);
      return args;
    }
  };
  var IfcStructuralLoadSingleDisplacementDistortion = class {
    constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DisplacementX = DisplacementX;
      this.DisplacementY = DisplacementY;
      this.DisplacementZ = DisplacementZ;
      this.RotationalDisplacementRX = RotationalDisplacementRX;
      this.RotationalDisplacementRY = RotationalDisplacementRY;
      this.RotationalDisplacementRZ = RotationalDisplacementRZ;
      this.Distortion = Distortion;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DisplacementX = tape[ptr++];
      let DisplacementY = tape[ptr++];
      let DisplacementZ = tape[ptr++];
      let RotationalDisplacementRX = tape[ptr++];
      let RotationalDisplacementRY = tape[ptr++];
      let RotationalDisplacementRZ = tape[ptr++];
      let Distortion = tape[ptr++];
      return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DisplacementX);
      args.push(this.DisplacementY);
      args.push(this.DisplacementZ);
      args.push(this.RotationalDisplacementRX);
      args.push(this.RotationalDisplacementRY);
      args.push(this.RotationalDisplacementRZ);
      args.push(this.Distortion);
      return args;
    }
  };
  var IfcStructuralLoadSingleForce = class {
    constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.ForceX = ForceX;
      this.ForceY = ForceY;
      this.ForceZ = ForceZ;
      this.MomentX = MomentX;
      this.MomentY = MomentY;
      this.MomentZ = MomentZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let ForceX = tape[ptr++];
      let ForceY = tape[ptr++];
      let ForceZ = tape[ptr++];
      let MomentX = tape[ptr++];
      let MomentY = tape[ptr++];
      let MomentZ = tape[ptr++];
      return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.ForceX);
      args.push(this.ForceY);
      args.push(this.ForceZ);
      args.push(this.MomentX);
      args.push(this.MomentY);
      args.push(this.MomentZ);
      return args;
    }
  };
  var IfcStructuralLoadSingleForceWarping = class {
    constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.ForceX = ForceX;
      this.ForceY = ForceY;
      this.ForceZ = ForceZ;
      this.MomentX = MomentX;
      this.MomentY = MomentY;
      this.MomentZ = MomentZ;
      this.WarpingMoment = WarpingMoment;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let ForceX = tape[ptr++];
      let ForceY = tape[ptr++];
      let ForceZ = tape[ptr++];
      let MomentX = tape[ptr++];
      let MomentY = tape[ptr++];
      let MomentZ = tape[ptr++];
      let WarpingMoment = tape[ptr++];
      return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.ForceX);
      args.push(this.ForceY);
      args.push(this.ForceZ);
      args.push(this.MomentX);
      args.push(this.MomentY);
      args.push(this.MomentZ);
      args.push(this.WarpingMoment);
      return args;
    }
  };
  var IfcStructuralLoadStatic = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralLoadStatic(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      return args;
    }
  };
  var IfcStructuralLoadTemperature = class {
    constructor(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DeltaTConstant = DeltaTConstant;
      this.DeltaTY = DeltaTY;
      this.DeltaTZ = DeltaTZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DeltaTConstant = tape[ptr++];
      let DeltaTY = tape[ptr++];
      let DeltaTZ = tape[ptr++];
      return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DeltaTConstant);
      args.push(this.DeltaTY);
      args.push(this.DeltaTZ);
      return args;
    }
  };
  var IfcStructuralMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      return args;
    }
  };
  var IfcStructuralPlanarAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.DestabilizingLoad);
      args.push(this.ProjectedOrTrue);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStructuralPointAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.DestabilizingLoad);
      return args;
    }
  };
  var IfcStructuralPointConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
      this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let ConditionCoordinateSystem = tape[ptr++];
      return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedCondition);
      args.push(this.ConditionCoordinateSystem);
      return args;
    }
  };
  var IfcStructuralPointReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      return args;
    }
  };
  var IfcStructuralReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      return args;
    }
  };
  var IfcStructuralResultGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.TheoryType = TheoryType;
      this.ResultForLoadGroup = ResultForLoadGroup;
      this.IsLinear = IsLinear;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let TheoryType = tape[ptr++];
      let ResultForLoadGroup = tape[ptr++];
      let IsLinear = tape[ptr++];
      return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.TheoryType);
      args.push(this.ResultForLoadGroup);
      args.push(this.IsLinear);
      return args;
    }
  };
  var IfcStructuralSurfaceAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.DestabilizingLoad);
      args.push(this.ProjectedOrTrue);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStructuralSurfaceConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedCondition);
      return args;
    }
  };
  var IfcStructuralSurfaceMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Thickness = Thickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Thickness = tape[ptr++];
      return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.PredefinedType);
      args.push(this.Thickness);
      return args;
    }
  };
  var IfcStructuralSurfaceMemberVarying = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Thickness = Thickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Thickness = tape[ptr++];
      return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.PredefinedType);
      args.push(this.Thickness);
      return args;
    }
  };
  var IfcStructuralSurfaceReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.AppliedLoad);
      args.push(this.GlobalOrLocal);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcStyleModel = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      args.push(this.RepresentationIdentifier);
      args.push(this.RepresentationType);
      args.push(this.Items);
      return args;
    }
  };
  var IfcStyledItem = class {
    constructor(expressID, type, Item, Styles, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Item = Item;
      this.Styles = Styles;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Item = tape[ptr++];
      let Styles = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcStyledItem(expressID, type, Item, Styles, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Item);
      args.push(this.Styles);
      args.push(this.Name);
      return args;
    }
  };
  var IfcStyledRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      args.push(this.RepresentationIdentifier);
      args.push(this.RepresentationType);
      args.push(this.Items);
      return args;
    }
  };
  var IfcSubContractResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Usage);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSubContractResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      args.push(this.BaseCosts);
      args.push(this.BaseQuantity);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSubedge = class {
    constructor(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
      this.ParentEdge = ParentEdge;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      let ParentEdge = tape[ptr++];
      return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      args.push(this.EdgeEnd);
      args.push(this.ParentEdge);
      return args;
    }
  };
  var IfcSurface = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcSurface(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcSurfaceCurve = class {
    constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.Curve3D = Curve3D;
      this.AssociatedGeometry = AssociatedGeometry;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Curve3D = tape[ptr++];
      let AssociatedGeometry = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.Curve3D);
      args.push(this.AssociatedGeometry);
      args.push(this.MasterRepresentation);
      return args;
    }
  };
  var IfcSurfaceCurveSweptAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Directrix = Directrix;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
      this.ReferenceSurface = ReferenceSurface;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Directrix = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      let ReferenceSurface = tape[ptr++];
      return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      args.push(this.Directrix);
      args.push(this.StartParam);
      args.push(this.EndParam);
      args.push(this.ReferenceSurface);
      return args;
    }
  };
  var IfcSurfaceFeature = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSurfaceOfLinearExtrusion = class {
    constructor(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
      this.expressID = expressID;
      this.type = type;
      this.SweptCurve = SweptCurve;
      this.Position = Position;
      this.ExtrudedDirection = ExtrudedDirection;
      this.Depth = Depth;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptCurve = tape[ptr++];
      let Position = tape[ptr++];
      let ExtrudedDirection = tape[ptr++];
      let Depth = tape[ptr++];
      return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptCurve);
      args.push(this.Position);
      args.push(this.ExtrudedDirection);
      args.push(this.Depth);
      return args;
    }
  };
  var IfcSurfaceOfRevolution = class {
    constructor(expressID, type, SweptCurve, Position, AxisPosition) {
      this.expressID = expressID;
      this.type = type;
      this.SweptCurve = SweptCurve;
      this.Position = Position;
      this.AxisPosition = AxisPosition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptCurve = tape[ptr++];
      let Position = tape[ptr++];
      let AxisPosition = tape[ptr++];
      return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptCurve);
      args.push(this.Position);
      args.push(this.AxisPosition);
      return args;
    }
  };
  var IfcSurfaceReinforcementArea = class {
    constructor(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.SurfaceReinforcement1 = SurfaceReinforcement1;
      this.SurfaceReinforcement2 = SurfaceReinforcement2;
      this.ShearReinforcement = ShearReinforcement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let SurfaceReinforcement1 = tape[ptr++];
      let SurfaceReinforcement2 = tape[ptr++];
      let ShearReinforcement = tape[ptr++];
      return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.SurfaceReinforcement1);
      args.push(this.SurfaceReinforcement2);
      args.push(this.ShearReinforcement);
      return args;
    }
  };
  var IfcSurfaceStyle = class {
    constructor(expressID, type, Name, Side, Styles) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Side = Side;
      this.Styles = Styles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Side = tape[ptr++];
      let Styles = tape[ptr++];
      return new IfcSurfaceStyle(expressID, type, Name, Side, Styles);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Side);
      args.push(this.Styles);
      return args;
    }
  };
  var IfcSurfaceStyleLighting = class {
    constructor(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
      this.expressID = expressID;
      this.type = type;
      this.DiffuseTransmissionColour = DiffuseTransmissionColour;
      this.DiffuseReflectionColour = DiffuseReflectionColour;
      this.TransmissionColour = TransmissionColour;
      this.ReflectanceColour = ReflectanceColour;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let DiffuseTransmissionColour = tape[ptr++];
      let DiffuseReflectionColour = tape[ptr++];
      let TransmissionColour = tape[ptr++];
      let ReflectanceColour = tape[ptr++];
      return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
    }
    ToTape() {
      let args = [];
      args.push(this.DiffuseTransmissionColour);
      args.push(this.DiffuseReflectionColour);
      args.push(this.TransmissionColour);
      args.push(this.ReflectanceColour);
      return args;
    }
  };
  var IfcSurfaceStyleRefraction = class {
    constructor(expressID, type, RefractionIndex, DispersionFactor) {
      this.expressID = expressID;
      this.type = type;
      this.RefractionIndex = RefractionIndex;
      this.DispersionFactor = DispersionFactor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RefractionIndex = tape[ptr++];
      let DispersionFactor = tape[ptr++];
      return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor);
    }
    ToTape() {
      let args = [];
      args.push(this.RefractionIndex);
      args.push(this.DispersionFactor);
      return args;
    }
  };
  var IfcSurfaceStyleRendering = class {
    constructor(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
      this.expressID = expressID;
      this.type = type;
      this.SurfaceColour = SurfaceColour;
      this.Transparency = Transparency;
      this.DiffuseColour = DiffuseColour;
      this.TransmissionColour = TransmissionColour;
      this.DiffuseTransmissionColour = DiffuseTransmissionColour;
      this.ReflectionColour = ReflectionColour;
      this.SpecularColour = SpecularColour;
      this.SpecularHighlight = SpecularHighlight;
      this.ReflectanceMethod = ReflectanceMethod;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SurfaceColour = tape[ptr++];
      let Transparency = tape[ptr++];
      let DiffuseColour = tape[ptr++];
      let TransmissionColour = tape[ptr++];
      let DiffuseTransmissionColour = tape[ptr++];
      let ReflectionColour = tape[ptr++];
      let SpecularColour = tape[ptr++];
      let SpecularHighlight = tape[ptr++];
      let ReflectanceMethod = tape[ptr++];
      return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
    }
    ToTape() {
      let args = [];
      args.push(this.SurfaceColour);
      args.push(this.Transparency);
      args.push(this.DiffuseColour);
      args.push(this.TransmissionColour);
      args.push(this.DiffuseTransmissionColour);
      args.push(this.ReflectionColour);
      args.push(this.SpecularColour);
      args.push(this.SpecularHighlight);
      args.push(this.ReflectanceMethod);
      return args;
    }
  };
  var IfcSurfaceStyleShading = class {
    constructor(expressID, type, SurfaceColour, Transparency) {
      this.expressID = expressID;
      this.type = type;
      this.SurfaceColour = SurfaceColour;
      this.Transparency = Transparency;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SurfaceColour = tape[ptr++];
      let Transparency = tape[ptr++];
      return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency);
    }
    ToTape() {
      let args = [];
      args.push(this.SurfaceColour);
      args.push(this.Transparency);
      return args;
    }
  };
  var IfcSurfaceStyleWithTextures = class {
    constructor(expressID, type, Textures) {
      this.expressID = expressID;
      this.type = type;
      this.Textures = Textures;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Textures = tape[ptr++];
      return new IfcSurfaceStyleWithTextures(expressID, type, Textures);
    }
    ToTape() {
      let args = [];
      args.push(this.Textures);
      return args;
    }
  };
  var IfcSurfaceTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      args.push(this.RepeatT);
      args.push(this.Mode);
      args.push(this.TextureTransform);
      args.push(this.Parameter);
      return args;
    }
  };
  var IfcSweptAreaSolid = class {
    constructor(expressID, type, SweptArea, Position) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      return new IfcSweptAreaSolid(expressID, type, SweptArea, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      args.push(this.Position);
      return args;
    }
  };
  var IfcSweptDiskSolid = class {
    constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.Radius = Radius;
      this.InnerRadius = InnerRadius;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let Radius = tape[ptr++];
      let InnerRadius = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      args.push(this.Radius);
      args.push(this.InnerRadius);
      args.push(this.StartParam);
      args.push(this.EndParam);
      return args;
    }
  };
  var IfcSweptDiskSolidPolygonal = class {
    constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.Radius = Radius;
      this.InnerRadius = InnerRadius;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
      this.FilletRadius = FilletRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let Radius = tape[ptr++];
      let InnerRadius = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      let FilletRadius = tape[ptr++];
      return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      args.push(this.Radius);
      args.push(this.InnerRadius);
      args.push(this.StartParam);
      args.push(this.EndParam);
      args.push(this.FilletRadius);
      return args;
    }
  };
  var IfcSweptSurface = class {
    constructor(expressID, type, SweptCurve, Position) {
      this.expressID = expressID;
      this.type = type;
      this.SweptCurve = SweptCurve;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptCurve = tape[ptr++];
      let Position = tape[ptr++];
      return new IfcSweptSurface(expressID, type, SweptCurve, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptCurve);
      args.push(this.Position);
      return args;
    }
  };
  var IfcSwitchingDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSwitchingDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSystem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      return args;
    }
  };
  var IfcSystemFurnitureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcSystemFurnitureElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.FlangeWidth = FlangeWidth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.FlangeEdgeRadius = FlangeEdgeRadius;
      this.WebEdgeRadius = WebEdgeRadius;
      this.WebSlope = WebSlope;
      this.FlangeSlope = FlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let FlangeWidth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let FlangeEdgeRadius = tape[ptr++];
      let WebEdgeRadius = tape[ptr++];
      let WebSlope = tape[ptr++];
      let FlangeSlope = tape[ptr++];
      return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Depth);
      args.push(this.FlangeWidth);
      args.push(this.WebThickness);
      args.push(this.FlangeThickness);
      args.push(this.FilletRadius);
      args.push(this.FlangeEdgeRadius);
      args.push(this.WebEdgeRadius);
      args.push(this.WebSlope);
      args.push(this.FlangeSlope);
      return args;
    }
  };
  var IfcTable = class {
    constructor(expressID, type, Name, Rows, Columns) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Rows = Rows;
      this.Columns = Columns;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Rows = tape[ptr++];
      let Columns = tape[ptr++];
      return new IfcTable(expressID, type, Name, Rows, Columns);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Rows);
      args.push(this.Columns);
      return args;
    }
  };
  var IfcTableColumn = class {
    constructor(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
      this.expressID = expressID;
      this.type = type;
      this.Identifier = Identifier;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.ReferencePath = ReferencePath;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identifier = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let ReferencePath = tape[ptr++];
      return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath);
    }
    ToTape() {
      let args = [];
      args.push(this.Identifier);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.Unit);
      args.push(this.ReferencePath);
      return args;
    }
  };
  var IfcTableRow = class {
    constructor(expressID, type, RowCells, IsHeading) {
      this.expressID = expressID;
      this.type = type;
      this.RowCells = RowCells;
      this.IsHeading = IsHeading;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RowCells = tape[ptr++];
      let IsHeading = tape[ptr++];
      return new IfcTableRow(expressID, type, RowCells, IsHeading);
    }
    ToTape() {
      let args = [];
      args.push(this.RowCells);
      args.push(this.IsHeading);
      return args;
    }
  };
  var IfcTank = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTankType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTask = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Status = Status;
      this.WorkMethod = WorkMethod;
      this.IsMilestone = IsMilestone;
      this.Priority = Priority;
      this.TaskTime = TaskTime;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Status = tape[ptr++];
      let WorkMethod = tape[ptr++];
      let IsMilestone = tape[ptr++];
      let Priority = tape[ptr++];
      let TaskTime = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.Status);
      args.push(this.WorkMethod);
      args.push(this.IsMilestone);
      args.push(this.Priority);
      args.push(this.TaskTime);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTaskTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.DurationType = DurationType;
      this.ScheduleDuration = ScheduleDuration;
      this.ScheduleStart = ScheduleStart;
      this.ScheduleFinish = ScheduleFinish;
      this.EarlyStart = EarlyStart;
      this.EarlyFinish = EarlyFinish;
      this.LateStart = LateStart;
      this.LateFinish = LateFinish;
      this.FreeFloat = FreeFloat;
      this.TotalFloat = TotalFloat;
      this.IsCritical = IsCritical;
      this.StatusTime = StatusTime;
      this.ActualDuration = ActualDuration;
      this.ActualStart = ActualStart;
      this.ActualFinish = ActualFinish;
      this.RemainingTime = RemainingTime;
      this.Completion = Completion;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let DurationType = tape[ptr++];
      let ScheduleDuration = tape[ptr++];
      let ScheduleStart = tape[ptr++];
      let ScheduleFinish = tape[ptr++];
      let EarlyStart = tape[ptr++];
      let EarlyFinish = tape[ptr++];
      let LateStart = tape[ptr++];
      let LateFinish = tape[ptr++];
      let FreeFloat = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let IsCritical = tape[ptr++];
      let StatusTime = tape[ptr++];
      let ActualDuration = tape[ptr++];
      let ActualStart = tape[ptr++];
      let ActualFinish = tape[ptr++];
      let RemainingTime = tape[ptr++];
      let Completion = tape[ptr++];
      return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.DurationType);
      args.push(this.ScheduleDuration);
      args.push(this.ScheduleStart);
      args.push(this.ScheduleFinish);
      args.push(this.EarlyStart);
      args.push(this.EarlyFinish);
      args.push(this.LateStart);
      args.push(this.LateFinish);
      args.push(this.FreeFloat);
      args.push(this.TotalFloat);
      args.push(this.IsCritical);
      args.push(this.StatusTime);
      args.push(this.ActualDuration);
      args.push(this.ActualStart);
      args.push(this.ActualFinish);
      args.push(this.RemainingTime);
      args.push(this.Completion);
      return args;
    }
  };
  var IfcTaskTimeRecurring = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.DurationType = DurationType;
      this.ScheduleDuration = ScheduleDuration;
      this.ScheduleStart = ScheduleStart;
      this.ScheduleFinish = ScheduleFinish;
      this.EarlyStart = EarlyStart;
      this.EarlyFinish = EarlyFinish;
      this.LateStart = LateStart;
      this.LateFinish = LateFinish;
      this.FreeFloat = FreeFloat;
      this.TotalFloat = TotalFloat;
      this.IsCritical = IsCritical;
      this.StatusTime = StatusTime;
      this.ActualDuration = ActualDuration;
      this.ActualStart = ActualStart;
      this.ActualFinish = ActualFinish;
      this.RemainingTime = RemainingTime;
      this.Completion = Completion;
      this.Recurrence = Recurrence;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let DurationType = tape[ptr++];
      let ScheduleDuration = tape[ptr++];
      let ScheduleStart = tape[ptr++];
      let ScheduleFinish = tape[ptr++];
      let EarlyStart = tape[ptr++];
      let EarlyFinish = tape[ptr++];
      let LateStart = tape[ptr++];
      let LateFinish = tape[ptr++];
      let FreeFloat = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let IsCritical = tape[ptr++];
      let StatusTime = tape[ptr++];
      let ActualDuration = tape[ptr++];
      let ActualStart = tape[ptr++];
      let ActualFinish = tape[ptr++];
      let RemainingTime = tape[ptr++];
      let Completion = tape[ptr++];
      let Recurrence = tape[ptr++];
      return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.DurationType);
      args.push(this.ScheduleDuration);
      args.push(this.ScheduleStart);
      args.push(this.ScheduleFinish);
      args.push(this.EarlyStart);
      args.push(this.EarlyFinish);
      args.push(this.LateStart);
      args.push(this.LateFinish);
      args.push(this.FreeFloat);
      args.push(this.TotalFloat);
      args.push(this.IsCritical);
      args.push(this.StatusTime);
      args.push(this.ActualDuration);
      args.push(this.ActualStart);
      args.push(this.ActualFinish);
      args.push(this.RemainingTime);
      args.push(this.Completion);
      args.push(this.Recurrence);
      return args;
    }
  };
  var IfcTaskType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
      this.PredefinedType = PredefinedType;
      this.WorkMethod = WorkMethod;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let WorkMethod = tape[ptr++];
      return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ProcessType);
      args.push(this.PredefinedType);
      args.push(this.WorkMethod);
      return args;
    }
  };
  var IfcTelecomAddress = class {
    constructor(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
      this.expressID = expressID;
      this.type = type;
      this.Purpose = Purpose;
      this.Description = Description;
      this.UserDefinedPurpose = UserDefinedPurpose;
      this.TelephoneNumbers = TelephoneNumbers;
      this.FacsimileNumbers = FacsimileNumbers;
      this.PagerNumber = PagerNumber;
      this.ElectronicMailAddresses = ElectronicMailAddresses;
      this.WWWHomePageURL = WWWHomePageURL;
      this.MessagingIDs = MessagingIDs;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Purpose = tape[ptr++];
      let Description = tape[ptr++];
      let UserDefinedPurpose = tape[ptr++];
      let TelephoneNumbers = tape[ptr++];
      let FacsimileNumbers = tape[ptr++];
      let PagerNumber = tape[ptr++];
      let ElectronicMailAddresses = tape[ptr++];
      let WWWHomePageURL = tape[ptr++];
      let MessagingIDs = tape[ptr++];
      return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
    }
    ToTape() {
      let args = [];
      args.push(this.Purpose);
      args.push(this.Description);
      args.push(this.UserDefinedPurpose);
      args.push(this.TelephoneNumbers);
      args.push(this.FacsimileNumbers);
      args.push(this.PagerNumber);
      args.push(this.ElectronicMailAddresses);
      args.push(this.WWWHomePageURL);
      args.push(this.MessagingIDs);
      return args;
    }
  };
  var IfcTendon = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.TensionForce = TensionForce;
      this.PreStress = PreStress;
      this.FrictionCoefficient = FrictionCoefficient;
      this.AnchorageSlip = AnchorageSlip;
      this.MinCurvatureRadius = MinCurvatureRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let TensionForce = tape[ptr++];
      let PreStress = tape[ptr++];
      let FrictionCoefficient = tape[ptr++];
      let AnchorageSlip = tape[ptr++];
      let MinCurvatureRadius = tape[ptr++];
      return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.SteelGrade);
      args.push(this.PredefinedType);
      args.push(this.NominalDiameter);
      args.push(this.CrossSectionArea);
      args.push(this.TensionForce);
      args.push(this.PreStress);
      args.push(this.FrictionCoefficient);
      args.push(this.AnchorageSlip);
      args.push(this.MinCurvatureRadius);
      return args;
    }
  };
  var IfcTendonAnchor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.SteelGrade);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTendonAnchorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTendonConduit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.SteelGrade);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTendonConduitType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTendonType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.SheathDiameter = SheathDiameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let SheathDiameter = tape[ptr++];
      return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.NominalDiameter);
      args.push(this.CrossSectionArea);
      args.push(this.SheathDiameter);
      return args;
    }
  };
  var IfcTessellatedFaceSet = class {
    constructor(expressID, type, Coordinates) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      return new IfcTessellatedFaceSet(expressID, type, Coordinates);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      return args;
    }
  };
  var IfcTessellatedItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcTessellatedItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcTextLiteral = class {
    constructor(expressID, type, Literal, Placement, Path) {
      this.expressID = expressID;
      this.type = type;
      this.Literal = Literal;
      this.Placement = Placement;
      this.Path = Path;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Literal = tape[ptr++];
      let Placement = tape[ptr++];
      let Path = tape[ptr++];
      return new IfcTextLiteral(expressID, type, Literal, Placement, Path);
    }
    ToTape() {
      let args = [];
      args.push(this.Literal);
      args.push(this.Placement);
      args.push(this.Path);
      return args;
    }
  };
  var IfcTextLiteralWithExtent = class {
    constructor(expressID, type, Literal, Placement, Path, Extent, BoxAlignment) {
      this.expressID = expressID;
      this.type = type;
      this.Literal = Literal;
      this.Placement = Placement;
      this.Path = Path;
      this.Extent = Extent;
      this.BoxAlignment = BoxAlignment;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Literal = tape[ptr++];
      let Placement = tape[ptr++];
      let Path = tape[ptr++];
      let Extent = tape[ptr++];
      let BoxAlignment = tape[ptr++];
      return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment);
    }
    ToTape() {
      let args = [];
      args.push(this.Literal);
      args.push(this.Placement);
      args.push(this.Path);
      args.push(this.Extent);
      args.push(this.BoxAlignment);
      return args;
    }
  };
  var IfcTextStyle = class {
    constructor(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TextCharacterAppearance = TextCharacterAppearance;
      this.TextStyle = TextStyle;
      this.TextFontStyle = TextFontStyle;
      this.ModelOrDraughting = ModelOrDraughting;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TextCharacterAppearance = tape[ptr++];
      let TextStyle = tape[ptr++];
      let TextFontStyle = tape[ptr++];
      let ModelOrDraughting = tape[ptr++];
      return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.TextCharacterAppearance);
      args.push(this.TextStyle);
      args.push(this.TextFontStyle);
      args.push(this.ModelOrDraughting);
      return args;
    }
  };
  var IfcTextStyleFontModel = class {
    constructor(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.FontFamily = FontFamily;
      this.FontStyle = FontStyle;
      this.FontVariant = FontVariant;
      this.FontWeight = FontWeight;
      this.FontSize = FontSize;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let FontFamily = tape[ptr++];
      let FontStyle = tape[ptr++];
      let FontVariant = tape[ptr++];
      let FontWeight = tape[ptr++];
      let FontSize = tape[ptr++];
      return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.FontFamily);
      args.push(this.FontStyle);
      args.push(this.FontVariant);
      args.push(this.FontWeight);
      args.push(this.FontSize);
      return args;
    }
  };
  var IfcTextStyleForDefinedFont = class {
    constructor(expressID, type, Colour, BackgroundColour) {
      this.expressID = expressID;
      this.type = type;
      this.Colour = Colour;
      this.BackgroundColour = BackgroundColour;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Colour = tape[ptr++];
      let BackgroundColour = tape[ptr++];
      return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour);
    }
    ToTape() {
      let args = [];
      args.push(this.Colour);
      args.push(this.BackgroundColour);
      return args;
    }
  };
  var IfcTextStyleTextModel = class {
    constructor(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
      this.expressID = expressID;
      this.type = type;
      this.TextIndent = TextIndent;
      this.TextAlign = TextAlign;
      this.TextDecoration = TextDecoration;
      this.LetterSpacing = LetterSpacing;
      this.WordSpacing = WordSpacing;
      this.TextTransform = TextTransform;
      this.LineHeight = LineHeight;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TextIndent = tape[ptr++];
      let TextAlign = tape[ptr++];
      let TextDecoration = tape[ptr++];
      let LetterSpacing = tape[ptr++];
      let WordSpacing = tape[ptr++];
      let TextTransform = tape[ptr++];
      let LineHeight = tape[ptr++];
      return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
    }
    ToTape() {
      let args = [];
      args.push(this.TextIndent);
      args.push(this.TextAlign);
      args.push(this.TextDecoration);
      args.push(this.LetterSpacing);
      args.push(this.WordSpacing);
      args.push(this.TextTransform);
      args.push(this.LineHeight);
      return args;
    }
  };
  var IfcTextureCoordinate = class {
    constructor(expressID, type, Maps) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      return new IfcTextureCoordinate(expressID, type, Maps);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      return args;
    }
  };
  var IfcTextureCoordinateGenerator = class {
    constructor(expressID, type, Maps, Mode, Parameter) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.Mode = Mode;
      this.Parameter = Parameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let Mode = tape[ptr++];
      let Parameter = tape[ptr++];
      return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      args.push(this.Mode);
      args.push(this.Parameter);
      return args;
    }
  };
  var IfcTextureMap = class {
    constructor(expressID, type, Maps, Vertices, MappedTo) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.Vertices = Vertices;
      this.MappedTo = MappedTo;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let Vertices = tape[ptr++];
      let MappedTo = tape[ptr++];
      return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      args.push(this.Vertices);
      args.push(this.MappedTo);
      return args;
    }
  };
  var IfcTextureVertex = class {
    constructor(expressID, type, Coordinates) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      return new IfcTextureVertex(expressID, type, Coordinates);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      return args;
    }
  };
  var IfcTextureVertexList = class {
    constructor(expressID, type, TexCoordsList) {
      this.expressID = expressID;
      this.type = type;
      this.TexCoordsList = TexCoordsList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TexCoordsList = tape[ptr++];
      return new IfcTextureVertexList(expressID, type, TexCoordsList);
    }
    ToTape() {
      let args = [];
      args.push(this.TexCoordsList);
      return args;
    }
  };
  var IfcTimePeriod = class {
    constructor(expressID, type, StartTime, EndTime) {
      this.expressID = expressID;
      this.type = type;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      return new IfcTimePeriod(expressID, type, StartTime, EndTime);
    }
    ToTape() {
      let args = [];
      args.push(this.StartTime);
      args.push(this.EndTime);
      return args;
    }
  };
  var IfcTimeSeries = class {
    constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
      this.TimeSeriesDataType = TimeSeriesDataType;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      let TimeSeriesDataType = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.StartTime);
      args.push(this.EndTime);
      args.push(this.TimeSeriesDataType);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.Unit);
      return args;
    }
  };
  var IfcTimeSeriesValue = class {
    constructor(expressID, type, ListValues) {
      this.expressID = expressID;
      this.type = type;
      this.ListValues = ListValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ListValues = tape[ptr++];
      return new IfcTimeSeriesValue(expressID, type, ListValues);
    }
    ToTape() {
      let args = [];
      args.push(this.ListValues);
      return args;
    }
  };
  var IfcTopologicalRepresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcTopologicalRepresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcTopologyRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      args.push(this.RepresentationIdentifier);
      args.push(this.RepresentationType);
      args.push(this.Items);
      return args;
    }
  };
  var IfcToroidalSurface = class {
    constructor(expressID, type, Position, MajorRadius, MinorRadius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.MajorRadius = MajorRadius;
      this.MinorRadius = MinorRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let MajorRadius = tape[ptr++];
      let MinorRadius = tape[ptr++];
      return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      args.push(this.MajorRadius);
      args.push(this.MinorRadius);
      return args;
    }
  };
  var IfcTransformer = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTransformerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTransitionCurveSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
      this.StartRadius = StartRadius;
      this.EndRadius = EndRadius;
      this.IsStartRadiusCCW = IsStartRadiusCCW;
      this.IsEndRadiusCCW = IsEndRadiusCCW;
      this.TransitionCurveType = TransitionCurveType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      let StartRadius = tape[ptr++];
      let EndRadius = tape[ptr++];
      let IsStartRadiusCCW = tape[ptr++];
      let IsEndRadiusCCW = tape[ptr++];
      let TransitionCurveType = tape[ptr++];
      return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      args.push(this.StartDirection);
      args.push(this.SegmentLength);
      args.push(this.StartRadius);
      args.push(this.EndRadius);
      args.push(this.IsStartRadiusCCW);
      args.push(this.IsEndRadiusCCW);
      args.push(this.TransitionCurveType);
      return args;
    }
  };
  var IfcTransportElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTransportElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTrapeziumProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.BottomXDim = BottomXDim;
      this.TopXDim = TopXDim;
      this.YDim = YDim;
      this.TopXOffset = TopXOffset;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let BottomXDim = tape[ptr++];
      let TopXDim = tape[ptr++];
      let YDim = tape[ptr++];
      let TopXOffset = tape[ptr++];
      return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.BottomXDim);
      args.push(this.TopXDim);
      args.push(this.YDim);
      args.push(this.TopXOffset);
      return args;
    }
  };
  var IfcTriangulatedFaceSet = class {
    constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
      this.Normals = Normals;
      this.Closed = Closed;
      this.CoordIndex = CoordIndex;
      this.PnIndex = PnIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      let Normals = tape[ptr++];
      let Closed = tape[ptr++];
      let CoordIndex = tape[ptr++];
      let PnIndex = tape[ptr++];
      return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      args.push(this.Normals);
      args.push(this.Closed);
      args.push(this.CoordIndex);
      args.push(this.PnIndex);
      return args;
    }
  };
  var IfcTriangulatedIrregularNetwork = class {
    constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
      this.Normals = Normals;
      this.Closed = Closed;
      this.CoordIndex = CoordIndex;
      this.PnIndex = PnIndex;
      this.Flags = Flags;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      let Normals = tape[ptr++];
      let Closed = tape[ptr++];
      let CoordIndex = tape[ptr++];
      let PnIndex = tape[ptr++];
      let Flags = tape[ptr++];
      return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      args.push(this.Normals);
      args.push(this.Closed);
      args.push(this.CoordIndex);
      args.push(this.PnIndex);
      args.push(this.Flags);
      return args;
    }
  };
  var IfcTrimmedCurve = class {
    constructor(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.Trim1 = Trim1;
      this.Trim2 = Trim2;
      this.SenseAgreement = SenseAgreement;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let Trim1 = tape[ptr++];
      let Trim2 = tape[ptr++];
      let SenseAgreement = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      args.push(this.Trim1);
      args.push(this.Trim2);
      args.push(this.SenseAgreement);
      args.push(this.MasterRepresentation);
      return args;
    }
  };
  var IfcTubeBundle = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTubeBundleType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcTypeObject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      return args;
    }
  };
  var IfcTypeProcess = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ProcessType);
      return args;
    }
  };
  var IfcTypeProduct = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcTypeResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.Identification);
      args.push(this.LongDescription);
      args.push(this.ResourceType);
      return args;
    }
  };
  var IfcUShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.FlangeWidth = FlangeWidth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.EdgeRadius = EdgeRadius;
      this.FlangeSlope = FlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let FlangeWidth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let EdgeRadius = tape[ptr++];
      let FlangeSlope = tape[ptr++];
      return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Depth);
      args.push(this.FlangeWidth);
      args.push(this.WebThickness);
      args.push(this.FlangeThickness);
      args.push(this.FilletRadius);
      args.push(this.EdgeRadius);
      args.push(this.FlangeSlope);
      return args;
    }
  };
  var IfcUnitAssignment = class {
    constructor(expressID, type, Units) {
      this.expressID = expressID;
      this.type = type;
      this.Units = Units;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Units = tape[ptr++];
      return new IfcUnitAssignment(expressID, type, Units);
    }
    ToTape() {
      let args = [];
      args.push(this.Units);
      return args;
    }
  };
  var IfcUnitaryControlElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcUnitaryControlElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcUnitaryEquipment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcUnitaryEquipmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcValve = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcValveType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcVector = class {
    constructor(expressID, type, Orientation, Magnitude) {
      this.expressID = expressID;
      this.type = type;
      this.Orientation = Orientation;
      this.Magnitude = Magnitude;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Orientation = tape[ptr++];
      let Magnitude = tape[ptr++];
      return new IfcVector(expressID, type, Orientation, Magnitude);
    }
    ToTape() {
      let args = [];
      args.push(this.Orientation);
      args.push(this.Magnitude);
      return args;
    }
  };
  var IfcVertex = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      return new IfcVertex(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcVertexLoop = class {
    constructor(expressID, type, LoopVertex) {
      this.expressID = expressID;
      this.type = type;
      this.LoopVertex = LoopVertex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LoopVertex = tape[ptr++];
      return new IfcVertexLoop(expressID, type, LoopVertex);
    }
    ToTape() {
      let args = [];
      args.push(this.LoopVertex);
      return args;
    }
  };
  var IfcVertexPoint = class {
    constructor(expressID, type, VertexGeometry) {
      this.expressID = expressID;
      this.type = type;
      this.VertexGeometry = VertexGeometry;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let VertexGeometry = tape[ptr++];
      return new IfcVertexPoint(expressID, type, VertexGeometry);
    }
    ToTape() {
      let args = [];
      args.push(this.VertexGeometry);
      return args;
    }
  };
  var IfcVibrationDamper = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcVibrationDamperType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcVibrationIsolator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcVibrationIsolatorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcVirtualElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      return args;
    }
  };
  var IfcVirtualGridIntersection = class {
    constructor(expressID, type, IntersectingAxes, OffsetDistances) {
      this.expressID = expressID;
      this.type = type;
      this.IntersectingAxes = IntersectingAxes;
      this.OffsetDistances = OffsetDistances;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let IntersectingAxes = tape[ptr++];
      let OffsetDistances = tape[ptr++];
      return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances);
    }
    ToTape() {
      let args = [];
      args.push(this.IntersectingAxes);
      args.push(this.OffsetDistances);
      return args;
    }
  };
  var IfcVoidingFeature = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWall = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWallElementedCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWallStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWallType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWasteTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWasteTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWindow = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.PartitioningType = PartitioningType;
      this.UserDefinedPartitioningType = UserDefinedPartitioningType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let PartitioningType = tape[ptr++];
      let UserDefinedPartitioningType = tape[ptr++];
      return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.OverallHeight);
      args.push(this.OverallWidth);
      args.push(this.PredefinedType);
      args.push(this.PartitioningType);
      args.push(this.UserDefinedPartitioningType);
      return args;
    }
  };
  var IfcWindowLiningProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.LiningDepth = LiningDepth;
      this.LiningThickness = LiningThickness;
      this.TransomThickness = TransomThickness;
      this.MullionThickness = MullionThickness;
      this.FirstTransomOffset = FirstTransomOffset;
      this.SecondTransomOffset = SecondTransomOffset;
      this.FirstMullionOffset = FirstMullionOffset;
      this.SecondMullionOffset = SecondMullionOffset;
      this.ShapeAspectStyle = ShapeAspectStyle;
      this.LiningOffset = LiningOffset;
      this.LiningToPanelOffsetX = LiningToPanelOffsetX;
      this.LiningToPanelOffsetY = LiningToPanelOffsetY;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let LiningDepth = tape[ptr++];
      let LiningThickness = tape[ptr++];
      let TransomThickness = tape[ptr++];
      let MullionThickness = tape[ptr++];
      let FirstTransomOffset = tape[ptr++];
      let SecondTransomOffset = tape[ptr++];
      let FirstMullionOffset = tape[ptr++];
      let SecondMullionOffset = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      let LiningOffset = tape[ptr++];
      let LiningToPanelOffsetX = tape[ptr++];
      let LiningToPanelOffsetY = tape[ptr++];
      return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.LiningDepth);
      args.push(this.LiningThickness);
      args.push(this.TransomThickness);
      args.push(this.MullionThickness);
      args.push(this.FirstTransomOffset);
      args.push(this.SecondTransomOffset);
      args.push(this.FirstMullionOffset);
      args.push(this.SecondMullionOffset);
      args.push(this.ShapeAspectStyle);
      args.push(this.LiningOffset);
      args.push(this.LiningToPanelOffsetX);
      args.push(this.LiningToPanelOffsetY);
      return args;
    }
  };
  var IfcWindowPanelProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.OperationType = OperationType;
      this.PanelPosition = PanelPosition;
      this.FrameDepth = FrameDepth;
      this.FrameThickness = FrameThickness;
      this.ShapeAspectStyle = ShapeAspectStyle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let OperationType = tape[ptr++];
      let PanelPosition = tape[ptr++];
      let FrameDepth = tape[ptr++];
      let FrameThickness = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.OperationType);
      args.push(this.PanelPosition);
      args.push(this.FrameDepth);
      args.push(this.FrameThickness);
      args.push(this.ShapeAspectStyle);
      return args;
    }
  };
  var IfcWindowStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.PartitioningType = PartitioningType;
      this.UserDefinedPartitioningType = UserDefinedPartitioningType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let PartitioningType = tape[ptr++];
      let UserDefinedPartitioningType = tape[ptr++];
      return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.ObjectPlacement);
      args.push(this.Representation);
      args.push(this.Tag);
      args.push(this.OverallHeight);
      args.push(this.OverallWidth);
      args.push(this.PredefinedType);
      args.push(this.PartitioningType);
      args.push(this.UserDefinedPartitioningType);
      return args;
    }
  };
  var IfcWindowStyle = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ConstructionType = ConstructionType;
      this.OperationType = OperationType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.Sizeable = Sizeable;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ConstructionType = tape[ptr++];
      let OperationType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let Sizeable = tape[ptr++];
      return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ConstructionType);
      args.push(this.OperationType);
      args.push(this.ParameterTakesPrecedence);
      args.push(this.Sizeable);
      return args;
    }
  };
  var IfcWindowType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.PartitioningType = PartitioningType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.UserDefinedPartitioningType = UserDefinedPartitioningType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let PartitioningType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let UserDefinedPartitioningType = tape[ptr++];
      return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ApplicableOccurrence);
      args.push(this.HasPropertySets);
      args.push(this.RepresentationMaps);
      args.push(this.Tag);
      args.push(this.ElementType);
      args.push(this.PredefinedType);
      args.push(this.PartitioningType);
      args.push(this.ParameterTakesPrecedence);
      args.push(this.UserDefinedPartitioningType);
      return args;
    }
  };
  var IfcWorkCalendar = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.WorkingTimes = WorkingTimes;
      this.ExceptionTimes = ExceptionTimes;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let WorkingTimes = tape[ptr++];
      let ExceptionTimes = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.WorkingTimes);
      args.push(this.ExceptionTimes);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWorkControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.CreationDate = CreationDate;
      this.Creators = Creators;
      this.Purpose = Purpose;
      this.Duration = Duration;
      this.TotalFloat = TotalFloat;
      this.StartTime = StartTime;
      this.FinishTime = FinishTime;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let CreationDate = tape[ptr++];
      let Creators = tape[ptr++];
      let Purpose = tape[ptr++];
      let Duration = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let StartTime = tape[ptr++];
      let FinishTime = tape[ptr++];
      return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.CreationDate);
      args.push(this.Creators);
      args.push(this.Purpose);
      args.push(this.Duration);
      args.push(this.TotalFloat);
      args.push(this.StartTime);
      args.push(this.FinishTime);
      return args;
    }
  };
  var IfcWorkPlan = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.CreationDate = CreationDate;
      this.Creators = Creators;
      this.Purpose = Purpose;
      this.Duration = Duration;
      this.TotalFloat = TotalFloat;
      this.StartTime = StartTime;
      this.FinishTime = FinishTime;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let CreationDate = tape[ptr++];
      let Creators = tape[ptr++];
      let Purpose = tape[ptr++];
      let Duration = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let StartTime = tape[ptr++];
      let FinishTime = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.CreationDate);
      args.push(this.Creators);
      args.push(this.Purpose);
      args.push(this.Duration);
      args.push(this.TotalFloat);
      args.push(this.StartTime);
      args.push(this.FinishTime);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWorkSchedule = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.CreationDate = CreationDate;
      this.Creators = Creators;
      this.Purpose = Purpose;
      this.Duration = Duration;
      this.TotalFloat = TotalFloat;
      this.StartTime = StartTime;
      this.FinishTime = FinishTime;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let CreationDate = tape[ptr++];
      let Creators = tape[ptr++];
      let Purpose = tape[ptr++];
      let Duration = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let StartTime = tape[ptr++];
      let FinishTime = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.Identification);
      args.push(this.CreationDate);
      args.push(this.Creators);
      args.push(this.Purpose);
      args.push(this.Duration);
      args.push(this.TotalFloat);
      args.push(this.StartTime);
      args.push(this.FinishTime);
      args.push(this.PredefinedType);
      return args;
    }
  };
  var IfcWorkTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.RecurrencePattern = RecurrencePattern;
      this.Start = Start;
      this.Finish = Finish;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let RecurrencePattern = tape[ptr++];
      let Start = tape[ptr++];
      let Finish = tape[ptr++];
      return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      args.push(this.DataOrigin);
      args.push(this.UserDefinedDataOrigin);
      args.push(this.RecurrencePattern);
      args.push(this.Start);
      args.push(this.Finish);
      return args;
    }
  };
  var IfcZShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.FlangeWidth = FlangeWidth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.EdgeRadius = EdgeRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let FlangeWidth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let EdgeRadius = tape[ptr++];
      return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      args.push(this.ProfileName);
      args.push(this.Position);
      args.push(this.Depth);
      args.push(this.FlangeWidth);
      args.push(this.WebThickness);
      args.push(this.FlangeThickness);
      args.push(this.FilletRadius);
      args.push(this.EdgeRadius);
      return args;
    }
  };
  var IfcZone = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      args.push(this.OwnerHistory);
      args.push(this.Name);
      args.push(this.Description);
      args.push(this.ObjectType);
      args.push(this.LongName);
      return args;
    }
  };

  // dist/helpers/ifc-elements.ts
  var IfcElements2 = {
    103090709: "IFCPROJECT",
    4097777520: "IFCSITE",
    4031249490: "IFCBUILDING",
    3124254112: "IFCBUILDINGSTOREY",
    3856911033: "IFCSPACE",
    1674181508: "IFCANNOTATION",
    25142252: "IFCCONTROLLER",
    32344328: "IFCBOILER",
    76236018: "IFCLAMP",
    90941305: "IFCPUMP",
    177149247: "IFCAIRTERMINALBOX",
    182646315: "IFCFLOWINSTRUMENT",
    263784265: "IFCFURNISHINGELEMENT",
    264262732: "IFCELECTRICGENERATOR",
    277319702: "IFCAUDIOVISUALAPPLIANCE",
    310824031: "IFCPIPEFITTING",
    331165859: "IFCSTAIR",
    342316401: "IFCDUCTFITTING",
    377706215: "IFCMECHANICALFASTENER",
    395920057: "IFCDOOR",
    402227799: "IFCELECTRICMOTOR",
    413509423: "IFCSYSTEMFURNITUREELEMENT",
    484807127: "IFCEVAPORATOR",
    486154966: "IFCWINDOWSTANDARDCASE",
    629592764: "IFCLIGHTFIXTURE",
    630975310: "IFCUNITARYCONTROLELEMENT",
    635142910: "IFCCABLECARRIERFITTING",
    639361253: "IFCCOIL",
    647756555: "IFCFASTENER",
    707683696: "IFCFLOWSTORAGEDEVICE",
    738039164: "IFCPROTECTIVEDEVICE",
    753842376: "IFCBEAM",
    812556717: "IFCTANK",
    819412036: "IFCFILTER",
    843113511: "IFCCOLUMN",
    862014818: "IFCELECTRICDISTRIBUTIONBOARD",
    900683007: "IFCFOOTING",
    905975707: "IFCCOLUMNSTANDARDCASE",
    926996030: "IFCVOIDINGFEATURE",
    979691226: "IFCREINFORCINGBAR",
    987401354: "IFCFLOWSEGMENT",
    1003880860: "IFCELECTRICTIMECONTROL",
    1051757585: "IFCCABLEFITTING",
    1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
    1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
    1073191201: "IFCMEMBER",
    1095909175: "IFCBUILDINGELEMENTPROXY",
    1156407060: "IFCPLATESTANDARDCASE",
    1162798199: "IFCSWITCHINGDEVICE",
    1329646415: "IFCSHADINGDEVICE",
    1335981549: "IFCDISCRETEACCESSORY",
    1360408905: "IFCDUCTSILENCER",
    1404847402: "IFCSTACKTERMINAL",
    1426591983: "IFCFIRESUPPRESSIONTERMINAL",
    1437502449: "IFCMEDICALDEVICE",
    1509553395: "IFCFURNITURE",
    1529196076: "IFCSLAB",
    1620046519: "IFCTRANSPORTELEMENT",
    1634111441: "IFCAIRTERMINAL",
    1658829314: "IFCENERGYCONVERSIONDEVICE",
    1677625105: "IFCCIVILELEMENT",
    1687234759: "IFCPILE",
    1904799276: "IFCELECTRICAPPLIANCE",
    1911478936: "IFCMEMBERSTANDARDCASE",
    1945004755: "IFCDISTRIBUTIONELEMENT",
    1973544240: "IFCCOVERING",
    1999602285: "IFCSPACEHEATER",
    2016517767: "IFCROOF",
    2056796094: "IFCAIRTOAIRHEATRECOVERY",
    2058353004: "IFCFLOWCONTROLLER",
    2068733104: "IFCHUMIDIFIER",
    2176052936: "IFCJUNCTIONBOX",
    2188021234: "IFCFLOWMETER",
    2223149337: "IFCFLOWTERMINAL",
    2262370178: "IFCRAILING",
    2272882330: "IFCCONDENSER",
    2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
    2320036040: "IFCREINFORCINGMESH",
    2347447852: "IFCTENDONANCHOR",
    2391383451: "IFCVIBRATIONISOLATOR",
    2391406946: "IFCWALL",
    2474470126: "IFCMOTORCONNECTION",
    2769231204: "IFCVIRTUALELEMENT",
    2814081492: "IFCENGINE",
    2906023776: "IFCBEAMSTANDARDCASE",
    2938176219: "IFCBURNER",
    2979338954: "IFCBUILDINGELEMENTPART",
    3024970846: "IFCRAMP",
    3026737570: "IFCTUBEBUNDLE",
    3027962421: "IFCSLABSTANDARDCASE",
    3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
    3053780830: "IFCSANITARYTERMINAL",
    3079942009: "IFCOPENINGSTANDARDCASE",
    3087945054: "IFCALARM",
    3101698114: "IFCSURFACEFEATURE",
    3127900445: "IFCSLABELEMENTEDCASE",
    3132237377: "IFCFLOWMOVINGDEVICE",
    3171933400: "IFCPLATE",
    3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
    3242481149: "IFCDOORSTANDARDCASE",
    3283111854: "IFCRAMPFLIGHT",
    3296154744: "IFCCHIMNEY",
    3304561284: "IFCWINDOW",
    3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
    3319311131: "IFCHEATEXCHANGER",
    3415622556: "IFCFAN",
    3420628829: "IFCSOLARDEVICE",
    3493046030: "IFCGEOGRAPHICELEMENT",
    3495092785: "IFCCURTAINWALL",
    3508470533: "IFCFLOWTREATMENTDEVICE",
    3512223829: "IFCWALLSTANDARDCASE",
    3518393246: "IFCDUCTSEGMENT",
    3571504051: "IFCCOMPRESSOR",
    3588315303: "IFCOPENINGELEMENT",
    3612865200: "IFCPIPESEGMENT",
    3640358203: "IFCCOOLINGTOWER",
    3651124850: "IFCPROJECTIONELEMENT",
    3694346114: "IFCOUTLET",
    3747195512: "IFCEVAPORATIVECOOLER",
    3758799889: "IFCCABLECARRIERSEGMENT",
    3824725483: "IFCTENDON",
    3825984169: "IFCTRANSFORMER",
    3902619387: "IFCCHILLER",
    4074379575: "IFCDAMPER",
    4086658281: "IFCSENSOR",
    4123344466: "IFCELEMENTASSEMBLY",
    4136498852: "IFCCOOLEDBEAM",
    4156078855: "IFCWALLELEMENTEDCASE",
    4175244083: "IFCINTERCEPTOR",
    4207607924: "IFCVALVE",
    4217484030: "IFCCABLESEGMENT",
    4237592921: "IFCWASTETERMINAL",
    4252922144: "IFCSTAIRFLIGHT",
    4278956645: "IFCFLOWFITTING",
    4288193352: "IFCACTUATOR",
    4292641817: "IFCUNITARYEQUIPMENT",
    3009204131: "IFCGRID"
  };

  // dist/helpers/properties.ts
  var PropsNames = {
    aggregates: {
      name: IFCRELAGGREGATES,
      relating: "RelatingObject",
      related: "RelatedObjects",
      key: "children"
    },
    spatial: {
      name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
      relating: "RelatingStructure",
      related: "RelatedElements",
      key: "children"
    },
    psets: {
      name: IFCRELDEFINESBYPROPERTIES,
      relating: "RelatingPropertyDefinition",
      related: "RelatedObjects",
      key: "hasPsets"
    },
    materials: {
      name: IFCRELASSOCIATESMATERIAL,
      relating: "RelatingMaterial",
      related: "RelatedObjects",
      key: "hasMaterial"
    },
    type: {
      name: IFCRELDEFINESBYTYPE,
      relating: "RelatingType",
      related: "RelatedObjects",
      key: "hasType"
    }
  };
  var Properties = class {
    constructor(api) {
      this.api = api;
    }
    getItemProperties(modelID, id, recursive = false) {
      return __async(this, null, function* () {
        return this.api.GetLine(modelID, id, recursive);
      });
    }
    getPropertySets(modelID, elementID, recursive = false) {
      return __async(this, null, function* () {
        return yield this.getProperty(modelID, elementID, recursive, PropsNames.psets);
      });
    }
    getTypeProperties(modelID, elementID, recursive = false) {
      return __async(this, null, function* () {
        return yield this.getProperty(modelID, elementID, recursive, PropsNames.type);
      });
    }
    getMaterialsProperties(modelID, elementID, recursive = false) {
      return __async(this, null, function* () {
        return yield this.getProperty(modelID, elementID, recursive, PropsNames.materials);
      });
    }
    getSpatialStructure(modelID, includeProperties) {
      return __async(this, null, function* () {
        yield this.getAllTypesOfModel(modelID);
        const chunks = yield this.getSpatialTreeChunks(modelID);
        const allLines = yield this.api.GetLineIDsWithType(modelID, IFCPROJECT);
        const projectID = allLines.get(0);
        const project = Properties.newIfcProject(projectID);
        yield this.getSpatialNode(modelID, project, chunks, includeProperties);
        this.cleanupTypes();
        return project;
      });
    }
    getAllItemsOfType(modelID, type, verbose) {
      return __async(this, null, function* () {
        let items = [];
        const lines = yield this.api.GetLineIDsWithType(modelID, type);
        for (let i = 0; i < lines.size(); i++)
          items.push(lines.get(i));
        if (!verbose)
          return items;
        const result = [];
        for (let i = 0; i < items.length; i++) {
          result.push(yield this.api.GetLine(modelID, items[i]));
        }
        return result;
      });
    }
    getProperty(modelID, elementID, recursive = false, propName) {
      return __async(this, null, function* () {
        const propSetIds = yield this.getAllRelatedItemsOfType(modelID, elementID, propName);
        const result = [];
        for (let i = 0; i < propSetIds.length; i++) {
          result.push(yield this.api.GetLine(modelID, propSetIds[i], recursive));
        }
        return result;
      });
    }
    getChunks(modelID, chunks, propNames) {
      return __async(this, null, function* () {
        const relation = yield this.api.GetLineIDsWithType(modelID, propNames.name);
        for (let i = 0; i < relation.size(); i++) {
          const rel = yield this.api.GetLine(modelID, relation.get(i), false);
          this.saveChunk(chunks, propNames, rel);
        }
      });
    }
    static isRelated(id, rel, propNames) {
      const relatedItems = rel[propNames.related];
      if (Array.isArray(relatedItems)) {
        const values = relatedItems.map((item) => item.value);
        return values.includes(id);
      }
      return relatedItems.value === id;
    }
    static newIfcProject(id) {
      return {
        expressID: id,
        type: "IFCPROJECT",
        children: []
      };
    }
    getSpatialNode(modelID, node, treeChunks, includeProperties) {
      return __async(this, null, function* () {
        yield this.getChildren(modelID, node, treeChunks, PropsNames.aggregates, includeProperties);
        yield this.getChildren(modelID, node, treeChunks, PropsNames.spatial, includeProperties);
      });
    }
    getChildren(modelID, node, treeChunks, propNames, includeProperties) {
      return __async(this, null, function* () {
        const children = treeChunks[node.expressID];
        if (children == void 0)
          return;
        const prop = propNames.key;
        const nodes = [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          let node2 = this.newNode(child);
          if (includeProperties) {
            const properties = yield this.getItemProperties(modelID, node2.expressID);
            node2 = __spreadValues(__spreadValues({}, properties), node2);
          }
          yield this.getSpatialNode(modelID, node2, treeChunks, includeProperties);
          nodes.push(node2);
        }
        node[prop] = nodes;
      });
    }
    newNode(id) {
      const typeName = this.getNodeType(id);
      return {
        expressID: id,
        type: typeName,
        children: []
      };
    }
    getNodeType(id) {
      const typeID = this.types[id];
      return IfcElements2[typeID];
    }
    getSpatialTreeChunks(modelID) {
      return __async(this, null, function* () {
        const treeChunks = {};
        yield this.getChunks(modelID, treeChunks, PropsNames.aggregates);
        yield this.getChunks(modelID, treeChunks, PropsNames.spatial);
        return treeChunks;
      });
    }
    saveChunk(chunks, propNames, rel) {
      const relating = rel[propNames.relating].value;
      const related = rel[propNames.related].map((r) => r.value);
      if (chunks[relating] == void 0) {
        chunks[relating] = related;
      } else {
        chunks[relating] = chunks[relating].concat(related);
      }
    }
    getRelated(rel, propNames, IDs) {
      const element = rel[propNames.relating];
      if (!Array.isArray(element))
        IDs.push(element.value);
      else
        element.forEach((ele) => IDs.push(ele.value));
    }
    getAllRelatedItemsOfType(modelID, id, propNames) {
      return __async(this, null, function* () {
        const lines = yield this.api.GetLineIDsWithType(modelID, propNames.name);
        const IDs = [];
        for (let i = 0; i < lines.size(); i++) {
          const rel = yield this.api.GetLine(modelID, lines.get(i));
          const isRelated = Properties.isRelated(id, rel, propNames);
          if (isRelated)
            this.getRelated(rel, propNames, IDs);
        }
        return IDs;
      });
    }
    cleanupTypes() {
      this.types = {};
    }
    getAllTypesOfModel(modelID) {
      return __async(this, null, function* () {
        const result = {};
        const elements = Object.keys(IfcElements2).map((e) => parseInt(e));
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          const lines = yield this.api.GetLineIDsWithType(modelID, element);
          const size = lines.size();
          for (let i2 = 0; i2 < size; i2++)
            result[lines.get(i2)] = element;
        }
        this.types = result;
      });
    }
  };

  // dist/web-ifc-api.ts
  var WebIFCWasm;
  if (typeof self !== "undefined" && self.crossOriginIsolated) {
    WebIFCWasm = require_web_ifc_mt();
  } else {
    WebIFCWasm = require_web_ifc();
  }
  var IfcAPI2 = class {
    constructor() {
      this.wasmModule = void 0;
      this.fs = void 0;
      this.wasmPath = "";
      this.ifcGuidMap = new Map();
      this.properties = new Properties(this);
    }
    Init(customLocateFileHandler) {
      return __async(this, null, function* () {
        if (WebIFCWasm) {
          let locateFileHandler = (path, prefix) => {
            if (path.endsWith(".wasm")) {
              return prefix + this.wasmPath + path;
            }
            return prefix + path;
          };
          this.wasmModule = yield WebIFCWasm({ noInitialRun: true, locateFile: customLocateFileHandler || locateFileHandler });
          this.fs = this.wasmModule.FS;
        } else {
          console.error(`Could not find wasm module at './web-ifc' from web-ifc-api.ts`);
        }
      });
    }
    OpenModel(data, settings) {
      let s = __spreadValues({
        COORDINATE_TO_ORIGIN: false,
        USE_FAST_BOOLS: false,
        CIRCLE_SEGMENTS_LOW: 5,
        CIRCLE_SEGMENTS_MEDIUM: 8,
        CIRCLE_SEGMENTS_HIGH: 12,
        BOOL_ABORT_THRESHOLD: 1e4
      }, settings);
      let offsetInSrc = 0;
      let result = this.wasmModule.OpenModel(s, (destPtr, destSize) => {
        let srcSize = Math.min(data.byteLength - offsetInSrc, destSize);
        let dest = this.wasmModule.HEAPU8.subarray(destPtr, destPtr + destSize);
        let src = data.subarray(offsetInSrc, offsetInSrc + srcSize);
        dest.set(src);
        offsetInSrc += srcSize;
        return srcSize;
      });
      return result;
    }
    CreateModel(settings) {
      let s = __spreadValues({
        COORDINATE_TO_ORIGIN: false,
        USE_FAST_BOOLS: false,
        CIRCLE_SEGMENTS_LOW: 5,
        CIRCLE_SEGMENTS_MEDIUM: 8,
        CIRCLE_SEGMENTS_HIGH: 12,
        BOOL_ABORT_THRESHOLD: 1e4
      }, settings);
      let result = this.wasmModule.CreateModel(s);
      return result;
    }
    ExportFileAsIFC(modelID) {
      this.wasmModule.ExportFileAsIFC(modelID);
      let result = this.fs.readFile("/export.ifc");
      this.wasmModule["FS_unlink"]("/export.ifc");
      return result;
    }
    GetGeometry(modelID, geometryExpressID) {
      return this.wasmModule.GetGeometry(modelID, geometryExpressID);
    }
    GetLine(modelID, expressID, flatten = false) {
      let rawLineData = this.GetRawLineData(modelID, expressID);
      let lineData = FromRawLineData[rawLineData.type](rawLineData);
      if (flatten) {
        this.FlattenLine(modelID, lineData);
      }
      return lineData;
    }
    GetAndClearErrors(modelID) {
      return this.wasmModule.GetAndClearErrors(modelID);
    }
    WriteLine(modelID, lineObject) {
      Object.keys(lineObject).forEach((propertyName) => {
        let property = lineObject[propertyName];
        if (property && property.expressID !== void 0) {
          this.WriteLine(modelID, property);
          lineObject[propertyName] = {
            type: 5,
            value: property.expressID
          };
        } else if (Array.isArray(property) && property.length > 0) {
          for (let i = 0; i < property.length; i++) {
            if (property[i].expressID !== void 0) {
              this.WriteLine(modelID, property[i]);
              lineObject[propertyName][i] = {
                type: 5,
                value: property[i].expressID
              };
            }
          }
        }
      });
      let rawLineData = {
        ID: lineObject.expressID,
        type: lineObject.type,
        arguments: lineObject.ToTape()
      };
      this.WriteRawLineData(modelID, rawLineData);
    }
    FlattenLine(modelID, line) {
      Object.keys(line).forEach((propertyName) => {
        let property = line[propertyName];
        if (property && property.type === 5) {
          line[propertyName] = this.GetLine(modelID, property.value, true);
        } else if (Array.isArray(property) && property.length > 0 && property[0].type === 5) {
          for (let i = 0; i < property.length; i++) {
            line[propertyName][i] = this.GetLine(modelID, property[i].value, true);
          }
        }
      });
    }
    GetRawLineData(modelID, expressID) {
      return this.wasmModule.GetLine(modelID, expressID);
    }
    WriteRawLineData(modelID, data) {
      return this.wasmModule.WriteLine(modelID, data.ID, data.type, data.arguments);
    }
    GetLineIDsWithType(modelID, type) {
      return this.wasmModule.GetLineIDsWithType(modelID, type);
    }
    GetAllLines(modelID) {
      return this.wasmModule.GetAllLines(modelID);
    }
    SetGeometryTransformation(modelID, transformationMatrix) {
      if (transformationMatrix.length != 16) {
        console.log(`Bad transformation matrix size: ${transformationMatrix.length}`);
        return;
      }
      this.wasmModule.SetGeometryTransformation(modelID, transformationMatrix);
    }
    GetCoordinationMatrix(modelID) {
      return this.wasmModule.GetCoordinationMatrix(modelID);
    }
    GetVertexArray(ptr, size) {
      return this.getSubArray(this.wasmModule.HEAPF32, ptr, size);
    }
    GetIndexArray(ptr, size) {
      return this.getSubArray(this.wasmModule.HEAPU32, ptr, size);
    }
    getSubArray(heap, startPtr, sizeBytes) {
      return heap.subarray(startPtr / 4, startPtr / 4 + sizeBytes).slice(0);
    }
    CloseModel(modelID) {
      this.ifcGuidMap.delete(modelID);
      this.wasmModule.CloseModel(modelID);
    }
    StreamAllMeshes(modelID, meshCallback) {
      this.wasmModule.StreamAllMeshes(modelID, meshCallback);
    }
    StreamAllMeshesWithTypes(modelID, types, meshCallback) {
      this.wasmModule.StreamAllMeshesWithTypes(modelID, types, meshCallback);
    }
    IsModelOpen(modelID) {
      return this.wasmModule.IsModelOpen(modelID);
    }
    LoadAllGeometry(modelID) {
      return this.wasmModule.LoadAllGeometry(modelID);
    }
    GetFlatMesh(modelID, expressID) {
      return this.wasmModule.GetFlatMesh(modelID, expressID);
    }
    CreateIfcGuidToExpressIdMapping(modelID) {
      const map = new Map();
      for (let x = 0; x < IfcElements$1.length; x++) {
        const type = IfcElements$1[x];
        const lines = this.GetLineIDsWithType(modelID, type);
        const size = lines.size();
        for (let y = 0; y < size; y++) {
          const expressID = lines.get(y);
          const info = this.GetLine(modelID, expressID);
          const globalID = info.GlobalId.value;
          map.set(expressID, globalID);
          map.set(globalID, expressID);
        }
      }
      this.ifcGuidMap.set(modelID, map);
    }
    SetWasmPath(path) {
      this.wasmPath = path;
    }
  };

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    Object.defineProperty(subClass, "prototype", {
      value: Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      }),
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }

  function defaultURIBuilder(globalId) {
    return "inst:".concat(encodeURIComponent(globalId));
  }

  function buildRelOneToOne(_x) {
    return _buildRelOneToOne.apply(this, arguments);
  } // ifcAPI: WebIFC.IfcAPI, modelID: number = 0, relationshipType: number, subjectRef: string, targetRef: string, rdfRelationship: string, subjectClassConstraint?: number, targetClassConstraint?: number

  function _buildRelOneToOne() {
    _buildRelOneToOne = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(d) {
      var graph, rels, i, relID, relProps, _yield$Promise$all, _yield$Promise$all2, subject, target, subjectURI, targetURI, interfaceURI;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (d.includeInterface == undefined) d.includeInterface = false;
              if (d.ifcSubjectClassIn == undefined) d.ifcSubjectClassIn = [];
              if (d.ifcTargetClassIn == undefined) d.ifcTargetClassIn = [];
              if (d.ifcSubjectClassIn.length) console.log("ifcSubjectClassIn not yet supported for buildRelOneToOne");
              if (d.ifcTargetClassIn.length) console.log("ifcTargetClassIn not yet supported for buildRelOneToOne");
              graph = [];
              _context.next = 8;
              return d.ifcAPI.properties.getAllItemsOfType(d.modelID, d.ifcRelationship, false);

            case 8:
              rels = _context.sent;
              i = 0;

            case 10:
              if (!(i < rels.length)) {
                _context.next = 34;
                break;
              }

              relID = rels[i];
              _context.next = 14;
              return d.ifcAPI.properties.getItemProperties(d.modelID, relID);

            case 14:
              relProps = _context.sent;

              if (!(!relProps[d.ifcSubjectRel] || !relProps[d.ifcTargetRel])) {
                _context.next = 17;
                break;
              }

              return _context.abrupt("continue", 31);

            case 17:
              _context.next = 19;
              return Promise.all([d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcSubjectRel].value), d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcTargetRel].value)]);

            case 19:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              subject = _yield$Promise$all2[0];
              target = _yield$Promise$all2[1];

              if (subject.GlobalId.value == "0dG4XB8Mj2QhLcDnrkJh$F") {
                console.log("subject");
              }

              if (target.GlobalId.value == "0dG4XB8Mj2QhLcDnrkJh$F") {
                console.log("target");
              }

              subjectURI = defaultURIBuilder(subject.GlobalId.value);
              targetURI = defaultURIBuilder(target.GlobalId.value);
              interfaceURI = defaultURIBuilder(relProps.GlobalId.value); // Push relationships

              graph.push(_defineProperty({
                "@id": subjectURI
              }, d.rdfRelationship, {
                "@id": targetURI
              })); // Optionally, push it in opposite direction

              if (d.oppoiteRelationship != undefined) {
                graph.push(_defineProperty({
                  "@id": targetURI
                }, d.oppoiteRelationship, {
                  "@id": subjectURI
                }));
              } // Optionally, also include the interface


              if (d.includeInterface) {
                graph.push({
                  "@id": interfaceURI,
                  "@type": "bot:Interface",
                  "ex:expressID": relProps.expressID,
                  "bot:interfaceOf": [{
                    "@id": subjectURI
                  }, {
                    "@id": targetURI
                  }]
                });
              }

            case 31:
              i++;
              _context.next = 10;
              break;

            case 34:
              return _context.abrupt("return", graph);

            case 35:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _buildRelOneToOne.apply(this, arguments);
  }

  function buildRelOneToMany(_x2) {
    return _buildRelOneToMany.apply(this, arguments);
  }

  function _buildRelOneToMany() {
    _buildRelOneToMany = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(d) {
      var graph, rels, _loop, i, _ret;

      return regenerator.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (d.includeInterface == undefined) d.includeInterface = false;
              if (d.ifcSubjectClassIn == undefined) d.ifcSubjectClassIn = [];
              if (d.ifcTargetClassIn == undefined) d.ifcTargetClassIn = [];
              if (d.includeInterface) console.log("Include interface not yet supported for buildRelOneToMany");
              graph = [];
              _context3.next = 7;
              return d.ifcAPI.properties.getAllItemsOfType(d.modelID, d.ifcRelationship, false);

            case 7:
              rels = _context3.sent;
              _loop = /*#__PURE__*/regenerator.mark(function _loop(i) {
                var relID, relProps, subject, targetPromises, _i, targets, types, targetObjects, subjectURI;

                return regenerator.wrap(function _loop$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        relID = rels[i];
                        _context2.next = 3;
                        return d.ifcAPI.properties.getItemProperties(d.modelID, relID);

                      case 3:
                        relProps = _context2.sent;

                        if (!(!relProps[d.ifcSubjectRel] || !relProps[d.ifcTargetRel])) {
                          _context2.next = 6;
                          break;
                        }

                        return _context2.abrupt("return", "continue");

                      case 6:
                        _context2.next = 8;
                        return d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcSubjectRel].value);

                      case 8:
                        subject = _context2.sent;

                        if (!(d.ifcSubjectClassIn.length && d.ifcSubjectClassIn.indexOf(subject.type) == -1)) {
                          _context2.next = 11;
                          break;
                        }

                        return _context2.abrupt("return", "continue");

                      case 11:
                        targetPromises = [];

                        for (_i = 0; _i < relProps[d.ifcTargetRel].length; _i++) {
                          targetPromises.push(d.ifcAPI.properties.getItemProperties(d.modelID, relProps[d.ifcTargetRel][_i].value));
                        }

                        _context2.next = 15;
                        return Promise.all(targetPromises);

                      case 15:
                        targets = _context2.sent;
                        types = new Set();
                        targetObjects = targets.filter(function (t) {
                          // It might be that we are only interested in relationship where the target fulfills the constraint
                          types.add(t.type);
                          if (d.ifcTargetClassIn.length && d.ifcTargetClassIn.indexOf(t.type) == -1) return false;
                          return true;
                        }).map(function (t) {
                          var targetURI = defaultURIBuilder(t.GlobalId.value);
                          return {
                            "@id": targetURI
                          };
                        }); // Skip if no target objects

                        if (targetObjects.length) {
                          _context2.next = 20;
                          break;
                        }

                        return _context2.abrupt("return", "continue");

                      case 20:
                        subjectURI = defaultURIBuilder(subject.GlobalId.value); // Push relationships

                        graph.push(_defineProperty({
                          "@id": subjectURI
                        }, d.rdfRelationship, targetObjects)); // Optionally, push it in opposite direction

                        if (d.oppoiteRelationship != undefined) {
                          targetObjects.forEach(function (item) {
                            var obj = JSON.parse(JSON.stringify(item));
                            graph.push(Object.assign(obj, _defineProperty({}, d.oppoiteRelationship, {
                              "@id": subjectURI
                            })));
                          });
                        }

                      case 23:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _loop);
              });
              i = 0;

            case 10:
              if (!(i < rels.length)) {
                _context3.next = 18;
                break;
              }

              return _context3.delegateYield(_loop(i), "t0", 12);

            case 12:
              _ret = _context3.t0;

              if (!(_ret === "continue")) {
                _context3.next = 15;
                break;
              }

              return _context3.abrupt("continue", 15);

            case 15:
              i++;
              _context3.next = 10;
              break;

            case 18:
              return _context3.abrupt("return", graph);

            case 19:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2);
    }));
    return _buildRelOneToMany.apply(this, arguments);
  }

  var IfcTypesTree = {
    "children": [{
      "children": [{
        "children": [{
          "name": "IfcProject",
          "id": 103090709
        }, {
          "name": "IfcProjectLibrary",
          "id": 653396225
        }],
        "name": "IfcContext",
        "id": 3419103109
      }, {
        "children": [{
          "children": [{
            "name": "IfcOccupant",
            "id": 4143007308
          }],
          "name": "IfcActor",
          "id": 2296667514
        }, {
          "children": [{
            "name": "IfcActionRequest",
            "id": 3821786052
          }, {
            "name": "IfcCostItem",
            "id": 3895139033
          }, {
            "name": "IfcCostSchedule",
            "id": 1419761937
          }, {
            "name": "IfcPerformanceHistory",
            "id": 2382730787
          }, {
            "name": "IfcPermit",
            "id": 3327091369
          }, {
            "name": "IfcProjectOrder",
            "id": 2904328755
          }, {
            "name": "IfcWorkCalendar",
            "id": 4088093105
          }, {
            "children": [{
              "name": "IfcWorkPlan",
              "id": 4218914973
            }, {
              "name": "IfcWorkSchedule",
              "id": 3342526732
            }],
            "name": "IfcWorkControl",
            "id": 1028945134
          }],
          "name": "IfcControl",
          "id": 3293443760
        }, {
          "children": [{
            "name": "IfcAsset",
            "id": 3460190687
          }, {
            "name": "IfcInventory",
            "id": 2391368822
          }, {
            "children": [{
              "name": "IfcStructuralLoadCase",
              "id": 385403989
            }],
            "name": "IfcStructuralLoadGroup",
            "id": 1252848954
          }, {
            "name": "IfcStructuralResultGroup",
            "id": 2986769608
          }, {
            "children": [{
              "name": "IfcBuildingSystem",
              "id": 1177604601
            }, {
              "children": [{
                "name": "IfcDistributionCircuit",
                "id": 562808652
              }],
              "name": "IfcDistributionSystem",
              "id": 3205830791
            }, {
              "name": "IfcStructuralAnalysisModel",
              "id": 2515109513
            }, {
              "name": "IfcZone",
              "id": 1033361043
            }],
            "name": "IfcSystem",
            "id": 2254336722
          }],
          "name": "IfcGroup",
          "id": 2706460486
        }, {
          "children": [{
            "name": "IfcEvent",
            "id": 4148101412
          }, {
            "name": "IfcProcedure",
            "id": 2744685151
          }, {
            "name": "IfcTask",
            "id": 3473067441
          }],
          "name": "IfcProcess",
          "id": 2945172077
        }, {
          "children": [{
            "name": "IfcAnnotation",
            "id": 1674181508
          }, {
            "children": [{
              "children": [{
                "children": [{
                  "name": "IfcBeamStandardCase",
                  "id": 2906023776
                }],
                "name": "IfcBeam",
                "id": 753842376
              }, {
                "name": "IfcBuildingElementProxy",
                "id": 1095909175
              }, {
                "name": "IfcChimney",
                "id": 3296154744
              }, {
                "children": [{
                  "name": "IfcColumnStandardCase",
                  "id": 905975707
                }],
                "name": "IfcColumn",
                "id": 843113511
              }, {
                "name": "IfcCovering",
                "id": 1973544240
              }, {
                "name": "IfcCurtainWall",
                "id": 3495092785
              }, {
                "children": [{
                  "name": "IfcDoorStandardCase",
                  "id": 3242481149
                }],
                "name": "IfcDoor",
                "id": 395920057
              }, {
                "name": "IfcFooting",
                "id": 900683007
              }, {
                "children": [{
                  "name": "IfcMemberStandardCase",
                  "id": 1911478936
                }],
                "name": "IfcMember",
                "id": 1073191201
              }, {
                "name": "IfcPile",
                "id": 1687234759
              }, {
                "children": [{
                  "name": "IfcPlateStandardCase",
                  "id": 1156407060
                }],
                "name": "IfcPlate",
                "id": 3171933400
              }, {
                "name": "IfcRailing",
                "id": 2262370178
              }, {
                "name": "IfcRamp",
                "id": 3024970846
              }, {
                "name": "IfcRampFlight",
                "id": 3283111854
              }, {
                "name": "IfcRoof",
                "id": 2016517767
              }, {
                "name": "IfcShadingDevice",
                "id": 1329646415
              }, {
                "children": [{
                  "name": "IfcSlabElementedCase",
                  "id": 3127900445
                }, {
                  "name": "IfcSlabStandardCase",
                  "id": 3027962421
                }],
                "name": "IfcSlab",
                "id": 1529196076
              }, {
                "name": "IfcStair",
                "id": 331165859
              }, {
                "name": "IfcStairFlight",
                "id": 4252922144
              }, {
                "children": [{
                  "name": "IfcWallElementedCase",
                  "id": 4156078855
                }, {
                  "name": "IfcWallStandardCase",
                  "id": 3512223829
                }],
                "name": "IfcWall",
                "id": 2391406946
              }, {
                "children": [{
                  "name": "IfcWindowStandardCase",
                  "id": 486154966
                }],
                "name": "IfcWindow",
                "id": 3304561284
              }],
              "name": "IfcBuildingElement",
              "id": 3299480353
            }, {
              "name": "IfcCivilElement",
              "id": 1677625105
            }, {
              "children": [{
                "children": [{
                  "name": "IfcActuator",
                  "id": 4288193352
                }, {
                  "name": "IfcAlarm",
                  "id": 3087945054
                }, {
                  "name": "IfcController",
                  "id": 25142252
                }, {
                  "name": "IfcFlowInstrument",
                  "id": 182646315
                }, {
                  "name": "IfcProtectiveDeviceTrippingUnit",
                  "id": 2295281155
                }, {
                  "name": "IfcSensor",
                  "id": 4086658281
                }, {
                  "name": "IfcUnitaryControlElement",
                  "id": 630975310
                }],
                "name": "IfcDistributionControlElement",
                "id": 1062813311
              }, {
                "children": [{
                  "name": "IfcDistributionChamberElement",
                  "id": 1052013943
                }, {
                  "children": [{
                    "name": "IfcAirToAirHeatRecovery",
                    "id": 2056796094
                  }, {
                    "name": "IfcBoiler",
                    "id": 32344328
                  }, {
                    "name": "IfcBurner",
                    "id": 2938176219
                  }, {
                    "name": "IfcChiller",
                    "id": 3902619387
                  }, {
                    "name": "IfcCoil",
                    "id": 639361253
                  }, {
                    "name": "IfcCondenser",
                    "id": 2272882330
                  }, {
                    "name": "IfcCooledBeam",
                    "id": 4136498852
                  }, {
                    "name": "IfcCoolingTower",
                    "id": 3640358203
                  }, {
                    "name": "IfcElectricGenerator",
                    "id": 264262732
                  }, {
                    "name": "IfcElectricMotor",
                    "id": 402227799
                  }, {
                    "name": "IfcEngine",
                    "id": 2814081492
                  }, {
                    "name": "IfcEvaporativeCooler",
                    "id": 3747195512
                  }, {
                    "name": "IfcEvaporator",
                    "id": 484807127
                  }, {
                    "name": "IfcHeatExchanger",
                    "id": 3319311131
                  }, {
                    "name": "IfcHumidifier",
                    "id": 2068733104
                  }, {
                    "name": "IfcMotorConnection",
                    "id": 2474470126
                  }, {
                    "name": "IfcSolarDevice",
                    "id": 3420628829
                  }, {
                    "name": "IfcTransformer",
                    "id": 3825984169
                  }, {
                    "name": "IfcTubeBundle",
                    "id": 3026737570
                  }, {
                    "name": "IfcUnitaryEquipment",
                    "id": 4292641817
                  }],
                  "name": "IfcEnergyConversionDevice",
                  "id": 1658829314
                }, {
                  "children": [{
                    "name": "IfcAirTerminalBox",
                    "id": 177149247
                  }, {
                    "name": "IfcDamper",
                    "id": 4074379575
                  }, {
                    "name": "IfcElectricDistributionBoard",
                    "id": 862014818
                  }, {
                    "name": "IfcElectricTimeControl",
                    "id": 1003880860
                  }, {
                    "name": "IfcFlowMeter",
                    "id": 2188021234
                  }, {
                    "name": "IfcProtectiveDevice",
                    "id": 738039164
                  }, {
                    "name": "IfcSwitchingDevice",
                    "id": 1162798199
                  }, {
                    "name": "IfcValve",
                    "id": 4207607924
                  }],
                  "name": "IfcFlowController",
                  "id": 2058353004
                }, {
                  "children": [{
                    "name": "IfcCableCarrierFitting",
                    "id": 635142910
                  }, {
                    "name": "IfcCableFitting",
                    "id": 1051757585
                  }, {
                    "name": "IfcDuctFitting",
                    "id": 342316401
                  }, {
                    "name": "IfcJunctionBox",
                    "id": 2176052936
                  }, {
                    "name": "IfcPipeFitting",
                    "id": 310824031
                  }],
                  "name": "IfcFlowFitting",
                  "id": 4278956645
                }, {
                  "children": [{
                    "name": "IfcCompressor",
                    "id": 3571504051
                  }, {
                    "name": "IfcFan",
                    "id": 3415622556
                  }, {
                    "name": "IfcPump",
                    "id": 90941305
                  }],
                  "name": "IfcFlowMovingDevice",
                  "id": 3132237377
                }, {
                  "children": [{
                    "name": "IfcCableCarrierSegment",
                    "id": 3758799889
                  }, {
                    "name": "IfcCableSegment",
                    "id": 4217484030
                  }, {
                    "name": "IfcDuctSegment",
                    "id": 3518393246
                  }, {
                    "name": "IfcPipeSegment",
                    "id": 3612865200
                  }],
                  "name": "IfcFlowSegment",
                  "id": 987401354
                }, {
                  "children": [{
                    "name": "IfcElectricFlowStorageDevice",
                    "id": 3310460725
                  }, {
                    "name": "IfcTank",
                    "id": 812556717
                  }],
                  "name": "IfcFlowStorageDevice",
                  "id": 707683696
                }, {
                  "children": [{
                    "name": "IfcAirTerminal",
                    "id": 1634111441
                  }, {
                    "name": "IfcAudioVisualAppliance",
                    "id": 277319702
                  }, {
                    "name": "IfcCommunicationsAppliance",
                    "id": 3221913625
                  }, {
                    "name": "IfcElectricAppliance",
                    "id": 1904799276
                  }, {
                    "name": "IfcFireSuppressionTerminal",
                    "id": 1426591983
                  }, {
                    "name": "IfcLamp",
                    "id": 76236018
                  }, {
                    "name": "IfcLightFixture",
                    "id": 629592764
                  }, {
                    "name": "IfcMedicalDevice",
                    "id": 1437502449
                  }, {
                    "name": "IfcOutlet",
                    "id": 3694346114
                  }, {
                    "name": "IfcSanitaryTerminal",
                    "id": 3053780830
                  }, {
                    "name": "IfcSpaceHeater",
                    "id": 1999602285
                  }, {
                    "name": "IfcStackTerminal",
                    "id": 1404847402
                  }, {
                    "name": "IfcWasteTerminal",
                    "id": 4237592921
                  }],
                  "name": "IfcFlowTerminal",
                  "id": 2223149337
                }, {
                  "children": [{
                    "name": "IfcDuctSilencer",
                    "id": 1360408905
                  }, {
                    "name": "IfcFilter",
                    "id": 819412036
                  }, {
                    "name": "IfcInterceptor",
                    "id": 4175244083
                  }],
                  "name": "IfcFlowTreatmentDevice",
                  "id": 3508470533
                }],
                "name": "IfcDistributionFlowElement",
                "id": 3040386961
              }],
              "name": "IfcDistributionElement",
              "id": 1945004755
            }, {
              "name": "IfcElementAssembly",
              "id": 4123344466
            }, {
              "children": [{
                "name": "IfcBuildingElementPart",
                "id": 2979338954
              }, {
                "name": "IfcDiscreteAccessory",
                "id": 1335981549
              }, {
                "name": "IfcFastener",
                "id": 647756555
              }, {
                "name": "IfcMechanicalFastener",
                "id": 377706215
              }, {
                "children": [{
                  "name": "IfcReinforcingBar",
                  "id": 979691226
                }, {
                  "name": "IfcReinforcingMesh",
                  "id": 2320036040
                }, {
                  "name": "IfcTendon",
                  "id": 3824725483
                }, {
                  "name": "IfcTendonAnchor",
                  "id": 2347447852
                }],
                "name": "IfcReinforcingElement",
                "id": 3027567501
              }, {
                "name": "IfcVibrationIsolator",
                "id": 2391383451
              }],
              "name": "IfcElementComponent",
              "id": 1623761950
            }, {
              "children": [{
                "children": [{
                  "name": "IfcProjectionElement",
                  "id": 3651124850
                }],
                "name": "IfcFeatureElementAddition",
                "id": 2143335405
              }, {
                "children": [{
                  "children": [{
                    "name": "IfcOpeningStandardCase",
                    "id": 3079942009
                  }],
                  "name": "IfcOpeningElement",
                  "id": 3588315303
                }, {
                  "name": "IfcVoidingFeature",
                  "id": 926996030
                }],
                "name": "IfcFeatureElementSubtraction",
                "id": 1287392070
              }, {
                "name": "IfcSurfaceFeature",
                "id": 3101698114
              }],
              "name": "IfcFeatureElement",
              "id": 2827207264
            }, {
              "children": [{
                "name": "IfcFurniture",
                "id": 1509553395
              }, {
                "name": "IfcSystemFurnitureElement",
                "id": 413509423
              }],
              "name": "IfcFurnishingElement",
              "id": 263784265
            }, {
              "name": "IfcGeographicElement",
              "id": 3493046030
            }, {
              "name": "IfcTransportElement",
              "id": 1620046519
            }, {
              "name": "IfcVirtualElement",
              "id": 2769231204
            }],
            "name": "IfcElement",
            "id": 1758889154
          }, {
            "name": "IfcGrid",
            "id": 3009204131
          }, {
            "children": [{
              "name": "IfcDistributionPort",
              "id": 3041715199
            }],
            "name": "IfcPort",
            "id": 3740093272
          }, {
            "name": "IfcProxy",
            "id": 3219374653
          }, {
            "children": [{
              "children": [{
                "name": "IfcExternalSpatialElement",
                "id": 1209101575
              }],
              "name": "IfcExternalSpatialStructureElement",
              "id": 2853485674
            }, {
              "children": [{
                "name": "IfcBuilding",
                "id": 4031249490
              }, {
                "name": "IfcBuildingStorey",
                "id": 3124254112
              }, {
                "name": "IfcSite",
                "id": 4097777520
              }, {
                "name": "IfcSpace",
                "id": 3856911033
              }],
              "name": "IfcSpatialStructureElement",
              "id": 2706606064
            }, {
              "name": "IfcSpatialZone",
              "id": 463610769
            }],
            "name": "IfcSpatialElement",
            "id": 1412071761
          }, {
            "children": [{
              "children": [{
                "children": [{
                  "name": "IfcStructuralLinearAction",
                  "id": 1807405624
                }],
                "name": "IfcStructuralCurveAction",
                "id": 1004757350
              }, {
                "name": "IfcStructuralPointAction",
                "id": 2082059205
              }, {
                "children": [{
                  "name": "IfcStructuralPlanarAction",
                  "id": 1621171031
                }],
                "name": "IfcStructuralSurfaceAction",
                "id": 3657597509
              }],
              "name": "IfcStructuralAction",
              "id": 682877961
            }, {
              "children": [{
                "name": "IfcStructuralCurveReaction",
                "id": 2757150158
              }, {
                "name": "IfcStructuralPointReaction",
                "id": 1235345126
              }, {
                "name": "IfcStructuralSurfaceReaction",
                "id": 603775116
              }],
              "name": "IfcStructuralReaction",
              "id": 3689010777
            }],
            "name": "IfcStructuralActivity",
            "id": 3544373492
          }, {
            "children": [{
              "children": [{
                "name": "IfcStructuralCurveConnection",
                "id": 4243806635
              }, {
                "name": "IfcStructuralPointConnection",
                "id": 734778138
              }, {
                "name": "IfcStructuralSurfaceConnection",
                "id": 1975003073
              }],
              "name": "IfcStructuralConnection",
              "id": 1179482911
            }, {
              "children": [{
                "children": [{
                  "name": "IfcStructuralCurveMemberVarying",
                  "id": 2445595289
                }],
                "name": "IfcStructuralCurveMember",
                "id": 214636428
              }, {
                "children": [{
                  "name": "IfcStructuralSurfaceMemberVarying",
                  "id": 2218152070
                }],
                "name": "IfcStructuralSurfaceMember",
                "id": 3979015343
              }],
              "name": "IfcStructuralMember",
              "id": 530289379
            }],
            "name": "IfcStructuralItem",
            "id": 3136571912
          }],
          "name": "IfcProduct",
          "id": 4208778838
        }, {
          "children": [{
            "children": [{
              "name": "IfcConstructionEquipmentResource",
              "id": 3898045240
            }, {
              "name": "IfcConstructionMaterialResource",
              "id": 1060000209
            }, {
              "name": "IfcConstructionProductResource",
              "id": 488727124
            }, {
              "name": "IfcCrewResource",
              "id": 3295246426
            }, {
              "name": "IfcLaborResource",
              "id": 3827777499
            }, {
              "name": "IfcSubContractResource",
              "id": 148013059
            }],
            "name": "IfcConstructionResource",
            "id": 2559216714
          }],
          "name": "IfcResource",
          "id": 2914609552
        }],
        "name": "IfcObject",
        "id": 3888040117
      }, {
        "children": [{
          "children": [{
            "name": "IfcEventType",
            "id": 4024345920
          }, {
            "name": "IfcProcedureType",
            "id": 569719735
          }, {
            "name": "IfcTaskType",
            "id": 3206491090
          }],
          "name": "IfcTypeProcess",
          "id": 3736923433
        }, {
          "children": [{
            "name": "IfcDoorStyle",
            "id": 526551008
          }, {
            "children": [{
              "children": [{
                "name": "IfcBeamType",
                "id": 819618141
              }, {
                "name": "IfcBuildingElementProxyType",
                "id": 1909888760
              }, {
                "name": "IfcChimneyType",
                "id": 2197970202
              }, {
                "name": "IfcColumnType",
                "id": 300633059
              }, {
                "name": "IfcCoveringType",
                "id": 1916426348
              }, {
                "name": "IfcCurtainWallType",
                "id": 1457835157
              }, {
                "name": "IfcDoorType",
                "id": 2323601079
              }, {
                "name": "IfcFootingType",
                "id": 1893162501
              }, {
                "name": "IfcMemberType",
                "id": 3181161470
              }, {
                "name": "IfcPileType",
                "id": 1158309216
              }, {
                "name": "IfcPlateType",
                "id": 4017108033
              }, {
                "name": "IfcRailingType",
                "id": 2893384427
              }, {
                "name": "IfcRampFlightType",
                "id": 2324767716
              }, {
                "name": "IfcRampType",
                "id": 1469900589
              }, {
                "name": "IfcRoofType",
                "id": 2781568857
              }, {
                "name": "IfcShadingDeviceType",
                "id": 4074543187
              }, {
                "name": "IfcSlabType",
                "id": 2533589738
              }, {
                "name": "IfcStairFlightType",
                "id": 1039846685
              }, {
                "name": "IfcStairType",
                "id": 338393293
              }, {
                "name": "IfcWallType",
                "id": 1898987631
              }, {
                "name": "IfcWindowType",
                "id": 4009809668
              }],
              "name": "IfcBuildingElementType",
              "id": 1950629157
            }, {
              "name": "IfcCivilElementType",
              "id": 3893394355
            }, {
              "children": [{
                "children": [{
                  "name": "IfcActuatorType",
                  "id": 2874132201
                }, {
                  "name": "IfcAlarmType",
                  "id": 3001207471
                }, {
                  "name": "IfcControllerType",
                  "id": 578613899
                }, {
                  "name": "IfcFlowInstrumentType",
                  "id": 4037862832
                }, {
                  "name": "IfcProtectiveDeviceTrippingUnitType",
                  "id": 655969474
                }, {
                  "name": "IfcSensorType",
                  "id": 1783015770
                }, {
                  "name": "IfcUnitaryControlElementType",
                  "id": 3179687236
                }],
                "name": "IfcDistributionControlElementType",
                "id": 2063403501
              }, {
                "children": [{
                  "name": "IfcDistributionChamberElementType",
                  "id": 1599208980
                }, {
                  "children": [{
                    "name": "IfcAirToAirHeatRecoveryType",
                    "id": 1871374353
                  }, {
                    "name": "IfcBoilerType",
                    "id": 231477066
                  }, {
                    "name": "IfcBurnerType",
                    "id": 2188180465
                  }, {
                    "name": "IfcChillerType",
                    "id": 2951183804
                  }, {
                    "name": "IfcCoilType",
                    "id": 2301859152
                  }, {
                    "name": "IfcCondenserType",
                    "id": 2816379211
                  }, {
                    "name": "IfcCooledBeamType",
                    "id": 335055490
                  }, {
                    "name": "IfcCoolingTowerType",
                    "id": 2954562838
                  }, {
                    "name": "IfcElectricGeneratorType",
                    "id": 1534661035
                  }, {
                    "name": "IfcElectricMotorType",
                    "id": 1217240411
                  }, {
                    "name": "IfcEngineType",
                    "id": 132023988
                  }, {
                    "name": "IfcEvaporativeCoolerType",
                    "id": 3174744832
                  }, {
                    "name": "IfcEvaporatorType",
                    "id": 3390157468
                  }, {
                    "name": "IfcHeatExchangerType",
                    "id": 1251058090
                  }, {
                    "name": "IfcHumidifierType",
                    "id": 1806887404
                  }, {
                    "name": "IfcMotorConnectionType",
                    "id": 977012517
                  }, {
                    "name": "IfcSolarDeviceType",
                    "id": 1072016465
                  }, {
                    "name": "IfcTransformerType",
                    "id": 1692211062
                  }, {
                    "name": "IfcTubeBundleType",
                    "id": 1600972822
                  }, {
                    "name": "IfcUnitaryEquipmentType",
                    "id": 1911125066
                  }],
                  "name": "IfcEnergyConversionDeviceType",
                  "id": 2107101300
                }, {
                  "children": [{
                    "name": "IfcAirTerminalBoxType",
                    "id": 1411407467
                  }, {
                    "name": "IfcDamperType",
                    "id": 3961806047
                  }, {
                    "name": "IfcElectricDistributionBoardType",
                    "id": 2417008758
                  }, {
                    "name": "IfcElectricTimeControlType",
                    "id": 712377611
                  }, {
                    "name": "IfcFlowMeterType",
                    "id": 3815607619
                  }, {
                    "name": "IfcProtectiveDeviceType",
                    "id": 1842657554
                  }, {
                    "name": "IfcSwitchingDeviceType",
                    "id": 2315554128
                  }, {
                    "name": "IfcValveType",
                    "id": 728799441
                  }],
                  "name": "IfcFlowControllerType",
                  "id": 3907093117
                }, {
                  "children": [{
                    "name": "IfcCableCarrierFittingType",
                    "id": 395041908
                  }, {
                    "name": "IfcCableFittingType",
                    "id": 2674252688
                  }, {
                    "name": "IfcDuctFittingType",
                    "id": 869906466
                  }, {
                    "name": "IfcJunctionBoxType",
                    "id": 4288270099
                  }, {
                    "name": "IfcPipeFittingType",
                    "id": 804291784
                  }],
                  "name": "IfcFlowFittingType",
                  "id": 3198132628
                }, {
                  "children": [{
                    "name": "IfcCompressorType",
                    "id": 3850581409
                  }, {
                    "name": "IfcFanType",
                    "id": 346874300
                  }, {
                    "name": "IfcPumpType",
                    "id": 2250791053
                  }],
                  "name": "IfcFlowMovingDeviceType",
                  "id": 1482959167
                }, {
                  "children": [{
                    "name": "IfcCableCarrierSegmentType",
                    "id": 3293546465
                  }, {
                    "name": "IfcCableSegmentType",
                    "id": 1285652485
                  }, {
                    "name": "IfcDuctSegmentType",
                    "id": 3760055223
                  }, {
                    "name": "IfcPipeSegmentType",
                    "id": 4231323485
                  }],
                  "name": "IfcFlowSegmentType",
                  "id": 1834744321
                }, {
                  "children": [{
                    "name": "IfcElectricFlowStorageDeviceType",
                    "id": 3277789161
                  }, {
                    "name": "IfcTankType",
                    "id": 5716631
                  }],
                  "name": "IfcFlowStorageDeviceType",
                  "id": 1339347760
                }, {
                  "children": [{
                    "name": "IfcAirTerminalType",
                    "id": 3352864051
                  }, {
                    "name": "IfcAudioVisualApplianceType",
                    "id": 1532957894
                  }, {
                    "name": "IfcCommunicationsApplianceType",
                    "id": 400855858
                  }, {
                    "name": "IfcElectricApplianceType",
                    "id": 663422040
                  }, {
                    "name": "IfcFireSuppressionTerminalType",
                    "id": 4222183408
                  }, {
                    "name": "IfcLampType",
                    "id": 1051575348
                  }, {
                    "name": "IfcLightFixtureType",
                    "id": 1161773419
                  }, {
                    "name": "IfcMedicalDeviceType",
                    "id": 1114901282
                  }, {
                    "name": "IfcOutletType",
                    "id": 2837617999
                  }, {
                    "name": "IfcSanitaryTerminalType",
                    "id": 1768891740
                  }, {
                    "name": "IfcSpaceHeaterType",
                    "id": 1305183839
                  }, {
                    "name": "IfcStackTerminalType",
                    "id": 3112655638
                  }, {
                    "name": "IfcWasteTerminalType",
                    "id": 1133259667
                  }],
                  "name": "IfcFlowTerminalType",
                  "id": 2297155007
                }, {
                  "children": [{
                    "name": "IfcDuctSilencerType",
                    "id": 2030761528
                  }, {
                    "name": "IfcFilterType",
                    "id": 1810631287
                  }, {
                    "name": "IfcInterceptorType",
                    "id": 3946677679
                  }],
                  "name": "IfcFlowTreatmentDeviceType",
                  "id": 3009222698
                }],
                "name": "IfcDistributionFlowElementType",
                "id": 3849074793
              }],
              "name": "IfcDistributionElementType",
              "id": 3256556792
            }, {
              "name": "IfcElementAssemblyType",
              "id": 2397081782
            }, {
              "children": [{
                "name": "IfcBuildingElementPartType",
                "id": 39481116
              }, {
                "name": "IfcDiscreteAccessoryType",
                "id": 2635815018
              }, {
                "name": "IfcFastenerType",
                "id": 2489546625
              }, {
                "name": "IfcMechanicalFastenerType",
                "id": 2108223431
              }, {
                "children": [{
                  "name": "IfcReinforcingBarType",
                  "id": 2572171363
                }, {
                  "name": "IfcReinforcingMeshType",
                  "id": 2310774935
                }, {
                  "name": "IfcTendonAnchorType",
                  "id": 3081323446
                }, {
                  "name": "IfcTendonType",
                  "id": 2415094496
                }],
                "name": "IfcReinforcingElementType",
                "id": 964333572
              }, {
                "name": "IfcVibrationIsolatorType",
                "id": 3313531582
              }],
              "name": "IfcElementComponentType",
              "id": 2590856083
            }, {
              "children": [{
                "name": "IfcFurnitureType",
                "id": 1268542332
              }, {
                "name": "IfcSystemFurnitureElementType",
                "id": 1580310250
              }],
              "name": "IfcFurnishingElementType",
              "id": 4238390223
            }, {
              "name": "IfcGeographicElementType",
              "id": 4095422895
            }, {
              "name": "IfcTransportElementType",
              "id": 2097647324
            }],
            "name": "IfcElementType",
            "id": 339256511
          }, {
            "children": [{
              "children": [{
                "name": "IfcSpaceType",
                "id": 3812236995
              }],
              "name": "IfcSpatialStructureElementType",
              "id": 3893378262
            }, {
              "name": "IfcSpatialZoneType",
              "id": 2481509218
            }],
            "name": "IfcSpatialElementType",
            "id": 710998568
          }, {
            "name": "IfcWindowStyle",
            "id": 1299126871
          }],
          "name": "IfcTypeProduct",
          "id": 2347495698
        }, {
          "children": [{
            "children": [{
              "name": "IfcConstructionEquipmentResourceType",
              "id": 2185764099
            }, {
              "name": "IfcConstructionMaterialResourceType",
              "id": 4105962743
            }, {
              "name": "IfcConstructionProductResourceType",
              "id": 1525564444
            }, {
              "name": "IfcCrewResourceType",
              "id": 1815067380
            }, {
              "name": "IfcLaborResourceType",
              "id": 428585644
            }, {
              "name": "IfcSubContractResourceType",
              "id": 4095615324
            }],
            "name": "IfcConstructionResourceType",
            "id": 2574617495
          }],
          "name": "IfcTypeResource",
          "id": 3698973494
        }],
        "name": "IfcTypeObject",
        "id": 1628702193
      }],
      "name": "IfcObjectDefinition",
      "id": 219451334
    }, {
      "children": [{
        "children": [{
          "children": [{
            "name": "IfcDoorLiningProperties",
            "id": 2963535650
          }, {
            "name": "IfcDoorPanelProperties",
            "id": 1714330368
          }, {
            "name": "IfcPermeableCoveringProperties",
            "id": 3566463478
          }, {
            "name": "IfcReinforcementDefinitionProperties",
            "id": 3765753017
          }, {
            "name": "IfcWindowLiningProperties",
            "id": 336235671
          }, {
            "name": "IfcWindowPanelProperties",
            "id": 512836454
          }],
          "name": "IfcPreDefinedPropertySet",
          "id": 3967405729
        }, {
          "name": "IfcPropertySet",
          "id": 1451395588
        }, {
          "children": [{
            "name": "IfcElementQuantity",
            "id": 1883228015
          }],
          "name": "IfcQuantitySet",
          "id": 2090586900
        }],
        "name": "IfcPropertySetDefinition",
        "id": 3357820518
      }, {
        "children": [{
          "name": "IfcPropertySetTemplate",
          "id": 492091185
        }, {
          "children": [{
            "name": "IfcComplexPropertyTemplate",
            "id": 3875453745
          }, {
            "name": "IfcSimplePropertyTemplate",
            "id": 3663146110
          }],
          "name": "IfcPropertyTemplate",
          "id": 3521284610
        }],
        "name": "IfcPropertyTemplateDefinition",
        "id": 1482703590
      }],
      "name": "IfcPropertyDefinition",
      "id": 1680319473
    }, {
      "children": [{
        "children": [{
          "name": "IfcRelAssignsToActor",
          "id": 1683148259
        }, {
          "name": "IfcRelAssignsToControl",
          "id": 2495723537
        }, {
          "children": [{
            "name": "IfcRelAssignsToGroupByFactor",
            "id": 1027710054
          }],
          "name": "IfcRelAssignsToGroup",
          "id": 1307041759
        }, {
          "name": "IfcRelAssignsToProcess",
          "id": 4278684876
        }, {
          "name": "IfcRelAssignsToProduct",
          "id": 2857406711
        }, {
          "name": "IfcRelAssignsToResource",
          "id": 205026976
        }],
        "name": "IfcRelAssigns",
        "id": 3939117080
      }, {
        "children": [{
          "name": "IfcRelAssociatesApproval",
          "id": 4095574036
        }, {
          "name": "IfcRelAssociatesClassification",
          "id": 919958153
        }, {
          "name": "IfcRelAssociatesConstraint",
          "id": 2728634034
        }, {
          "name": "IfcRelAssociatesDocument",
          "id": 982818633
        }, {
          "name": "IfcRelAssociatesLibrary",
          "id": 3840914261
        }, {
          "name": "IfcRelAssociatesMaterial",
          "id": 2655215786
        }],
        "name": "IfcRelAssociates",
        "id": 1865459582
      }, {
        "children": [{
          "children": [{
            "name": "IfcRelConnectsPathElements",
            "id": 3945020480
          }, {
            "name": "IfcRelConnectsWithRealizingElements",
            "id": 3678494232
          }],
          "name": "IfcRelConnectsElements",
          "id": 1204542856
        }, {
          "name": "IfcRelConnectsPortToElement",
          "id": 4201705270
        }, {
          "name": "IfcRelConnectsPorts",
          "id": 3190031847
        }, {
          "name": "IfcRelConnectsStructuralActivity",
          "id": 2127690289
        }, {
          "children": [{
            "name": "IfcRelConnectsWithEccentricity",
            "id": 504942748
          }],
          "name": "IfcRelConnectsStructuralMember",
          "id": 1638771189
        }, {
          "name": "IfcRelContainedInSpatialStructure",
          "id": 3242617779
        }, {
          "name": "IfcRelCoversBldgElements",
          "id": 886880790
        }, {
          "name": "IfcRelCoversSpaces",
          "id": 2802773753
        }, {
          "name": "IfcRelFillsElement",
          "id": 3940055652
        }, {
          "name": "IfcRelFlowControlElements",
          "id": 279856033
        }, {
          "name": "IfcRelInterferesElements",
          "id": 427948657
        }, {
          "name": "IfcRelReferencedInSpatialStructure",
          "id": 1245217292
        }, {
          "name": "IfcRelSequence",
          "id": 4122056220
        }, {
          "name": "IfcRelServicesBuildings",
          "id": 366585022
        }, {
          "children": [{
            "children": [{
              "name": "IfcRelSpaceBoundary2ndLevel",
              "id": 1521410863
            }],
            "name": "IfcRelSpaceBoundary1stLevel",
            "id": 3523091289
          }],
          "name": "IfcRelSpaceBoundary",
          "id": 3451746338
        }],
        "name": "IfcRelConnects",
        "id": 826625072
      }, {
        "name": "IfcRelDeclares",
        "id": 2565941209
      }, {
        "children": [{
          "name": "IfcRelAggregates",
          "id": 160246688
        }, {
          "name": "IfcRelNests",
          "id": 3268803585
        }, {
          "name": "IfcRelProjectsElement",
          "id": 750771296
        }, {
          "name": "IfcRelVoidsElement",
          "id": 1401173127
        }],
        "name": "IfcRelDecomposes",
        "id": 2551354335
      }, {
        "children": [{
          "name": "IfcRelDefinesByObject",
          "id": 1462361463
        }, {
          "name": "IfcRelDefinesByProperties",
          "id": 4186316022
        }, {
          "name": "IfcRelDefinesByTemplate",
          "id": 307848117
        }, {
          "name": "IfcRelDefinesByType",
          "id": 781010003
        }],
        "name": "IfcRelDefines",
        "id": 693640335
      }],
      "name": "IfcRelationship",
      "id": 478536968
    }],
    "name": "IfcRoot",
    "id": 2341007311
  };

  function getAllItemsOfTypeOrSubtype(_x, _x2, _x3) {
    return _getAllItemsOfTypeOrSubtype.apply(this, arguments);
  }

  function _getAllItemsOfTypeOrSubtype() {
    _getAllItemsOfTypeOrSubtype = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ifcAPI, modelID, ifcType) {
      var subTypes, items, i;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              subTypes = getItemSubtypes(ifcType);
              items = [];
              i = 0;

            case 3:
              if (!(i < subTypes.length)) {
                _context.next = 15;
                break;
              }

              _context.t0 = items.push;
              _context.t1 = items;
              _context.t2 = _toConsumableArray;
              _context.next = 9;
              return ifcAPI.properties.getAllItemsOfType(modelID, subTypes[i], false);

            case 9:
              _context.t3 = _context.sent;
              _context.t4 = (0, _context.t2)(_context.t3);

              _context.t0.apply.call(_context.t0, _context.t1, _context.t4);

            case 12:
              i++;
              _context.next = 3;
              break;

            case 15:
              return _context.abrupt("return", items);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _getAllItemsOfTypeOrSubtype.apply(this, arguments);
  }

  function getItemSubtypes(type) {
    var subTypes = []; // Get the tree node that corresponds to the requested type

    var treeNode = searchProductTree(IfcTypesTree, type);

    if (treeNode) {
      // Get all typeIds for the node itself and its subtypes
      collectAllIds(treeNode, subTypes);
    }

    return subTypes; // Search IfcProductTree for the particular typeID and get the node

    function searchProductTree(node, typeID) {
      if (node.id == typeID) {
        return node;
      } else if (node.children != null) {
        var i;
        var result = null;

        for (i = 0; result == null && i < node.children.length; i++) {
          result = searchProductTree(node.children[i], typeID);
        }

        return result;
      }

      return null;
    } // Collect all ids of tree node and its children


    function collectAllIds(node) {
      var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      ids.push(node.id);

      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          collectAllIds(node.children[i], ids);
        }
      }
    }
  }

  function buildClassInstances(_x, _x2, _x3, _x4) {
    return _buildClassInstances.apply(this, arguments);
  }

  function _buildClassInstances() {
    _buildClassInstances = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ifcAPI, modelID, ifcType, rdfClasses) {
      var includeSubTypes,
          items,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              includeSubTypes = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;

              if (!includeSubTypes) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return getAllItemsOfTypeOrSubtype(ifcAPI, modelID, ifcType);

            case 4:
              _context.t0 = _context.sent;
              _context.next = 10;
              break;

            case 7:
              _context.next = 9;
              return ifcAPI.properties.getAllItemsOfType(modelID, ifcType, false);

            case 9:
              _context.t0 = _context.sent;

            case 10:
              items = _context.t0;
              return _context.abrupt("return", buildClassInstancesFromExpressIDs(ifcAPI, modelID, items, rdfClasses));

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _buildClassInstances.apply(this, arguments);
  }

  function buildClassInstancesFromExpressIDs(_x5, _x6, _x7, _x8) {
    return _buildClassInstancesFromExpressIDs.apply(this, arguments);
  }

  function _buildClassInstancesFromExpressIDs() {
    _buildClassInstancesFromExpressIDs = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ifcAPI, modelID, expressIDs, rdfClasses) {
      var graph, i, expressID, _yield$ifcAPI$propert, GlobalId, URI;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              graph = [];
              i = 0;

            case 2:
              if (!(i < expressIDs.length)) {
                _context2.next = 13;
                break;
              }

              expressID = expressIDs[i];
              _context2.next = 6;
              return ifcAPI.properties.getItemProperties(modelID, expressID);

            case 6:
              _yield$ifcAPI$propert = _context2.sent;
              GlobalId = _yield$ifcAPI$propert.GlobalId;
              URI = defaultURIBuilder(GlobalId.value); // Push spaces

              graph.push({
                "@id": URI,
                "@type": rdfClasses
              });

            case 10:
              i++;
              _context2.next = 2;
              break;

            case 13:
              return _context2.abrupt("return", graph);

            case 14:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _buildClassInstancesFromExpressIDs.apply(this, arguments);
  }

  var SerializationFormat;

  (function (SerializationFormat) {
    SerializationFormat["NQuads"] = "nquads";
    SerializationFormat["JSONLD"] = "jsonld";
  })(SerializationFormat || (SerializationFormat = {}));

  var Mimetype;

  (function (Mimetype) {
    Mimetype["NTriples"] = "application/n-triples";
    Mimetype["Turtle"] = "text/turtle";
    Mimetype["NQuads"] = "application/n-quads";
    Mimetype["Trig"] = "application/trig";
    Mimetype["SPARQLJSON"] = "application/sparql-results+json";
    Mimetype["JSONLD"] = "application/ld+json";
    Mimetype["DLOG"] = "application/x.datalog";
  })(Mimetype || (Mimetype = {}));

  var N3Format;

  (function (N3Format) {
    N3Format["NTriples"] = "N-Triples";
    N3Format["Trig"] = "application/trig";
    N3Format["NQuads"] = "N-Quads";
    N3Format["Turtle"] = "Turtle";
  })(N3Format || (N3Format = {}));

  var prefixes = {
    "bot": "https://w3id.org/bot#",
    "ex": "https://example.com/",
    "fog": "https://w3id.org/fog#",
    "fso": "https://w3id.org/fso#",
    "ifc": "http://ifcowl.openbimstandards.org/IFC2X3_Final#",
    "inst": "https://example.com/",
    "omg": "https://w3id.org/omg#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "tso": "https://w3id.org/tso#"
  };

  var rdfDataFactory = {};

  var BlankNode$1 = {};

  Object.defineProperty(BlankNode$1, "__esModule", { value: true });
  BlankNode$1.BlankNode = void 0;
  /**
   * A term that represents an RDF blank node with a label.
   */
  class BlankNode {
      constructor(value) {
          this.termType = 'BlankNode';
          this.value = value;
      }
      equals(other) {
          return !!other && other.termType === 'BlankNode' && other.value === this.value;
      }
  }
  BlankNode$1.BlankNode = BlankNode;

  var DataFactory$1 = {};

  var DefaultGraph$1 = {};

  Object.defineProperty(DefaultGraph$1, "__esModule", { value: true });
  DefaultGraph$1.DefaultGraph = void 0;
  /**
   * A singleton term instance that represents the default graph.
   * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
   */
  class DefaultGraph {
      constructor() {
          this.termType = 'DefaultGraph';
          this.value = '';
          // Private constructor
      }
      equals(other) {
          return !!other && other.termType === 'DefaultGraph';
      }
  }
  DefaultGraph$1.DefaultGraph = DefaultGraph;
  DefaultGraph.INSTANCE = new DefaultGraph();

  var Literal$1 = {};

  var NamedNode$1 = {};

  Object.defineProperty(NamedNode$1, "__esModule", { value: true });
  NamedNode$1.NamedNode = void 0;
  /**
   * A term that contains an IRI.
   */
  class NamedNode {
      constructor(value) {
          this.termType = 'NamedNode';
          this.value = value;
      }
      equals(other) {
          return !!other && other.termType === 'NamedNode' && other.value === this.value;
      }
  }
  NamedNode$1.NamedNode = NamedNode;

  Object.defineProperty(Literal$1, "__esModule", { value: true });
  Literal$1.Literal = void 0;
  const NamedNode_1$1 = NamedNode$1;
  /**
   * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
   */
  class Literal {
      constructor(value, languageOrDatatype) {
          this.termType = 'Literal';
          this.value = value;
          if (typeof languageOrDatatype === 'string') {
              this.language = languageOrDatatype;
              this.datatype = Literal.RDF_LANGUAGE_STRING;
          }
          else if (languageOrDatatype) {
              this.language = '';
              this.datatype = languageOrDatatype;
          }
          else {
              this.language = '';
              this.datatype = Literal.XSD_STRING;
          }
      }
      equals(other) {
          return !!other && other.termType === 'Literal' && other.value === this.value &&
              other.language === this.language && other.datatype.equals(this.datatype);
      }
  }
  Literal$1.Literal = Literal;
  Literal.RDF_LANGUAGE_STRING = new NamedNode_1$1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
  Literal.XSD_STRING = new NamedNode_1$1.NamedNode('http://www.w3.org/2001/XMLSchema#string');

  var Quad$1 = {};

  Object.defineProperty(Quad$1, "__esModule", { value: true });
  Quad$1.Quad = void 0;
  /**
   * An instance of DefaultGraph represents the default graph.
   * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
   */
  class Quad {
      constructor(subject, predicate, object, graph) {
          this.termType = 'Quad';
          this.value = '';
          this.subject = subject;
          this.predicate = predicate;
          this.object = object;
          this.graph = graph;
      }
      equals(other) {
          // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
          return !!other && (other.termType === 'Quad' || !other.termType) &&
              this.subject.equals(other.subject) &&
              this.predicate.equals(other.predicate) &&
              this.object.equals(other.object) &&
              this.graph.equals(other.graph);
      }
  }
  Quad$1.Quad = Quad;

  var Variable$1 = {};

  Object.defineProperty(Variable$1, "__esModule", { value: true });
  Variable$1.Variable = void 0;
  /**
   * A term that represents a variable.
   */
  class Variable {
      constructor(value) {
          this.termType = 'Variable';
          this.value = value;
      }
      equals(other) {
          return !!other && other.termType === 'Variable' && other.value === this.value;
      }
  }
  Variable$1.Variable = Variable;

  Object.defineProperty(DataFactory$1, "__esModule", { value: true });
  DataFactory$1.DataFactory = void 0;
  const BlankNode_1 = BlankNode$1;
  const DefaultGraph_1 = DefaultGraph$1;
  const Literal_1 = Literal$1;
  const NamedNode_1 = NamedNode$1;
  const Quad_1 = Quad$1;
  const Variable_1 = Variable$1;
  let dataFactoryCounter = 0;
  /**
   * A factory for instantiating RDF terms and quads.
   */
  class DataFactory {
      constructor(options) {
          this.blankNodeCounter = 0;
          options = options || {};
          this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
      }
      /**
       * @param value The IRI for the named node.
       * @return A new instance of NamedNode.
       * @see NamedNode
       */
      namedNode(value) {
          return new NamedNode_1.NamedNode(value);
      }
      /**
       * @param value The optional blank node identifier.
       * @return A new instance of BlankNode.
       *         If the `value` parameter is undefined a new identifier
       *         for the blank node is generated for each call.
       * @see BlankNode
       */
      blankNode(value) {
          return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
      }
      /**
       * @param value              The literal value.
       * @param languageOrDatatype The optional language or datatype.
       *                           If `languageOrDatatype` is a NamedNode,
       *                           then it is used for the value of `NamedNode.datatype`.
       *                           Otherwise `languageOrDatatype` is used for the value
       *                           of `NamedNode.language`.
       * @return A new instance of Literal.
       * @see Literal
       */
      literal(value, languageOrDatatype) {
          return new Literal_1.Literal(value, languageOrDatatype);
      }
      /**
       * This method is optional.
       * @param value The variable name
       * @return A new instance of Variable.
       * @see Variable
       */
      variable(value) {
          return new Variable_1.Variable(value);
      }
      /**
       * @return An instance of DefaultGraph.
       */
      defaultGraph() {
          return DefaultGraph_1.DefaultGraph.INSTANCE;
      }
      /**
       * @param subject   The quad subject term.
       * @param predicate The quad predicate term.
       * @param object    The quad object term.
       * @param graph     The quad graph term.
       * @return A new instance of Quad.
       * @see Quad
       */
      quad(subject, predicate, object, graph) {
          return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
      }
      /**
       * Create a deep copy of the given term using this data factory.
       * @param original An RDF term.
       * @return A deep copy of the given term.
       */
      fromTerm(original) {
          // TODO: remove nasty any casts when this TS bug has been fixed:
          //  https://github.com/microsoft/TypeScript/issues/26933
          switch (original.termType) {
              case 'NamedNode':
                  return this.namedNode(original.value);
              case 'BlankNode':
                  return this.blankNode(original.value);
              case 'Literal':
                  if (original.language) {
                      return this.literal(original.value, original.language);
                  }
                  if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
                      return this.literal(original.value, this.fromTerm(original.datatype));
                  }
                  return this.literal(original.value);
              case 'Variable':
                  return this.variable(original.value);
              case 'DefaultGraph':
                  return this.defaultGraph();
              case 'Quad':
                  return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
          }
      }
      /**
       * Create a deep copy of the given quad using this data factory.
       * @param original An RDF quad.
       * @return A deep copy of the given quad.
       */
      fromQuad(original) {
          return this.fromTerm(original);
      }
      /**
       * Reset the internal blank node counter.
       */
      resetBlankNodeCounter() {
          this.blankNodeCounter = 0;
      }
  }
  DataFactory$1.DataFactory = DataFactory;

  (function (exports) {
  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(BlankNode$1, exports);
  __exportStar(DataFactory$1, exports);
  __exportStar(DefaultGraph$1, exports);
  __exportStar(Literal$1, exports);
  __exportStar(NamedNode$1, exports);
  __exportStar(Quad$1, exports);
  __exportStar(Variable$1, exports);

  }(rdfDataFactory));

  var DF = new rdfDataFactory.DataFactory();
  var extensionFunctions = {
    'http://example.org/functions#to-upper-case': function httpExampleOrgFunctionsToUpperCase(args) {
      var arg = args[0];

      if (arg.termType === 'Literal' && arg.datatype.value === 'http://www.w3.org/2001/XMLSchema#string') {
        return DF.literal(arg.value.toUpperCase(), arg.datatype);
      }

      return arg;
    },
    'http://example.org/functions#get-id': function httpExampleOrgFunctionsGetId(args) {
      var arg = args[0];

      if (arg.termType === 'NamedNode') {
        return DF.literal(getID(arg));
      }

      return arg;
    },
    'http://example.org/functions#get-namespace': function httpExampleOrgFunctionsGetNamespace(args) {
      var arg = args[0];

      if (arg.termType === 'NamedNode') {
        return DF.literal(getNamespace(arg));
      }

      return arg;
    },
    'http://example.org/functions#uri-concat': function httpExampleOrgFunctionsUriConcat(args) {
      var uri1 = args[0];
      var uri2 = args[1];

      if (uri1.termType === 'NamedNode' && uri2.termType === 'NamedNode') {
        var ns = getNamespace(uri1);
        var id1 = getID(uri1);
        var id2 = getID(uri2);
        return DF.namedNode(ns + id1 + id2);
      }

      return DF.literal("ERROR");
    }
  };

  function getID(uri) {
    return uri.value.indexOf("#") != -1 ? uri.value.split("#")[1] : uri.value.split("/").pop();
  }

  function getNamespace(uri) {
    if (uri.value.indexOf("#") != -1) {
      return uri.value.split("#")[0] + "#";
    } else {
      var arr = uri.value.split("/");
      arr.pop();
      return arr.join("/") + "/";
    }
  }

  var bundle_umd = {exports: {}};

  (function (module, exports) {
  (function (global, factory) {
  	factory(exports) ;
  })(commonjsGlobal, (function (exports) {
  	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

  	var rdfDataFactory = {};

  	var BlankNode$1 = {};

  	Object.defineProperty(BlankNode$1, "__esModule", { value: true });
  	BlankNode$1.BlankNode = void 0;
  	/**
  	 * A term that represents an RDF blank node with a label.
  	 */
  	class BlankNode {
  	    constructor(value) {
  	        this.termType = 'BlankNode';
  	        this.value = value;
  	    }
  	    equals(other) {
  	        return !!other && other.termType === 'BlankNode' && other.value === this.value;
  	    }
  	}
  	BlankNode$1.BlankNode = BlankNode;

  	var DataFactory$1 = {};

  	var DefaultGraph$1 = {};

  	Object.defineProperty(DefaultGraph$1, "__esModule", { value: true });
  	DefaultGraph$1.DefaultGraph = void 0;
  	/**
  	 * A singleton term instance that represents the default graph.
  	 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
  	 */
  	class DefaultGraph {
  	    constructor() {
  	        this.termType = 'DefaultGraph';
  	        this.value = '';
  	        // Private constructor
  	    }
  	    equals(other) {
  	        return !!other && other.termType === 'DefaultGraph';
  	    }
  	}
  	DefaultGraph$1.DefaultGraph = DefaultGraph;
  	DefaultGraph.INSTANCE = new DefaultGraph();

  	var Literal$1 = {};

  	var NamedNode$1 = {};

  	Object.defineProperty(NamedNode$1, "__esModule", { value: true });
  	NamedNode$1.NamedNode = void 0;
  	/**
  	 * A term that contains an IRI.
  	 */
  	class NamedNode {
  	    constructor(value) {
  	        this.termType = 'NamedNode';
  	        this.value = value;
  	    }
  	    equals(other) {
  	        return !!other && other.termType === 'NamedNode' && other.value === this.value;
  	    }
  	}
  	NamedNode$1.NamedNode = NamedNode;

  	Object.defineProperty(Literal$1, "__esModule", { value: true });
  	Literal$1.Literal = void 0;
  	const NamedNode_1$1 = NamedNode$1;
  	/**
  	 * A term that represents an RDF literal, containing a string with an optional language tag or datatype.
  	 */
  	class Literal {
  	    constructor(value, languageOrDatatype) {
  	        this.termType = 'Literal';
  	        this.value = value;
  	        if (typeof languageOrDatatype === 'string') {
  	            this.language = languageOrDatatype;
  	            this.datatype = Literal.RDF_LANGUAGE_STRING;
  	        }
  	        else if (languageOrDatatype) {
  	            this.language = '';
  	            this.datatype = languageOrDatatype;
  	        }
  	        else {
  	            this.language = '';
  	            this.datatype = Literal.XSD_STRING;
  	        }
  	    }
  	    equals(other) {
  	        return !!other && other.termType === 'Literal' && other.value === this.value &&
  	            other.language === this.language && other.datatype.equals(this.datatype);
  	    }
  	}
  	Literal$1.Literal = Literal;
  	Literal.RDF_LANGUAGE_STRING = new NamedNode_1$1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
  	Literal.XSD_STRING = new NamedNode_1$1.NamedNode('http://www.w3.org/2001/XMLSchema#string');

  	var Quad$1 = {};

  	Object.defineProperty(Quad$1, "__esModule", { value: true });
  	Quad$1.Quad = void 0;
  	/**
  	 * An instance of DefaultGraph represents the default graph.
  	 * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.
  	 */
  	class Quad {
  	    constructor(subject, predicate, object, graph) {
  	        this.termType = 'Quad';
  	        this.value = '';
  	        this.subject = subject;
  	        this.predicate = predicate;
  	        this.object = object;
  	        this.graph = graph;
  	    }
  	    equals(other) {
  	        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.
  	        return !!other && (other.termType === 'Quad' || !other.termType) &&
  	            this.subject.equals(other.subject) &&
  	            this.predicate.equals(other.predicate) &&
  	            this.object.equals(other.object) &&
  	            this.graph.equals(other.graph);
  	    }
  	}
  	Quad$1.Quad = Quad;

  	var Variable$1 = {};

  	Object.defineProperty(Variable$1, "__esModule", { value: true });
  	Variable$1.Variable = void 0;
  	/**
  	 * A term that represents a variable.
  	 */
  	class Variable {
  	    constructor(value) {
  	        this.termType = 'Variable';
  	        this.value = value;
  	    }
  	    equals(other) {
  	        return !!other && other.termType === 'Variable' && other.value === this.value;
  	    }
  	}
  	Variable$1.Variable = Variable;

  	Object.defineProperty(DataFactory$1, "__esModule", { value: true });
  	DataFactory$1.DataFactory = void 0;
  	const BlankNode_1 = BlankNode$1;
  	const DefaultGraph_1 = DefaultGraph$1;
  	const Literal_1 = Literal$1;
  	const NamedNode_1 = NamedNode$1;
  	const Quad_1 = Quad$1;
  	const Variable_1 = Variable$1;
  	let dataFactoryCounter = 0;
  	/**
  	 * A factory for instantiating RDF terms and quads.
  	 */
  	class DataFactory {
  	    constructor(options) {
  	        this.blankNodeCounter = 0;
  	        options = options || {};
  	        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
  	    }
  	    /**
  	     * @param value The IRI for the named node.
  	     * @return A new instance of NamedNode.
  	     * @see NamedNode
  	     */
  	    namedNode(value) {
  	        return new NamedNode_1.NamedNode(value);
  	    }
  	    /**
  	     * @param value The optional blank node identifier.
  	     * @return A new instance of BlankNode.
  	     *         If the `value` parameter is undefined a new identifier
  	     *         for the blank node is generated for each call.
  	     * @see BlankNode
  	     */
  	    blankNode(value) {
  	        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
  	    }
  	    /**
  	     * @param value              The literal value.
  	     * @param languageOrDatatype The optional language or datatype.
  	     *                           If `languageOrDatatype` is a NamedNode,
  	     *                           then it is used for the value of `NamedNode.datatype`.
  	     *                           Otherwise `languageOrDatatype` is used for the value
  	     *                           of `NamedNode.language`.
  	     * @return A new instance of Literal.
  	     * @see Literal
  	     */
  	    literal(value, languageOrDatatype) {
  	        return new Literal_1.Literal(value, languageOrDatatype);
  	    }
  	    /**
  	     * This method is optional.
  	     * @param value The variable name
  	     * @return A new instance of Variable.
  	     * @see Variable
  	     */
  	    variable(value) {
  	        return new Variable_1.Variable(value);
  	    }
  	    /**
  	     * @return An instance of DefaultGraph.
  	     */
  	    defaultGraph() {
  	        return DefaultGraph_1.DefaultGraph.INSTANCE;
  	    }
  	    /**
  	     * @param subject   The quad subject term.
  	     * @param predicate The quad predicate term.
  	     * @param object    The quad object term.
  	     * @param graph     The quad graph term.
  	     * @return A new instance of Quad.
  	     * @see Quad
  	     */
  	    quad(subject, predicate, object, graph) {
  	        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());
  	    }
  	    /**
  	     * Create a deep copy of the given term using this data factory.
  	     * @param original An RDF term.
  	     * @return A deep copy of the given term.
  	     */
  	    fromTerm(original) {
  	        // TODO: remove nasty any casts when this TS bug has been fixed:
  	        //  https://github.com/microsoft/TypeScript/issues/26933
  	        switch (original.termType) {
  	            case 'NamedNode':
  	                return this.namedNode(original.value);
  	            case 'BlankNode':
  	                return this.blankNode(original.value);
  	            case 'Literal':
  	                if (original.language) {
  	                    return this.literal(original.value, original.language);
  	                }
  	                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
  	                    return this.literal(original.value, this.fromTerm(original.datatype));
  	                }
  	                return this.literal(original.value);
  	            case 'Variable':
  	                return this.variable(original.value);
  	            case 'DefaultGraph':
  	                return this.defaultGraph();
  	            case 'Quad':
  	                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
  	        }
  	    }
  	    /**
  	     * Create a deep copy of the given quad using this data factory.
  	     * @param original An RDF quad.
  	     * @return A deep copy of the given quad.
  	     */
  	    fromQuad(original) {
  	        return this.fromTerm(original);
  	    }
  	    /**
  	     * Reset the internal blank node counter.
  	     */
  	    resetBlankNodeCounter() {
  	        this.blankNodeCounter = 0;
  	    }
  	}
  	DataFactory$1.DataFactory = DataFactory;

  	(function (exports) {
  	var __createBinding = (commonjsGlobal$1 && commonjsGlobal$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  	}) : (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    o[k2] = m[k];
  	}));
  	var __exportStar = (commonjsGlobal$1 && commonjsGlobal$1.__exportStar) || function(m, exports) {
  	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  	};
  	Object.defineProperty(exports, "__esModule", { value: true });
  	__exportStar(BlankNode$1, exports);
  	__exportStar(DataFactory$1, exports);
  	__exportStar(DefaultGraph$1, exports);
  	__exportStar(Literal$1, exports);
  	__exportStar(NamedNode$1, exports);
  	__exportStar(Quad$1, exports);
  	__exportStar(Variable$1, exports);

  	}(rdfDataFactory));

  	var geometryType;

  	(function (geometryType) {
  	  geometryType["POINT"] = "point";
  	})(geometryType || (geometryType = {}));

  	function parseWKT(wktString) {
  	  wktString = wktString.toLocaleLowerCase();

  	  if (wktString.startsWith("point")) {
  	    var coordinates = parsePoint(wktString);
  	    return {
  	      coordinates: coordinates,
  	      type: geometryType.POINT
  	    };
  	  }
  	}

  	function parsePoint(wktString) {
  	  var point = wktString.split("(")[1].split(")")[0].trim(); // Ex ["0 0 0"]

  	  return point.split(" ").map(function (p) {
  	    return parseFloat(p);
  	  });
  	}

  	var DF = new rdfDataFactory.DataFactory();
  	var geoSPARQLFunctions = {
  	  // geosf:distance(p1, p2, decimals)
  	  'http://www.opengis.net/def/function/geosparql/distance': function httpWwwOpengisNetDefFunctionGeosparqlDistance(args) {
  	    var decimals = args[2] != undefined ? parseFloat(args[2].value) : 8;

  	    if (args[0].termType === 'Literal' && args[1].termType === 'Literal') {
  	      var p1 = parseWKT(args[0].value);
  	      var p2 = parseWKT(args[1].value);

  	      if (p1 && p2) {
  	        if (p1.type == geometryType.POINT && p2.type == geometryType.POINT) {
  	          var a = p1.coordinates[0] - p2.coordinates[0];
  	          var b = p1.coordinates[1] - p2.coordinates[1];
  	          var c = p1.coordinates[2] - p2.coordinates[2];
  	          var d = round(Math.sqrt(a * a + b * b + c * c), decimals); // if(p1.length == 2 && p2.length == 2){
  	          // } 

  	          return DF.literal(d.toString(), DF.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));
  	        }
  	      }
  	    }

  	    return DF.literal("ERROR");
  	  },
  	  // geosf:sfWithin(p1, p2, decimals)
  	  'http://www.opengis.net/def/function/geosparql/inside': function httpWwwOpengisNetDefFunctionGeosparqlInside(args) {
  	    var decimals = args[2] != undefined ? parseFloat(args[2].value) : 8;

  	    if (args[0].termType === 'Literal' && args[1].termType === 'Literal') {
  	      var p1 = parseWKT(args[0].value);
  	      var p2 = parseWKT(args[1].value);

  	      if (p1 && p2) {
  	        if (p1.type == geometryType.POINT && p2.type == geometryType.POINT) {
  	          var a = p1.coordinates[0] - p2.coordinates[0];
  	          var b = p1.coordinates[1] - p2.coordinates[1];
  	          var c = p1.coordinates[2] - p2.coordinates[2];
  	          var d = round(Math.sqrt(a * a + b * b + c * c), decimals); // if(p1.length == 2 && p2.length == 2){
  	          // } 

  	          return DF.literal(d.toString(), DF.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));
  	        }
  	      }
  	    }

  	    return DF.literal("ERROR");
  	  }
  	};

  	function round(num) {
  	  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  	  return Math.round(num * Math.pow(10, decimals) + Number.EPSILON) / Math.pow(10, decimals);
  	}

  	exports.geoSPARQLFunctions = geoSPARQLFunctions;

  	Object.defineProperty(exports, '__esModule', { value: true });

  }));

  }(bundle_umd, bundle_umd.exports));

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var Parser = /*#__PURE__*/function () {
    function Parser(ifcAPI, modelID) {
      var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SerializationFormat.JSONLD;
      var verbose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      _classCallCheck(this, Parser);

      _defineProperty(this, "jsonLDObject", {
        "@context": prefixes,
        "@graph": []
      });

      _defineProperty(this, "communicaEngine", actorInitSparqlRdfjs.newEngine());

      _defineProperty(this, "store", new N3__namespace.Store());

      _defineProperty(this, "extensionFunctions", _objectSpread(_objectSpread({}, extensionFunctions), bundle_umd.exports.geoSPARQLFunctions));

      this.modelID = modelID;
      this.ifcAPI = ifcAPI;
      this.verbose = verbose;
      this.format = format;
    }

    _createClass(Parser, [{
      key: "getTriples",
      value: function () {
        var _getTriples = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(this.format == SerializationFormat.JSONLD)) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return", this.getJSONLD());

                case 2:
                  if (!(this.format == SerializationFormat.NQuads)) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt("return", this.getNQuads());

                case 4:
                  return _context.abrupt("return", "");

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function getTriples() {
          return _getTriples.apply(this, arguments);
        }

        return getTriples;
      }()
    }, {
      key: "getTripleCount",
      value: function () {
        var _getTripleCount = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var rdf, tripleCount;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(this.store.size > 0)) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return", this.getStoreSize());

                case 2:
                  _context2.next = 4;
                  return jsonld.toRDF(this.jsonLDObject);

                case 4:
                  rdf = _context2.sent;
                  tripleCount = rdf.length;
                  return _context2.abrupt("return", tripleCount);

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getTripleCount() {
          return _getTripleCount.apply(this, arguments);
        }

        return getTripleCount;
      }()
    }, {
      key: "loadInStore",
      value: function () {
        var _loadInStore = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var quads;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return jsonld.toRDF(this.jsonLDObject);

                case 2:
                  quads = _context3.sent;
                  _context3.next = 5;
                  return this.store.addQuads(quads);

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function loadInStore() {
          return _loadInStore.apply(this, arguments);
        }

        return loadInStore;
      }()
    }, {
      key: "executeUpdateQuery",
      value: function () {
        var _executeUpdateQuery = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(query) {
          var engine, result;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  // Initiate the update
                  engine = actorInitSparqlRdfjs.newEngine();
                  _context4.next = 3;
                  return engine.query(query, {
                    sources: [this.store],
                    extensionFunctions: this.extensionFunctions
                  });

                case 3:
                  result = _context4.sent;
                  _context4.next = 6;
                  return result.updateResult;

                case 6:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function executeUpdateQuery(_x) {
          return _executeUpdateQuery.apply(this, arguments);
        }

        return executeUpdateQuery;
      }()
    }, {
      key: "executeSelectQuery",
      value: function () {
        var _executeSelectQuery = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(query) {
          var engine, result, _yield$engine$resultT, data;

          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  // Initiate the update
                  engine = actorInitSparqlRdfjs.newEngine();
                  _context5.next = 3;
                  return engine.query(query, {
                    sources: [this.store],
                    extensionFunctions: this.extensionFunctions
                  });

                case 3:
                  result = _context5.sent;
                  _context5.next = 6;
                  return engine.resultToString(result, 'application/sparql-results+json');

                case 6:
                  _yield$engine$resultT = _context5.sent;
                  data = _yield$engine$resultT.data;
                  data.pipe(process.stdout); // Print to standard output

                case 9:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function executeSelectQuery(_x2) {
          return _executeSelectQuery.apply(this, arguments);
        }

        return executeSelectQuery;
      }()
    }, {
      key: "getStoreSize",
      value: function getStoreSize() {
        return this.store.size;
      }
    }, {
      key: "getJSONLD",
      value: function () {
        var _getJSONLD = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          var nquads, doc, compacted;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  if (!(this.store.size > 0)) {
                    _context6.next = 9;
                    break;
                  }

                  nquads = this.store.getQuads(null, null, null, null);
                  _context6.next = 4;
                  return jsonld.fromRDF(nquads);

                case 4:
                  doc = _context6.sent;
                  _context6.next = 7;
                  return jsonld.compact(doc, this.jsonLDObject["@context"]);

                case 7:
                  compacted = _context6.sent;
                  return _context6.abrupt("return", compacted);

                case 9:
                  return _context6.abrupt("return", this.jsonLDObject);

                case 10:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function getJSONLD() {
          return _getJSONLD.apply(this, arguments);
        }

        return getJSONLD;
      }()
    }, {
      key: "getNQuads",
      value: function () {
        var _getNQuads = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  if (!(this.store.size > 0)) {
                    _context7.next = 4;
                    break;
                  }

                  _context7.next = 3;
                  return this.serializeStoreContent(N3Format.NQuads);

                case 3:
                  return _context7.abrupt("return", _context7.sent);

                case 4:
                  _context7.next = 6;
                  return jsonld.toRDF(this.jsonLDObject, {
                    format: 'application/n-quads'
                  });

                case 6:
                  return _context7.abrupt("return", _context7.sent);

                case 7:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function getNQuads() {
          return _getNQuads.apply(this, arguments);
        }

        return getNQuads;
      }()
    }, {
      key: "serializeStoreContent",
      value: function () {
        var _serializeStoreContent = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          var _this = this;

          var format,
              _args8 = arguments;
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  format = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : N3Format.Turtle;
                  return _context8.abrupt("return", new Promise(function (resolve, reject) {
                    var writer = new N3__namespace.Writer({
                      prefixes: prefixes,
                      format: format
                    });

                    var quads = _this.store.getQuads(null, null, null, null);

                    for (var i = 0; i < quads.length; i++) {
                      writer.addQuad(quads[i]);
                    }

                    writer.end(function (error, result) {
                      if (error) reject(error);
                      resolve(result);
                    });
                  }));

                case 2:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }));

        function serializeStoreContent() {
          return _serializeStoreContent.apply(this, arguments);
        }

        return serializeStoreContent;
      }()
    }]);

    return Parser;
  }();

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var BOTParser = /*#__PURE__*/function (_Parser) {
    _inherits(BOTParser, _Parser);

    var _super = _createSuper$4(BOTParser);

    function BOTParser() {
      _classCallCheck(this, BOTParser);

      return _super.apply(this, arguments);
    }

    _createClass(BOTParser, [{
      key: "doParse",
      value: function () {
        var _doParse = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$jsonLDObject$G, _this$jsonLDObject$G2, _this$jsonLDObject$G3, _this$jsonLDObject$G4, _this$jsonLDObject$G5, _this$jsonLDObject$G6, _this$jsonLDObject$G7, _this$jsonLDObject$G8, _this$jsonLDObject$G9, _this$jsonLDObject$G10, _this$jsonLDObject$G11, _this$jsonLDObject$G12;

          var tripleCount;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.verbose && console.log("Started BOT parsing");
                  this.verbose && console.log("");
                  console.time("Finished BOT parsing"); // Class assignment

                  this.verbose && console.log("## STEP 1: CLASS ASSIGNMENT ##");
                  this.verbose && console.time("1/12: Finding sites");
                  _context.t0 = (_this$jsonLDObject$G = this.jsonLDObject["@graph"]).push;
                  _context.t1 = _this$jsonLDObject$G;
                  _context.t2 = _toConsumableArray;
                  _context.next = 10;
                  return this.buildSites();

                case 10:
                  _context.t3 = _context.sent;
                  _context.t4 = (0, _context.t2)(_context.t3);

                  _context.t0.apply.call(_context.t0, _context.t1, _context.t4);

                  this.verbose && console.timeEnd("1/12: Finding sites");
                  this.verbose && console.time("2/12: Finding buildings");
                  _context.t5 = (_this$jsonLDObject$G2 = this.jsonLDObject["@graph"]).push;
                  _context.t6 = _this$jsonLDObject$G2;
                  _context.t7 = _toConsumableArray;
                  _context.next = 20;
                  return this.buildBuildings();

                case 20:
                  _context.t8 = _context.sent;
                  _context.t9 = (0, _context.t7)(_context.t8);

                  _context.t5.apply.call(_context.t5, _context.t6, _context.t9);

                  this.verbose && console.timeEnd("2/12: Finding buildings");
                  this.verbose && console.time("3/12: Finding storeys");
                  _context.t10 = (_this$jsonLDObject$G3 = this.jsonLDObject["@graph"]).push;
                  _context.t11 = _this$jsonLDObject$G3;
                  _context.t12 = _toConsumableArray;
                  _context.next = 30;
                  return this.buildStoreys();

                case 30:
                  _context.t13 = _context.sent;
                  _context.t14 = (0, _context.t12)(_context.t13);

                  _context.t10.apply.call(_context.t10, _context.t11, _context.t14);

                  this.verbose && console.timeEnd("3/12: Finding storeys");
                  this.verbose && console.time("4/12: Finding spaces");
                  _context.t15 = (_this$jsonLDObject$G4 = this.jsonLDObject["@graph"]).push;
                  _context.t16 = _this$jsonLDObject$G4;
                  _context.t17 = _toConsumableArray;
                  _context.next = 40;
                  return this.buildSpaces();

                case 40:
                  _context.t18 = _context.sent;
                  _context.t19 = (0, _context.t17)(_context.t18);

                  _context.t15.apply.call(_context.t15, _context.t16, _context.t19);

                  this.verbose && console.timeEnd("4/12: Finding spaces");
                  this.verbose && console.time("5/12: Finding elements");
                  _context.t20 = (_this$jsonLDObject$G5 = this.jsonLDObject["@graph"]).push;
                  _context.t21 = _this$jsonLDObject$G5;
                  _context.t22 = _toConsumableArray;
                  _context.next = 50;
                  return this.buildElements();

                case 50:
                  _context.t23 = _context.sent;
                  _context.t24 = (0, _context.t22)(_context.t23);

                  _context.t20.apply.call(_context.t20, _context.t21, _context.t24);

                  this.verbose && console.timeEnd("5/12: Finding elements");
                  this.verbose && console.log(""); // Space-Element relationships

                  this.verbose && console.log("## STEP 2: SPACE-ELEMENT RELATIONSHIPS ##");
                  this.verbose && console.time("6/12: Finding spaces' adjacent elements");
                  _context.t25 = (_this$jsonLDObject$G6 = this.jsonLDObject["@graph"]).push;
                  _context.t26 = _this$jsonLDObject$G6;
                  _context.t27 = _toConsumableArray;
                  _context.next = 62;
                  return this.buildSpaceAdjacentElementRelationships();

                case 62:
                  _context.t28 = _context.sent;
                  _context.t29 = (0, _context.t27)(_context.t28);

                  _context.t25.apply.call(_context.t25, _context.t26, _context.t29);

                  this.verbose && console.timeEnd("6/12: Finding spaces' adjacent elements");
                  this.verbose && console.time("7/12: Finding spaces' contained elements");
                  _context.t30 = (_this$jsonLDObject$G7 = this.jsonLDObject["@graph"]).push;
                  _context.t31 = _this$jsonLDObject$G7;
                  _context.t32 = _toConsumableArray;
                  _context.next = 72;
                  return this.buildSpaceContainedElementRelationships();

                case 72:
                  _context.t33 = _context.sent;
                  _context.t34 = (0, _context.t32)(_context.t33);

                  _context.t30.apply.call(_context.t30, _context.t31, _context.t34);

                  this.verbose && console.timeEnd("7/12: Finding spaces' contained elements");
                  this.verbose && console.time("8/12: Finding storeys' elements");
                  _context.t35 = (_this$jsonLDObject$G8 = this.jsonLDObject["@graph"]).push;
                  _context.t36 = _this$jsonLDObject$G8;
                  _context.t37 = _toConsumableArray;
                  _context.next = 82;
                  return this.buildStoreyElementRelationships();

                case 82:
                  _context.t38 = _context.sent;
                  _context.t39 = (0, _context.t37)(_context.t38);

                  _context.t35.apply.call(_context.t35, _context.t36, _context.t39);

                  this.verbose && console.timeEnd("8/12: Finding storeys' elements");
                  this.verbose && console.log(""); // Element-element relationships

                  this.verbose && console.log("## STEP 3: ELEMENT-ELEMENT RELATIONSHIPS ##");
                  this.verbose && console.time("9/12: Finding elements' hosted elements");
                  _context.t40 = (_this$jsonLDObject$G9 = this.jsonLDObject["@graph"]).push;
                  _context.t41 = _this$jsonLDObject$G9;
                  _context.t42 = _toConsumableArray;
                  _context.next = 94;
                  return this.buildHostedElementRelationships();

                case 94:
                  _context.t43 = _context.sent;
                  _context.t44 = (0, _context.t42)(_context.t43);

                  _context.t40.apply.call(_context.t40, _context.t41, _context.t44);

                  this.verbose && console.timeEnd("9/12: Finding elements' hosted elements");
                  this.verbose && console.log(""); // Zone containment

                  this.verbose && console.log("## STEP 4: ZONE-ZONE RELATIONSHIPS ##");
                  this.verbose && console.time("10/12: Finding storeys' spaces");
                  _context.t45 = (_this$jsonLDObject$G10 = this.jsonLDObject["@graph"]).push;
                  _context.t46 = _this$jsonLDObject$G10;
                  _context.t47 = _toConsumableArray;
                  _context.next = 106;
                  return this.buildStoreySpaceRelationships();

                case 106:
                  _context.t48 = _context.sent;
                  _context.t49 = (0, _context.t47)(_context.t48);

                  _context.t45.apply.call(_context.t45, _context.t46, _context.t49);

                  this.verbose && console.timeEnd("10/12: Finding storeys' spaces");
                  this.verbose && console.time("11/12: Finding buildings' storeys");
                  _context.t50 = (_this$jsonLDObject$G11 = this.jsonLDObject["@graph"]).push;
                  _context.t51 = _this$jsonLDObject$G11;
                  _context.t52 = _toConsumableArray;
                  _context.next = 116;
                  return this.buildBuildingStoreyRelationships();

                case 116:
                  _context.t53 = _context.sent;
                  _context.t54 = (0, _context.t52)(_context.t53);

                  _context.t50.apply.call(_context.t50, _context.t51, _context.t54);

                  this.verbose && console.timeEnd("11/12: Finding buildings' storeys");
                  this.verbose && console.time("12/12: Finding sties' buildings");
                  _context.t55 = (_this$jsonLDObject$G12 = this.jsonLDObject["@graph"]).push;
                  _context.t56 = _this$jsonLDObject$G12;
                  _context.t57 = _toConsumableArray;
                  _context.next = 126;
                  return this.buildSiteBuildingRelationships();

                case 126:
                  _context.t58 = _context.sent;
                  _context.t59 = (0, _context.t57)(_context.t58);

                  _context.t55.apply.call(_context.t55, _context.t56, _context.t59);

                  this.verbose && console.timeEnd("12/12: Finding sties' buildings");
                  this.verbose && console.log("");
                  console.timeEnd("Finished BOT parsing");

                  if (!this.verbose) {
                    _context.next = 137;
                    break;
                  }

                  _context.next = 135;
                  return this.getTripleCount();

                case 135:
                  tripleCount = _context.sent;
                  console.log("Total triples: " + tripleCount);

                case 137:
                  _context.next = 139;
                  return this.getTriples();

                case 139:
                  return _context.abrupt("return", _context.sent);

                case 140:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function doParse() {
          return _doParse.apply(this, arguments);
        }

        return doParse;
      }()
      /**
       * CLASS ASSIGNMENT
       */

    }, {
      key: "buildSites",
      value: function () {
        var _buildSites = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return buildClassInstances(this.ifcAPI, this.modelID, IFCSITE, ["bot:Site"]);

                case 2:
                  return _context2.abrupt("return", _context2.sent);

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function buildSites() {
          return _buildSites.apply(this, arguments);
        }

        return buildSites;
      }()
    }, {
      key: "buildBuildings",
      value: function () {
        var _buildBuildings = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return buildClassInstances(this.ifcAPI, this.modelID, IFCBUILDING, ["bot:Building"]);

                case 2:
                  return _context3.abrupt("return", _context3.sent);

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function buildBuildings() {
          return _buildBuildings.apply(this, arguments);
        }

        return buildBuildings;
      }()
    }, {
      key: "buildStoreys",
      value: function () {
        var _buildStoreys = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return buildClassInstances(this.ifcAPI, this.modelID, IFCBUILDINGSTOREY, ["bot:Storey"]);

                case 2:
                  return _context4.abrupt("return", _context4.sent);

                case 3:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function buildStoreys() {
          return _buildStoreys.apply(this, arguments);
        }

        return buildStoreys;
      }()
    }, {
      key: "buildSpaces",
      value: function () {
        var _buildSpaces = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return buildClassInstances(this.ifcAPI, this.modelID, IFCSPACE, ["bot:Space"]);

                case 2:
                  return _context5.abrupt("return", _context5.sent);

                case 3:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function buildSpaces() {
          return _buildSpaces.apply(this, arguments);
        }

        return buildSpaces;
      }()
    }, {
      key: "buildElements",
      value: function () {
        var _buildElements = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          var includeSubTypes;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  includeSubTypes = true;
                  _context6.next = 3;
                  return buildClassInstances(this.ifcAPI, this.modelID, IFCELEMENT, ["bot:Element"], includeSubTypes);

                case 3:
                  return _context6.abrupt("return", _context6.sent);

                case 4:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function buildElements() {
          return _buildElements.apply(this, arguments);
        }

        return buildElements;
      }()
      /**
       * ZONE-ELEMENT-RELATIONSHIPS
       */

    }, {
      key: "buildSpaceAdjacentElementRelationships",
      value: function () {
        var _buildSpaceAdjacentElementRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          var input;
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELSPACEBOUNDARY,
                    ifcSubjectRel: "RelatingSpace",
                    ifcTargetRel: "RelatedBuildingElement",
                    rdfRelationship: "bot:adjacentElement",
                    includeInterface: true
                  };
                  _context7.next = 3;
                  return buildRelOneToOne(input);

                case 3:
                  return _context7.abrupt("return", _context7.sent);

                case 4:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function buildSpaceAdjacentElementRelationships() {
          return _buildSpaceAdjacentElementRelationships.apply(this, arguments);
        }

        return buildSpaceAdjacentElementRelationships;
      }()
    }, {
      key: "buildSpaceContainedElementRelationships",
      value: function () {
        var _buildSpaceContainedElementRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          var input;
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELCONTAINEDINSPATIALSTRUCTURE,
                    ifcSubjectRel: "RelatingStructure",
                    ifcTargetRel: "RelatedElements",
                    rdfRelationship: "bot:containsElement",
                    ifcSubjectClassIn: [IFCSPACE]
                  };
                  _context8.next = 3;
                  return buildRelOneToMany(input);

                case 3:
                  return _context8.abrupt("return", _context8.sent);

                case 4:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function buildSpaceContainedElementRelationships() {
          return _buildSpaceContainedElementRelationships.apply(this, arguments);
        }

        return buildSpaceContainedElementRelationships;
      }()
    }, {
      key: "buildStoreyElementRelationships",
      value: function () {
        var _buildStoreyElementRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          var input;
          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELCONTAINEDINSPATIALSTRUCTURE,
                    ifcSubjectRel: "RelatingStructure",
                    ifcTargetRel: "RelatedElements",
                    rdfRelationship: "bot:hasElement",
                    ifcSubjectClassIn: [IFCBUILDINGSTOREY]
                  };
                  _context9.next = 3;
                  return buildRelOneToMany(input);

                case 3:
                  return _context9.abrupt("return", _context9.sent);

                case 4:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function buildStoreyElementRelationships() {
          return _buildStoreyElementRelationships.apply(this, arguments);
        }

        return buildStoreyElementRelationships;
      }()
      /**
       * ELEMENT-ELEMENT-RELATIONSHIPS
       */
      // NB! PROBABLY REFERS TO THE VOID AND NOT THE WINDOW!

    }, {
      key: "buildHostedElementRelationships",
      value: function () {
        var _buildHostedElementRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
          var input;
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELVOIDSELEMENT,
                    ifcSubjectRel: "RelatingBuildingElement",
                    ifcTargetRel: "RelatedOpeningElement",
                    rdfRelationship: "bot:hasSubElement"
                  };
                  _context10.next = 3;
                  return buildRelOneToOne(input);

                case 3:
                  return _context10.abrupt("return", _context10.sent);

                case 4:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function buildHostedElementRelationships() {
          return _buildHostedElementRelationships.apply(this, arguments);
        }

        return buildHostedElementRelationships;
      }()
      /**
       * ZONE-CONTAINMENT
       */

    }, {
      key: "buildStoreySpaceRelationships",
      value: function () {
        var _buildStoreySpaceRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
          var input;
          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELAGGREGATES,
                    ifcSubjectRel: "RelatingObject",
                    ifcTargetRel: "RelatedObjects",
                    rdfRelationship: "bot:hasSpace",
                    ifcSubjectClassIn: [IFCBUILDINGSTOREY],
                    ifcTargetClassIn: [IFCSPACE]
                  };
                  _context11.next = 3;
                  return buildRelOneToMany(input);

                case 3:
                  return _context11.abrupt("return", _context11.sent);

                case 4:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this);
        }));

        function buildStoreySpaceRelationships() {
          return _buildStoreySpaceRelationships.apply(this, arguments);
        }

        return buildStoreySpaceRelationships;
      }()
    }, {
      key: "buildBuildingStoreyRelationships",
      value: function () {
        var _buildBuildingStoreyRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
          var input;
          return regenerator.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELAGGREGATES,
                    ifcSubjectRel: "RelatingObject",
                    ifcTargetRel: "RelatedObjects",
                    rdfRelationship: "bot:hasStorey",
                    ifcSubjectClassIn: [IFCBUILDING],
                    ifcTargetClassIn: [IFCBUILDINGSTOREY]
                  };
                  _context12.next = 3;
                  return buildRelOneToMany(input);

                case 3:
                  return _context12.abrupt("return", _context12.sent);

                case 4:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, this);
        }));

        function buildBuildingStoreyRelationships() {
          return _buildBuildingStoreyRelationships.apply(this, arguments);
        }

        return buildBuildingStoreyRelationships;
      }()
    }, {
      key: "buildSiteBuildingRelationships",
      value: function () {
        var _buildSiteBuildingRelationships = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {
          var input;
          return regenerator.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELAGGREGATES,
                    ifcSubjectRel: "RelatingObject",
                    ifcTargetRel: "RelatedObjects",
                    rdfRelationship: "bot:hasBuilding",
                    ifcSubjectClassIn: [IFCSITE],
                    ifcTargetClassIn: [IFCBUILDING]
                  };
                  _context13.next = 3;
                  return buildRelOneToMany(input);

                case 3:
                  return _context13.abrupt("return", _context13.sent);

                case 4:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13, this);
        }));

        function buildSiteBuildingRelationships() {
          return _buildSiteBuildingRelationships.apply(this, arguments);
        }

        return buildSiteBuildingRelationships;
      }()
    }]);

    return BOTParser;
  }(Parser);

  var IfcElements = {
    103090709: 'IfcProject',
    4097777520: 'IfcSite',
    4031249490: 'IfcBuilding',
    3124254112: 'IfcBuildingStorey',
    3856911033: 'IfcSpace',
    1674181508: 'IfcAnnotation',
    25142252: 'IfcController',
    32344328: 'IfcBoiler',
    76236018: 'IfcLamp',
    90941305: 'IfcPump',
    177149247: 'IfcAirTerminalBox',
    182646315: 'IfcFlowInstrument',
    263784265: 'IfcFurnishingElement',
    264262732: 'IfcElectricGenerator',
    277319702: 'IfcAudioVisualAppliance',
    310824031: 'IfcPipeFitting',
    331165859: 'IfcStair',
    342316401: 'IfcDuctFitting',
    377706215: 'IfcMechanicalFastener',
    395920057: 'IfcDoor',
    402227799: 'IfcElectricMotor',
    413509423: 'IfcSystemFurnitureElement',
    484807127: 'IfcEvaporator',
    486154966: 'IfcWindowStandardCase',
    629592764: 'IfcLightFixture',
    630975310: 'IfcUnitaryControlElement',
    635142910: 'IfcCableCarrierFitting',
    639361253: 'IfcCoil',
    647756555: 'IfcFastener',
    707683696: 'IfcFlowStorageDevice',
    738039164: 'IfcProtectiveDevice',
    753842376: 'IfcBeam',
    812556717: 'IfcTank',
    819412036: 'IfcFilter',
    843113511: 'IfcColumn',
    862014818: 'IfcElectricDistributionBoard',
    900683007: 'IfcFooting',
    905975707: 'IfcColumnStandardCase',
    926996030: 'IfcVoidingFeature',
    979691226: 'IfcReinforcingBar',
    987401354: 'IfcFlowSegment',
    1003880860: 'IfcElectricTimeControl',
    1051757585: 'IfcCableFitting',
    1052013943: 'IfcDistributionChamberElement',
    1062813311: 'IfcDistributionControlElement',
    1073191201: 'IfcMember',
    1095909175: 'IfcBuildingElementProxy',
    1156407060: 'IfcPlateStandardCase',
    1162798199: 'IfcSwitchingDevice',
    1329646415: 'IfcShadingDevice',
    1335981549: 'IfcDiscreteAccessory',
    1360408905: 'IfcDuctSilencer',
    1404847402: 'IfcStackTerminal',
    1426591983: 'IfcFireSuppressionTerminal',
    1437502449: 'IfcMedicalDevice',
    1509553395: 'IfcFurniture',
    1529196076: 'IfcSlab',
    1620046519: 'IfcTransportElement',
    1634111441: 'IfcAirTerminal',
    1658829314: 'IfcEnergyConversionDevice',
    1677625105: 'IfcCivilElement',
    1687234759: 'IfcPile',
    1904799276: 'IfcElectricAppliance',
    1911478936: 'IfcMemberStandardCase',
    1945004755: 'IfcDistributionElement',
    1973544240: 'IfcCovering',
    1999602285: 'IfcSpaceHeater',
    2016517767: 'IfcRoof',
    2056796094: 'IfcAirToAirHeatRecovery',
    2058353004: 'IfcFlowController',
    2068733104: 'IfcHumidifier',
    2176052936: 'IfcJunctionBox',
    2188021234: 'IfcFlowMeter',
    2223149337: 'IfcFlowTerminal',
    2262370178: 'IfcRailing',
    2272882330: 'IfcCondenser',
    2295281155: 'IfcProtectiveDeviceTrippingUnit',
    2320036040: 'IfcReinforcingMesh',
    2347447852: 'IfcTendonAnchor',
    2391383451: 'IfcVibrationIsolator',
    2391406946: 'IfcWall',
    2474470126: 'IfcMotorConnection',
    2769231204: 'IfcVirtualElement',
    2814081492: 'IfcEngine',
    2906023776: 'IfcBeamStandardCase',
    2938176219: 'IfcBurner',
    2979338954: 'IfcBuildingElementPart',
    3024970846: 'IfcRamp',
    3026737570: 'IfcTubeBundle',
    3027962421: 'IfcSlabStandardCase',
    3040386961: 'IfcDistributionFlowElement',
    3053780830: 'IfcSanitaryTerminal',
    3079942009: 'IfcOpeningStandardCase',
    3087945054: 'IfcAlarm',
    3101698114: 'IfcSurfaceFeature',
    3127900445: 'IfcSlabElementedCase',
    3132237377: 'IfcFlowMovingDevice',
    3171933400: 'IfcPlate',
    3221913625: 'IfcCommunicationsAppliance',
    3242481149: 'IfcDoorStandardCase',
    3283111854: 'IfcRampFlight',
    3296154744: 'IfcChimney',
    3304561284: 'IfcWindow',
    3310460725: 'IfcElectricFlowStorageDevice',
    3319311131: 'IfcHeatExchanger',
    3415622556: 'IfcFan',
    3420628829: 'IfcSolarDevice',
    3493046030: 'IfcGeographicElement',
    3495092785: 'IfcCurtainWall',
    3508470533: 'IfcFlowTreatmentDevice',
    3512223829: 'IfcWallStandardCase',
    3518393246: 'IfcDuctSegment',
    3571504051: 'IfcCompressor',
    3588315303: 'IfcOpeningElement',
    3612865200: 'IfcPipeSegment',
    3640358203: 'IfcCoolingTower',
    3651124850: 'IfcProjectionElement',
    3694346114: 'IfcOutlet',
    3747195512: 'IfcEvaporativeCooler',
    3758799889: 'IfcCableCarrierSegment',
    3824725483: 'IfcTendon',
    3825984169: 'IfcTransformer',
    3902619387: 'IfcChiller',
    4074379575: 'IfcDamper',
    4086658281: 'IfcSensor',
    4123344466: 'IfcElementAssembly',
    4136498852: 'IfcCooledBeam',
    4156078855: 'IfcWallElementedCase',
    4175244083: 'IfcInterceptor',
    4207607924: 'IfcValve',
    4217484030: 'IfcCableSegment',
    4237592921: 'IfcWasteTerminal',
    4252922144: 'IfcStairFlight',
    4278956645: 'IfcFlowFitting',
    4288193352: 'IfcActuator',
    4292641817: 'IfcUnitaryEquipment',
    3009204131: 'IfcGrid'
  };

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var ProductParser = /*#__PURE__*/function (_Parser) {
    _inherits(ProductParser, _Parser);

    var _super = _createSuper$3(ProductParser);

    function ProductParser() {
      _classCallCheck(this, ProductParser);

      return _super.apply(this, arguments);
    }

    _createClass(ProductParser, [{
      key: "doParse",
      value: function () {
        var _doParse = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var tripleCount;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.verbose && console.log("Started PRODUCTS parsing");
                  this.verbose && console.log("");
                  console.time("Finished products parsing");
                  this.verbose && console.log("## STEP 1: CLASS ASSIGNMENT ##");
                  this.verbose && console.time("1/1: Finding products");
                  _context.next = 7;
                  return this.buildProducts();

                case 7:
                  this.jsonLDObject["@graph"] = _context.sent;
                  this.verbose && console.timeEnd("1/1: Finding products");
                  this.verbose && console.log("");
                  console.timeEnd("Finished products parsing");

                  if (!this.verbose) {
                    _context.next = 16;
                    break;
                  }

                  _context.next = 14;
                  return this.getTripleCount();

                case 14:
                  tripleCount = _context.sent;
                  console.log("Total triples: " + tripleCount);

                case 16:
                  _context.next = 18;
                  return this.getTriples();

                case 18:
                  return _context.abrupt("return", _context.sent);

                case 19:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function doParse() {
          return _doParse.apply(this, arguments);
        }

        return doParse;
      }()
    }, {
      key: "buildProducts",
      value: function () {
        var _buildProducts = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var graph, skippedTypes, subTypes, expressIDArray, _iterator, _step, typeId, i, expressID, _yield$this$ifcAPI$pr, type, GlobalId, URI;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  graph = [];
                  skippedTypes = [IFCOPENINGELEMENT]; // Get all subTypes of IfcElement

                  subTypes = getItemSubtypes(IFCELEMENT).filter(function (typeID) {
                    return skippedTypes.indexOf(typeID) == -1;
                  }); // Filter out skipped types
                  // Get all items in model that belong to any of these types

                  expressIDArray = [];
                  _iterator = _createForOfIteratorHelper(subTypes);
                  _context2.prev = 5;

                  _iterator.s();

                case 7:
                  if ((_step = _iterator.n()).done) {
                    _context2.next = 19;
                    break;
                  }

                  typeId = _step.value;
                  _context2.t0 = expressIDArray.push;
                  _context2.t1 = expressIDArray;
                  _context2.t2 = _toConsumableArray;
                  _context2.next = 14;
                  return this.ifcAPI.properties.getAllItemsOfType(this.modelID, typeId, false);

                case 14:
                  _context2.t3 = _context2.sent;
                  _context2.t4 = (0, _context2.t2)(_context2.t3);

                  _context2.t0.apply.call(_context2.t0, _context2.t1, _context2.t4);

                case 17:
                  _context2.next = 7;
                  break;

                case 19:
                  _context2.next = 24;
                  break;

                case 21:
                  _context2.prev = 21;
                  _context2.t5 = _context2["catch"](5);

                  _iterator.e(_context2.t5);

                case 24:
                  _context2.prev = 24;

                  _iterator.f();

                  return _context2.finish(24);

                case 27:
                  i = 0;

                case 28:
                  if (!(i < expressIDArray.length)) {
                    _context2.next = 40;
                    break;
                  }

                  expressID = expressIDArray[i];
                  _context2.next = 32;
                  return this.ifcAPI.properties.getItemProperties(this.modelID, expressID);

                case 32:
                  _yield$this$ifcAPI$pr = _context2.sent;
                  type = _yield$this$ifcAPI$pr.type;
                  GlobalId = _yield$this$ifcAPI$pr.GlobalId;
                  URI = defaultURIBuilder(GlobalId.value); // Push product

                  graph.push({
                    "@id": URI,
                    "@type": "ifc:".concat(IfcElements[type])
                  });

                case 37:
                  i++;
                  _context2.next = 28;
                  break;

                case 40:
                  return _context2.abrupt("return", graph);

                case 41:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this, [[5, 21, 24, 27]]);
        }));

        function buildProducts() {
          return _buildProducts.apply(this, arguments);
        }

        return buildProducts;
      }()
    }]);

    return ProductParser;
  }(Parser);

  var map = {
    "\\\\X2\\\\00FC\\\\X0\\\\": "ü",
    "\\\\X2\\\\00F6\\\\X0\\\\": "ä"
  };
  function decodeString(str) {
    // Skip if no special characters found
    if (str.indexOf("\\") == -1) return str; // Replace all known special characters

    var keys = Object.keys(map);

    for (var i = 0; i < keys.length; i++) {
      var regex = new RegExp(keys[i], "g");
      str = str.replace(regex, map[keys[i]]);
    }

    return str;
  }

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var PropertyParser = /*#__PURE__*/function (_Parser) {
    _inherits(PropertyParser, _Parser);

    var _super = _createSuper$2(PropertyParser);

    function PropertyParser() {
      _classCallCheck(this, PropertyParser);

      return _super.apply(this, arguments);
    }

    _createClass(PropertyParser, [{
      key: "doParse",
      value: // Holds expressIDs for all relevant items
      function () {
        var _doParse = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$jsonLDObject$G;

          var tripleCount;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.verbose && console.log("Started PROPERTIES parsing");
                  this.verbose && console.log("");
                  console.time("Finished PROPERTIES parsing");
                  this.verbose && console.log("## PRE STEPS ##");
                  this.verbose && console.time("Getting element and group IDs");
                  _context.next = 7;
                  return this.getAllRelevantItems();

                case 7:
                  this.itemIDs = _context.sent;
                  this.verbose && console.timeEnd("Getting element and group IDs");
                  this.verbose && console.log("## STEP 1: DIRECT PROPERTIES ##");
                  this.verbose && console.time("1/1: Finding direct properties");
                  _context.t0 = (_this$jsonLDObject$G = this.jsonLDObject["@graph"]).push;
                  _context.t1 = _this$jsonLDObject$G;
                  _context.t2 = _toConsumableArray;
                  _context.next = 16;
                  return this.getElementProperties();

                case 16:
                  _context.t3 = _context.sent;
                  _context.t4 = (0, _context.t2)(_context.t3);

                  _context.t0.apply.call(_context.t0, _context.t1, _context.t4);

                  this.verbose && console.timeEnd("1/1: Finding direct properties");
                  console.log("");
                  console.timeEnd("Finished PROPERTIES parsing");

                  if (!this.verbose) {
                    _context.next = 27;
                    break;
                  }

                  _context.next = 25;
                  return this.getTripleCount();

                case 25:
                  tripleCount = _context.sent;
                  console.log("Total triples: " + tripleCount);

                case 27:
                  _context.next = 29;
                  return this.getTriples();

                case 29:
                  return _context.abrupt("return", _context.sent);

                case 30:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function doParse() {
          return _doParse.apply(this, arguments);
        }

        return doParse;
      }()
    }, {
      key: "getAllRelevantItems",
      value: function () {
        var _getAllRelevantItems = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var arr;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  arr = [];
                  _context2.t0 = arr.push;
                  _context2.t1 = arr;
                  _context2.t2 = _toConsumableArray;
                  _context2.next = 6;
                  return getAllItemsOfTypeOrSubtype(this.ifcAPI, this.modelID, IFCPRODUCT);

                case 6:
                  _context2.t3 = _context2.sent;
                  _context2.t4 = (0, _context2.t2)(_context2.t3);

                  _context2.t0.apply.call(_context2.t0, _context2.t1, _context2.t4);

                  _context2.t5 = arr.push;
                  _context2.t6 = arr;
                  _context2.t7 = _toConsumableArray;
                  _context2.next = 14;
                  return getAllItemsOfTypeOrSubtype(this.ifcAPI, this.modelID, IFCGROUP);

                case 14:
                  _context2.t8 = _context2.sent;
                  _context2.t9 = (0, _context2.t7)(_context2.t8);

                  _context2.t5.apply.call(_context2.t5, _context2.t6, _context2.t9);

                  return _context2.abrupt("return", arr);

                case 18:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getAllRelevantItems() {
          return _getAllRelevantItems.apply(this, arguments);
        }

        return getAllRelevantItems;
      }()
      /**
       * DIRECT
       */

    }, {
      key: "getElementProperties",
      value: function () {
        var _getElementProperties = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var graph, i, _properties$Name, _properties$Descripti, expressID, properties, name, globalId, description, URI, obj;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  graph = [];
                  i = 0;

                case 2:
                  if (!(i < this.itemIDs.length)) {
                    _context3.next = 19;
                    break;
                  }

                  expressID = this.itemIDs[i];
                  _context3.next = 6;
                  return this.ifcAPI.properties.getItemProperties(this.modelID, expressID);

                case 6:
                  properties = _context3.sent;
                  // Example
                  // IfcCooledBeam {
                  //     expressID: 2701,
                  //     type: 4136498852,
                  //     GlobalId: { type: 1, value: '0MMKrFmIr4b8IaMYvCQ0YS' },
                  //     OwnerHistory: { type: 5, value: 42 },
                  //     Name: {
                  //       type: 1,
                  //       value: 'DID642-4-S2-RR-AV 1200x900-593 158 158 LE - TROX Technik (DEU) #s8hqpa4#:Standard:7295696'
                  //     },
                  //     Description: null,
                  //     ObjectType: {
                  //       type: 1,
                  //       value: 'DID642-4-S2-RR-AV 1200x900-593 158 158 LE - TROX Technik (DEU) #s8hqpa4#:Standard'
                  //     },
                  //     ObjectPlacement: { type: 5, value: 2699 },
                  //     Representation: { type: 5, value: 2689 },
                  //     Tag: { type: 1, value: '7295696' },
                  //     PredefinedType: { type: 3, value: 'ACTIVE' }
                  //   }
                  name = (_properties$Name = properties.Name) === null || _properties$Name === void 0 ? void 0 : _properties$Name.value;
                  globalId = properties.GlobalId.value;
                  description = (_properties$Descripti = properties.Description) === null || _properties$Descripti === void 0 ? void 0 : _properties$Descripti.value;
                  URI = defaultURIBuilder(globalId);
                  obj = {
                    "@id": URI,
                    "ex:globalId": globalId
                  };
                  if (name != undefined) obj["rdfs:label"] = decodeString(name);
                  if (description != undefined) obj["rdfs:description"] = description; // Specific for ports

                  if (properties.type == IFCPORT || properties.type == IFCDISTRIBUTIONPORT) {
                    obj["ex:flowDirection"] = properties.FlowDirection.value;
                  } // // Specific for systems
                  // if(properties.type == IFCSYSTEM || properties.type == IFCDISTRIBUTIONSYSTEM){
                  //     console.log(properties);
                  // }


                  graph.push(obj);

                case 16:
                  i++;
                  _context3.next = 2;
                  break;

                case 19:
                  return _context3.abrupt("return", graph);

                case 20:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getElementProperties() {
          return _getElementProperties.apply(this, arguments);
        }

        return getElementProperties;
      }()
    }]);

    return PropertyParser;
  }(Parser);

  /**
   * Return the global position (coordinate) from the local one
   * @param objectPlacement is the object placement in the local coordinate system
   * @param globalPlacement is the global placement (being calculated as the tree is traversed)
   * @returns global coordinate
   */

  function getGlobalPosition(objectPlacement) {
    var _objectPlacement$Rela, _objectPlacement$Rela2;

    var globalPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    // Get relative placement
    var relativeCoordinates = objectPlacement === null || objectPlacement === void 0 ? void 0 : (_objectPlacement$Rela = objectPlacement.RelativePlacement) === null || _objectPlacement$Rela === void 0 ? void 0 : (_objectPlacement$Rela2 = _objectPlacement$Rela.Location) === null || _objectPlacement$Rela2 === void 0 ? void 0 : _objectPlacement$Rela2.Coordinates;
    var relativePlacement = [];

    if (relativeCoordinates != undefined && relativeCoordinates.length == 3) {
      var x = round(relativeCoordinates[0].value);
      var y = round(relativeCoordinates[1].value);
      var z = round(relativeCoordinates[2].value);
      relativePlacement = [x, y, z];
    } // Update global placement


    globalPlacement = getAbsolutePlacement(relativePlacement, globalPlacement); // If related to something else, continue the journey

    if (objectPlacement.PlacementRelTo) {
      return getGlobalPosition(objectPlacement.PlacementRelTo, globalPlacement);
    }

    return globalPlacement;
  }

  function getAbsolutePlacement(relativePlacement, globalPlacement) {
    var x = relativePlacement[0] + globalPlacement[0];
    var y = relativePlacement[1] + globalPlacement[1];
    var z = relativePlacement[2] + globalPlacement[2];
    return [x, y, z];
  }

  function round(num) {
    return Math.round(num * 100000) / 100000;
  }

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var typeMappings$1 = {
    2254336722: ["fso:DistributionSystem"],
    3740093272: ["fso:Port"],
    987401354: ["fso:Segment", "fso:Component"],
    4278956645: ["fso:Fitting", "fso:Component"],
    2058353004: ["fso:FlowController", "fso:Component"],
    1658829314: ["fso:EnergyConversionDevice", "fso:Component"],
    3132237377: ["fso:FlowMovingDevice", "fso:Component"],
    707683696: ["fso:StorageDevice", "fso:Component"],
    2223149337: ["fso:Terminal", "fso:Component"],
    3508470533: ["fso:TreatmentDevice", "fso:Component"]
  };
  var FSOParser = /*#__PURE__*/function (_Parser) {
    _inherits(FSOParser, _Parser);

    var _super = _createSuper$1(FSOParser);

    function FSOParser() {
      _classCallCheck(this, FSOParser);

      return _super.apply(this, arguments);
    }

    _createClass(FSOParser, [{
      key: "doParse",
      value: function () {
        var _doParse = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$jsonLDObject$G, _this$jsonLDObject$G2, _this$jsonLDObject$G3, _this$jsonLDObject$G4, _this$jsonLDObject$G5, _this$jsonLDObject$G6;

          var portIDs, tripleCount;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.verbose && console.log("Started FSO parsing");
                  this.verbose && console.log("");
                  console.time("Finished FSO parsing");
                  this.verbose && console.log("## STEP 1: CLASS ASSIGNMENT ##");
                  this.verbose && console.time("1/10: Classifying FSO items");
                  _context.t0 = (_this$jsonLDObject$G = this.jsonLDObject["@graph"]).push;
                  _context.t1 = _this$jsonLDObject$G;
                  _context.t2 = _toConsumableArray;
                  _context.next = 10;
                  return this.classify();

                case 10:
                  _context.t3 = _context.sent;
                  _context.t4 = (0, _context.t2)(_context.t3);

                  _context.t0.apply.call(_context.t0, _context.t1, _context.t4);

                  this.verbose && console.timeEnd("1/10: Classifying FSO items");
                  this.verbose && console.log("");
                  this.verbose && console.log("## STEP 2: PORTS ##");
                  _context.next = 18;
                  return getAllItemsOfTypeOrSubtype(this.ifcAPI, this.modelID, IFCPORT);

                case 18:
                  portIDs = _context.sent;
                  this.verbose && console.time("2/10: Finding port-port connections");
                  _context.t5 = (_this$jsonLDObject$G2 = this.jsonLDObject["@graph"]).push;
                  _context.t6 = _this$jsonLDObject$G2;
                  _context.t7 = _toConsumableArray;
                  _context.next = 25;
                  return this.portPort();

                case 25:
                  _context.t8 = _context.sent;
                  _context.t9 = (0, _context.t7)(_context.t8);

                  _context.t5.apply.call(_context.t5, _context.t6, _context.t9);

                  this.verbose && console.timeEnd("2/10: Finding port-port connections");
                  this.verbose && console.time("3/10: Finding port-component connections");
                  _context.t10 = (_this$jsonLDObject$G3 = this.jsonLDObject["@graph"]).push;
                  _context.t11 = _this$jsonLDObject$G3;
                  _context.t12 = _toConsumableArray;
                  _context.next = 35;
                  return this.portComponent();

                case 35:
                  _context.t13 = _context.sent;
                  _context.t14 = (0, _context.t12)(_context.t13);

                  _context.t10.apply.call(_context.t10, _context.t11, _context.t14);

                  this.verbose && console.timeEnd("3/10: Finding port-component connections");
                  this.verbose && console.time("4/10: Finding port flow directions");
                  _context.t15 = (_this$jsonLDObject$G4 = this.jsonLDObject["@graph"]).push;
                  _context.t16 = _this$jsonLDObject$G4;
                  _context.t17 = _toConsumableArray;
                  _context.next = 45;
                  return this.portFlowDirection(portIDs);

                case 45:
                  _context.t18 = _context.sent;
                  _context.t19 = (0, _context.t17)(_context.t18);

                  _context.t15.apply.call(_context.t15, _context.t16, _context.t19);

                  this.verbose && console.timeEnd("4/10: Finding port flow directions");
                  this.verbose && console.time("5/10: Finding port placements");
                  _context.t20 = (_this$jsonLDObject$G5 = this.jsonLDObject["@graph"]).push;
                  _context.t21 = _this$jsonLDObject$G5;
                  _context.t22 = _toConsumableArray;
                  _context.next = 55;
                  return this.portPlacements(portIDs);

                case 55:
                  _context.t23 = _context.sent;
                  _context.t24 = (0, _context.t22)(_context.t23);

                  _context.t20.apply.call(_context.t20, _context.t21, _context.t24);

                  this.verbose && console.timeEnd("5/10: Finding port placements");
                  this.verbose && console.log("");
                  this.verbose && console.log("## STEP 3: SYSTEMS ##");
                  this.verbose && console.time("6/10: Finding system-component relationships");
                  _context.t25 = (_this$jsonLDObject$G6 = this.jsonLDObject["@graph"]).push;
                  _context.t26 = _this$jsonLDObject$G6;
                  _context.t27 = _toConsumableArray;
                  _context.next = 67;
                  return this.systemComponent();

                case 67:
                  _context.t28 = _context.sent;
                  _context.t29 = (0, _context.t27)(_context.t28);

                  _context.t25.apply.call(_context.t25, _context.t26, _context.t29);

                  this.verbose && console.timeEnd("6/10: Finding system-component relationships");
                  this.verbose && console.log("");
                  this.verbose && console.log("## STEP 4: POST PROCESSING ##");
                  this.verbose && console.time("7/10: Loading data into in-memory triplestore for querying");
                  _context.next = 76;
                  return this.loadInStore();

                case 76:
                  this.verbose && console.timeEnd("7/10: Loading data into in-memory triplestore for querying");
                  this.verbose && console.time("8/10: Deducing element conections from ports");
                  _context.next = 80;
                  return this.componentConections();

                case 80:
                  this.verbose && console.timeEnd("8/10: Deducing element conections from ports");
                  this.verbose && console.time("9/10: Deducing connection interfaces");
                  _context.next = 84;
                  return this.connectionInterfaces();

                case 84:
                  this.verbose && console.timeEnd("9/10: Deducing connection interfaces");
                  this.verbose && console.time("10/10: Calculating segment lengths");
                  _context.next = 88;
                  return this.segmentLengths();

                case 88:
                  this.verbose && console.timeEnd("10/10: Calculating segment lengths");
                  console.timeEnd("Finished FSO parsing");

                  if (!this.verbose) {
                    _context.next = 95;
                    break;
                  }

                  _context.next = 93;
                  return this.getTripleCount();

                case 93:
                  tripleCount = _context.sent;
                  console.log("Total triples: " + tripleCount);

                case 95:
                  _context.next = 97;
                  return this.getTriples();

                case 97:
                  return _context.abrupt("return", _context.sent);

                case 98:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function doParse() {
          return _doParse.apply(this, arguments);
        }

        return doParse;
      }()
      /**
       * CLASS ASSIGNMENT
       */

    }, {
      key: "classify",
      value: function () {
        var _classify = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var graph, typeIDs, i, typeID, fsoClass;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  graph = [];
                  typeIDs = Object.keys(typeMappings$1);
                  i = 0;

                case 3:
                  if (!(i < typeIDs.length)) {
                    _context2.next = 17;
                    break;
                  }

                  typeID = typeIDs[i];
                  fsoClass = typeMappings$1[typeID];
                  _context2.t0 = graph.push;
                  _context2.t1 = graph;
                  _context2.t2 = _toConsumableArray;
                  _context2.next = 11;
                  return buildClassInstances(this.ifcAPI, this.modelID, typeID, fsoClass, true);

                case 11:
                  _context2.t3 = _context2.sent;
                  _context2.t4 = (0, _context2.t2)(_context2.t3);

                  _context2.t0.apply.call(_context2.t0, _context2.t1, _context2.t4);

                case 14:
                  i++;
                  _context2.next = 3;
                  break;

                case 17:
                  return _context2.abrupt("return", graph);

                case 18:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function classify() {
          return _classify.apply(this, arguments);
        }

        return classify;
      }()
      /**
       * RELATIONSHIP ASSIGNMENT
       */
      // <port1> fso:connectedPort <port2>
      // <port2> fso:connectedPort <port1>

    }, {
      key: "portPort",
      value: function () {
        var _portPort = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var input;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELCONNECTSPORTS,
                    ifcSubjectRel: "RelatedPort",
                    ifcTargetRel: "RelatingPort",
                    rdfRelationship: "fso:connectedPort",
                    includeInterface: false,
                    oppoiteRelationship: "fso:connectedPort"
                  };
                  _context3.next = 3;
                  return buildRelOneToOne(input);

                case 3:
                  return _context3.abrupt("return", _context3.sent);

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function portPort() {
          return _portPort.apply(this, arguments);
        }

        return portPort;
      }() // <element> fso:connectedPort <port>
      // <port> fso:connectedElement <element>

    }, {
      key: "portComponent",
      value: function () {
        var _portComponent = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var graph, inputA, inputB;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  graph = []; // UNTIL IFC 4, THE RELATIONSHIP IS EXPRESSED WITH IFCRELCONNECTSPORTTOELEMENT

                  inputA = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELCONNECTSPORTTOELEMENT,
                    ifcSubjectRel: "RelatedElement",
                    ifcTargetRel: "RelatingPort",
                    rdfRelationship: "fso:connectedPort",
                    includeInterface: false,
                    oppoiteRelationship: "fso:connectedComponent"
                  };
                  _context4.t0 = graph.push;
                  _context4.t1 = graph;
                  _context4.t2 = _toConsumableArray;
                  _context4.next = 7;
                  return buildRelOneToOne(inputA);

                case 7:
                  _context4.t3 = _context4.sent;
                  _context4.t4 = (0, _context4.t2)(_context4.t3);

                  _context4.t0.apply.call(_context4.t0, _context4.t1, _context4.t4);

                  // AFTER IFC 4, THE RELATIONSHIP IS EXPRESSED WITH IFCRELNESTS
                  // IFCRELNESTS has a 
                  inputB = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELNESTS,
                    ifcSubjectRel: "RelatingObject",
                    ifcTargetRel: "RelatedObjects",
                    rdfRelationship: "fso:connectedPort",
                    includeInterface: false,
                    oppoiteRelationship: "fso:connectedComponent"
                  };
                  _context4.t5 = graph.push;
                  _context4.t6 = graph;
                  _context4.t7 = _toConsumableArray;
                  _context4.next = 16;
                  return buildRelOneToMany(inputB);

                case 16:
                  _context4.t8 = _context4.sent;
                  _context4.t9 = (0, _context4.t7)(_context4.t8);

                  _context4.t5.apply.call(_context4.t5, _context4.t6, _context4.t9);

                  return _context4.abrupt("return", graph);

                case 20:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function portComponent() {
          return _portComponent.apply(this, arguments);
        }

        return portComponent;
      }() // <system> fso:hasComponent <element>

    }, {
      key: "systemComponent",
      value: function () {
        var _systemComponent = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var input;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  input = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELASSIGNSTOGROUP,
                    ifcSubjectRel: "RelatingGroup",
                    ifcTargetRel: "RelatedObjects",
                    rdfRelationship: "fso:hasComponent",
                    ifcSubjectClassIn: [IFCSYSTEM, IFCDISTRIBUTIONSYSTEM]
                  };
                  _context5.next = 3;
                  return buildRelOneToMany(input);

                case 3:
                  return _context5.abrupt("return", _context5.sent);

                case 4:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function systemComponent() {
          return _systemComponent.apply(this, arguments);
        }

        return systemComponent;
      }()
      /**
       * PROPERTIES
       */
      // <port> a fso:InPort .
      // <port> a fso:OutPort .
      // <port> a fso:BidirectionalPort .

    }, {
      key: "portFlowDirection",
      value: function () {
        var _portFlowDirection = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(expressIDArray) {
          var graph, i, expressID, props, flowDirection, portType;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  // Port property example
                  // Description: {type: 1, value: 'Flow'}
                  // FlowDirection: {type: 3, value: 'SINK'}
                  // GlobalId: {type: 1, value: '1noFI6neD67vh$xlz57Jcc'}
                  // Name: {type: 1, value: 'InPort_1614379'}
                  // ObjectPlacement: IfcLocalPlacement {expressID: 27954, type: 2624227202, PlacementRelTo: IfcLocalPlacement, RelativePlacement: IfcAxis2Placement3D}
                  // ObjectType: null
                  // OwnerHistory: IfcOwnerHistory {expressID: 42, type: 1207048766, OwningUser: IfcPersonAndOrganization, OwningApplication: IfcApplication, State: null, …}
                  // PredefinedType: undefined
                  // Representation: null
                  // SystemType: undefined
                  // expressID: 27956
                  // type: 3041715199
                  graph = [];
                  i = 0;

                case 2:
                  if (!(i < expressIDArray.length)) {
                    _context6.next = 16;
                    break;
                  }

                  expressID = expressIDArray[i];
                  _context6.next = 6;
                  return this.ifcAPI.properties.getItemProperties(this.modelID, expressID);

                case 6:
                  props = _context6.sent;
                  flowDirection = props.FlowDirection.value;
                  portType = "";
                  if (flowDirection == "SINK") portType = "fso:InPort";
                  if (flowDirection == "SOURCE") portType = "fso:OutPort";
                  if (flowDirection == "SOURCEANDSINK") portType = "fso:BidirectionalPort";

                  if (portType != "") {
                    graph.push({
                      "@id": defaultURIBuilder(props.GlobalId.value),
                      "@type": portType
                    });
                  }

                case 13:
                  i++;
                  _context6.next = 2;
                  break;

                case 16:
                  return _context6.abrupt("return", graph);

                case 17:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function portFlowDirection(_x) {
          return _portFlowDirection.apply(this, arguments);
        }

        return portFlowDirection;
      }()
    }, {
      key: "portPlacements",
      value: function () {
        var _portPlacements = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(expressIDArray) {
          var graph, i, expressID, props, coordinates, point, portURI, cpURI;
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  graph = [];
                  i = 0;

                case 2:
                  if (!(i < expressIDArray.length)) {
                    _context7.next = 17;
                    break;
                  }

                  expressID = expressIDArray[i];
                  _context7.next = 6;
                  return this.ifcAPI.properties.getItemProperties(this.modelID, expressID, true);

                case 6:
                  props = _context7.sent;
                  _context7.next = 9;
                  return getGlobalPosition(props.ObjectPlacement);

                case 9:
                  coordinates = _context7.sent;
                  point = "POINT Z(".concat(coordinates[0], " ").concat(coordinates[1], " ").concat(coordinates[2], ")");
                  portURI = defaultURIBuilder(props.GlobalId.value);
                  cpURI = portURI + "_cp";
                  graph.push({
                    "@id": portURI,
                    "omg:hasGeometry": {
                      "@id": cpURI,
                      "@type": ["omg:Geometry", "ex:CenterPoint"],
                      "fog::asSfa_v2-wkt": point
                    }
                  });

                case 14:
                  i++;
                  _context7.next = 2;
                  break;

                case 17:
                  return _context7.abrupt("return", graph);

                case 18:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function portPlacements(_x2) {
          return _portPlacements.apply(this, arguments);
        }

        return portPlacements;
      }()
      /**
       * POST PROCESSING
       */

    }, {
      key: "componentConections",
      value: function () {
        var _componentConections = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          var query;
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  query = "PREFIX fso: <https://w3id.org/fso#>\n                    INSERT{\n                        ?e1 fso:connectedWith ?e2 .\n                        ?e2 fso:connectedWith ?e1 .\n                        ?e1 fso:feedsFluidTo ?e2 .\n                        ?e2 fso:hasFluidFedBy ?e1\n                    }\n                    WHERE{\n                        ?e1 fso:connectedPort ?p1 .\n                        ?p1 fso:connectedPort ?p2 .\n                        ?p2 fso:connectedComponent ?e2 .\n                        ?p1 a fso:OutPort .\n                        ?p2 a fso:InPort .\n                    }";
                  _context8.next = 3;
                  return this.executeUpdateQuery(query);

                case 3:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function componentConections() {
          return _componentConections.apply(this, arguments);
        }

        return componentConections;
      }()
    }, {
      key: "connectionInterfaces",
      value: function () {
        var _connectionInterfaces = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          var query;
          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  query = "PREFIX fso: <https://w3id.org/fso#>\n            PREFIX func: <http://example.org/functions#>\n            INSERT{\n                ?uri a fso:ConnectionPoint ;\n                    fso:connectsFrom ?e1 ;\n                    fso:connectsTo ?e2\n            }\n            WHERE{\n                ?e1 fso:connectedPort ?p1 .\n                ?p1 fso:connectedPort ?p2 .\n                ?p2 fso:connectedComponent ?e2 .\n                ?p1 a fso:OutPort .\n                ?p2 a fso:InPort .\n                BIND(func:uri-concat(?e1, ?e1) AS ?uri)\n            }";
                  _context9.next = 3;
                  return this.executeUpdateQuery(query);

                case 3:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function connectionInterfaces() {
          return _connectionInterfaces.apply(this, arguments);
        }

        return connectionInterfaces;
      }() // NB! pretty slow, so probably better to just get them from the IFC directly

    }, {
      key: "segmentLengths",
      value: function () {
        var _segmentLengths = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
          var query;
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  query = "PREFIX fso: <https://w3id.org/fso#>\n        PREFIX omg: <https://w3id.org/omg#>\n        PREFIX fog: <https://w3id.org/fog#>\n        PREFIX ex:  <https://example.com/>\n        PREFIX geosf: <http://www.opengis.net/def/function/geosparql/>\n        INSERT{\n            ?seg ex:length ?d\n        }\n        WHERE{\n            ?seg a fso:Segment ;\n                fso:connectedPort ?port1 , ?port2 .\n            FILTER(?port1 != ?port2)\n            ?port1 omg:hasGeometry/fog::asSfa_v2-wkt ?p1 .\n            ?port2 omg:hasGeometry/fog::asSfa_v2-wkt ?p2 .\n            BIND(geosf:distance(?p1, ?p2, 3) AS ?d)\n        }";
                  _context10.next = 3;
                  return this.executeUpdateQuery(query);

                case 3:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function segmentLengths() {
          return _segmentLengths.apply(this, arguments);
        }

        return segmentLengths;
      }()
    }]);

    return FSOParser;
  }(Parser);

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var typeMappings = {
    3740093272: ["tso:ConnectionPoint"],
    1945004755: ["tso:Component"]
  };
  var TSOParser = /*#__PURE__*/function (_Parser) {
    _inherits(TSOParser, _Parser);

    var _super = _createSuper(TSOParser);

    function TSOParser() {
      _classCallCheck(this, TSOParser);

      return _super.apply(this, arguments);
    }

    _createClass(TSOParser, [{
      key: "doParse",
      value: function () {
        var _doParse = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$jsonLDObject$G, _this$jsonLDObject$G2;

          var tripleCount;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.verbose && console.log("Started TSO parsing");
                  this.verbose && console.log("");
                  console.time("Finished TSO parsing");
                  this.verbose && console.log("## STEP 1: CLASS ASSIGNMENT ##");
                  this.verbose && console.time("1/2: Classifying TSO components");
                  _context.t0 = (_this$jsonLDObject$G = this.jsonLDObject["@graph"]).push;
                  _context.t1 = _this$jsonLDObject$G;
                  _context.t2 = _toConsumableArray;
                  _context.next = 10;
                  return this.classify();

                case 10:
                  _context.t3 = _context.sent;
                  _context.t4 = (0, _context.t2)(_context.t3);

                  _context.t0.apply.call(_context.t0, _context.t1, _context.t4);

                  this.verbose && console.timeEnd("1/2: Classifying TSO components");
                  this.verbose && console.log("");
                  this.verbose && console.log("## STEP 2: CONNECTION POINTS ##");
                  this.verbose && console.time("2/2: Finding port-port connections");
                  _context.t5 = (_this$jsonLDObject$G2 = this.jsonLDObject["@graph"]).push;
                  _context.t6 = _this$jsonLDObject$G2;
                  _context.t7 = _toConsumableArray;
                  _context.next = 22;
                  return this.connections();

                case 22:
                  _context.t8 = _context.sent;
                  _context.t9 = (0, _context.t7)(_context.t8);

                  _context.t5.apply.call(_context.t5, _context.t6, _context.t9);

                  this.verbose && console.timeEnd("2/2: Finding port-port connections");
                  console.timeEnd("Finished TSO parsing");

                  if (!this.verbose) {
                    _context.next = 32;
                    break;
                  }

                  _context.next = 30;
                  return this.getTripleCount();

                case 30:
                  tripleCount = _context.sent;
                  console.log("Total triples: " + tripleCount);

                case 32:
                  _context.next = 34;
                  return this.getTriples();

                case 34:
                  return _context.abrupt("return", _context.sent);

                case 35:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function doParse() {
          return _doParse.apply(this, arguments);
        }

        return doParse;
      }()
      /**
       * CLASS ASSIGNMENT
       */

    }, {
      key: "classify",
      value: function () {
        var _classify = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var graph, typeIDs, i, typeID, tsoClass;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  graph = [];
                  typeIDs = Object.keys(typeMappings);
                  i = 0;

                case 3:
                  if (!(i < typeIDs.length)) {
                    _context2.next = 17;
                    break;
                  }

                  typeID = typeIDs[i];
                  tsoClass = typeMappings[typeID];
                  _context2.t0 = graph.push;
                  _context2.t1 = graph;
                  _context2.t2 = _toConsumableArray;
                  _context2.next = 11;
                  return buildClassInstances(this.ifcAPI, this.modelID, typeID, tsoClass, true);

                case 11:
                  _context2.t3 = _context2.sent;
                  _context2.t4 = (0, _context2.t2)(_context2.t3);

                  _context2.t0.apply.call(_context2.t0, _context2.t1, _context2.t4);

                case 14:
                  i++;
                  _context2.next = 3;
                  break;

                case 17:
                  return _context2.abrupt("return", graph);

                case 18:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function classify() {
          return _classify.apply(this, arguments);
        }

        return classify;
      }()
      /**
       * RELATIONSHIPS
       */
      // <component> tso:connectsAt <connectionPoint>
      // <connectionPoint> tso:connectionPointOf <component>

    }, {
      key: "connections",
      value: function () {
        var _connections = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var graph, inputA;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  graph = []; // UNTIL IFC 4, THE RELATIONSHIP IS EXPRESSED WITH IFCRELCONNECTSPORTTOELEMENT

                  inputA = {
                    ifcAPI: this.ifcAPI,
                    modelID: this.modelID,
                    ifcRelationship: IFCRELCONNECTSPORTTOELEMENT,
                    ifcSubjectRel: "RelatedElement",
                    ifcTargetRel: "RelatingPort",
                    rdfRelationship: "tso:connectsAt",
                    oppoiteRelationship: "tso:connectionPointOf"
                  };
                  _context3.t0 = graph.push;
                  _context3.t1 = graph;
                  _context3.t2 = _toConsumableArray;
                  _context3.next = 7;
                  return buildRelOneToOne(inputA);

                case 7:
                  _context3.t3 = _context3.sent;
                  _context3.t4 = (0, _context3.t2)(_context3.t3);

                  _context3.t0.apply.call(_context3.t0, _context3.t1, _context3.t4);

                  return _context3.abrupt("return", graph);

                case 11:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function connections() {
          return _connections.apply(this, arguments);
        }

        return connections;
      }()
    }]);

    return TSOParser;
  }(Parser);

  var LBDParser = /*#__PURE__*/function () {
    // initialize the API
    function LBDParser() {
      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SerializationFormat.JSONLD;

      _classCallCheck(this, LBDParser);

      _defineProperty(this, "ifcApi", new IfcAPI2());

      this.format = format;
    }

    _createClass(LBDParser, [{
      key: "setWasmPath",
      value: function setWasmPath(path) {
        this.ifcApi.SetWasmPath(path);
      }
    }, {
      key: "parseBOTTriples",
      value: function () {
        var _parseBOTTriples = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ifcApi, modelID) {
          var verbose,
              botParser,
              _args = arguments;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  verbose = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
                  botParser = new BOTParser(ifcApi, modelID, this.format, verbose);
                  _context.next = 4;
                  return botParser.doParse();

                case 4:
                  return _context.abrupt("return", _context.sent);

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function parseBOTTriples(_x, _x2) {
          return _parseBOTTriples.apply(this, arguments);
        }

        return parseBOTTriples;
      }()
    }, {
      key: "parseProductTriples",
      value: function () {
        var _parseProductTriples = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ifcApi, modelID) {
          var verbose,
              productParser,
              _args2 = arguments;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  verbose = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                  productParser = new ProductParser(ifcApi, modelID, this.format, verbose);
                  _context2.next = 4;
                  return productParser.doParse();

                case 4:
                  return _context2.abrupt("return", _context2.sent);

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function parseProductTriples(_x3, _x4) {
          return _parseProductTriples.apply(this, arguments);
        }

        return parseProductTriples;
      }()
    }, {
      key: "parsePropertyTriples",
      value: function () {
        var _parsePropertyTriples = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ifcApi, modelID) {
          var verbose,
              productParser,
              _args3 = arguments;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  verbose = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;
                  productParser = new PropertyParser(ifcApi, modelID, this.format, verbose);
                  _context3.next = 4;
                  return productParser.doParse();

                case 4:
                  return _context3.abrupt("return", _context3.sent);

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function parsePropertyTriples(_x5, _x6) {
          return _parsePropertyTriples.apply(this, arguments);
        }

        return parsePropertyTriples;
      }()
    }, {
      key: "parseFSOTriples",
      value: function () {
        var _parseFSOTriples = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ifcApi, modelID) {
          var verbose,
              fsoParser,
              _args4 = arguments;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  verbose = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : false;
                  fsoParser = new FSOParser(ifcApi, modelID, this.format, verbose);
                  _context4.next = 4;
                  return fsoParser.doParse();

                case 4:
                  return _context4.abrupt("return", _context4.sent);

                case 5:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function parseFSOTriples(_x7, _x8) {
          return _parseFSOTriples.apply(this, arguments);
        }

        return parseFSOTriples;
      }()
    }, {
      key: "parseTSOTriples",
      value: function () {
        var _parseTSOTriples = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(ifcApi, modelID) {
          var verbose,
              tsoParser,
              _args5 = arguments;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  verbose = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : false;
                  tsoParser = new TSOParser(ifcApi, modelID, this.format, verbose);
                  _context5.next = 4;
                  return tsoParser.doParse();

                case 4:
                  return _context5.abrupt("return", _context5.sent);

                case 5:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function parseTSOTriples(_x9, _x10) {
          return _parseTSOTriples.apply(this, arguments);
        }

        return parseTSOTriples;
      }()
    }]);

    return LBDParser;
  }();

  exports.LBDParser = LBDParser;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=bundle.umd.js.map
