import { BufferAttribute, BufferGeometry } from 'three';
import { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils';
export class GeometryUtils {
    static merge(geometriesByMaterial, splitByBlocks = false) {
        const geometriesByMat = [];
        const sizes = [];
        for (const geometries of geometriesByMaterial) {
            const merged = this.mergeGeomsOfSameMaterial(geometries, splitByBlocks);
            geometriesByMat.push(merged);
            sizes.push(merged.index.count);
        }
        const geometry = mergeBufferGeometries(geometriesByMat);
        this.setupMaterialGroups(sizes, geometry);
        this.cleanUp(geometriesByMat);
        return geometry;
    }
    // When Three.js exports to glTF, it generates one separate mesh per material. All meshes
    // share the same BufferAttributes and have different indices
    static async mergeGltfMeshes(meshes) {
        const geometry = new BufferGeometry();
        const attributes = meshes[0].geometry.attributes;
        this.getMeshesAttributes(geometry, attributes);
        this.getMeshesIndices(geometry, meshes);
        return geometry;
    }
    static getMeshesAttributes(geometry, attributes) {
        // Three.js GLTFExporter exports custom BufferAttributes as underscore lowercase
        // eslint-disable-next-line no-underscore-dangle
        geometry.setAttribute('blockID', attributes._blockid);
        geometry.setAttribute('position', attributes.position);
        geometry.setAttribute('normal', attributes.normal);
        geometry.groups = [];
    }
    static getMeshesIndices(geometry, meshes) {
        const counter = { index: 0, material: 0 };
        const indices = [];
        for (const mesh of meshes) {
            const index = mesh.geometry.index;
            this.getIndicesOfMesh(index, indices);
            this.getMeshGroup(geometry, counter, index);
            this.cleanUpMesh(mesh);
        }
        geometry.setIndex(indices);
    }
    static getMeshGroup(geometry, counter, index) {
        geometry.groups.push({
            start: counter.index,
            count: index.count,
            materialIndex: counter.material++
        });
        counter.index += index.count;
    }
    static cleanUpMesh(mesh) {
        mesh.geometry.setIndex([]);
        mesh.geometry.attributes = {};
        mesh.geometry.dispose();
    }
    static getIndicesOfMesh(index, indices) {
        for (const number of index.array) {
            indices.push(number);
        }
    }
    static cleanUp(geometries) {
        geometries.forEach((geometry) => geometry.dispose());
        geometries.length = 0;
    }
    static setupMaterialGroups(sizes, geometry) {
        let vertexCounter = 0;
        let counter = 0;
        for (const size of sizes) {
            const group = { start: vertexCounter, count: size, materialIndex: counter++ };
            geometry.groups.push(group);
            vertexCounter += size;
        }
    }
    static mergeGeomsOfSameMaterial(geometries, splitByBlocks) {
        this.checkAllGeometriesAreIndexed(geometries);
        if (splitByBlocks) {
            this.splitByBlocks(geometries);
        }
        const merged = mergeBufferGeometries(geometries);
        this.cleanUp(geometries);
        return merged;
    }
    static splitByBlocks(geometries) {
        let i = 0;
        for (const geometry of geometries) {
            const size = geometry.attributes.position.count;
            const array = new Uint8Array(size).fill(i++);
            geometry.setAttribute('blockID', new BufferAttribute(array, 1));
        }
    }
    static checkAllGeometriesAreIndexed(geometries) {
        for (const geometry of geometries) {
            if (!geometry.index) {
                throw new Error('All geometries must be indexed!');
            }
        }
    }
}
//# sourceMappingURL=geometry-utils.js.map