import { SubsetUtils } from './subset-utils';
import { BVH } from './bvh';
export class SubsetCreator {
    constructor(items, subsets) {
        this.items = items;
        this.subsets = subsets;
        this.tempIndex = [];
    }
    createSubset(config, subsetID) {
        if (!this.subsets[subsetID])
            this.initializeSubset(config, subsetID);
        this.filterIndices(config, subsetID);
        this.constructSubsetByMaterial(config, subsetID);
        config.ids.forEach((id) => this.subsets[subsetID].ids.add(id));
        this.subsets[subsetID].mesh.geometry.setIndex(this.tempIndex);
        this.tempIndex.length = 0;
        const subset = this.subsets[subsetID].mesh;
        if (config.applyBVH)
            BVH.apply(subset.geometry);
        if (config.scene)
            config.scene.add(subset);
        return this.subsets[subsetID].mesh;
    }
    dispose() {
        this.tempIndex = [];
    }
    initializeSubset(config, subsetID) {
        const model = config.fragment.mesh;
        const subsetGeom = model.geometry;
        // this.initializeSubsetAttributes(subsetGeom, model);
        if (!config.material)
            this.initializeSubsetGroups(subsetGeom, model);
        const bvh = Boolean(config.applyBVH);
        this.subsets[subsetID] = { ids: new Set(), mesh: model, bvh };
    }
    // The subset shares the same attributes as the original (no memory consumed)
    // private initializeSubsetAttributes(subsetGeom: BufferGeometry, model: Mesh) {
    //   subsetGeom.setAttribute('position', model.geometry.attributes.position);
    //   subsetGeom.setAttribute('normal', model.geometry.attributes.normal);
    //   subsetGeom.setAttribute('expressID', model.geometry.attributes.expressID);
    //   subsetGeom.setIndex([]);
    // }
    // If the subset has original materials, initialize the groups for the subset
    initializeSubsetGroups(subsetGeom, model) {
        subsetGeom.groups = JSON.parse(JSON.stringify(model.geometry.groups));
        this.resetGroups(subsetGeom);
    }
    // Remove previous indices or filter the given ones to avoid repeating items
    filterIndices(config, subsetID) {
        const geometry = this.subsets[subsetID].mesh.geometry;
        if (config.removePrevious) {
            geometry.setIndex([]);
            this.resetGroups(geometry);
            return;
        }
        const previousIndices = geometry.index.array;
        const previousIDs = this.subsets[subsetID].ids;
        config.ids = config.ids.filter((id) => !previousIDs.has(id));
        this.tempIndex = Array.from(previousIndices);
    }
    constructSubsetByMaterial(config, subsetID) {
        const model = config.fragment.mesh;
        const newIndices = { count: 0 };
        for (let i = 0; i < model.geometry.groups.length; i++) {
            this.insertNewIndices(config, subsetID, i, newIndices);
        }
    }
    // If this subset has original materials, insert indices in correct position and update groups
    // Otherwise, just insert indices at any position
    insertNewIndices(config, subsetID, materialIndex, newIndices) {
        const items = this.items.blocks;
        const indicesOfOneMaterial = SubsetUtils.getAllIndicesOfGroup(config.ids, materialIndex, items);
        if (!config.material) {
            this.insertIndicesAtGroup(subsetID, indicesOfOneMaterial, materialIndex, newIndices);
        }
        else {
            indicesOfOneMaterial.forEach((index) => this.tempIndex.push(index));
        }
    }
    insertIndicesAtGroup(subsetID, indicesByGroup, index, newIndices) {
        const currentGroup = this.getCurrentGroup(subsetID, index);
        currentGroup.start += newIndices.count;
        const newIndicesPosition = currentGroup.start + currentGroup.count;
        newIndices.count += indicesByGroup.length;
        if (indicesByGroup.length > 0) {
            const position = newIndicesPosition;
            const start = this.tempIndex.slice(0, position);
            const end = this.tempIndex.slice(position);
            this.tempIndex = Array.prototype.concat.apply([], [start, indicesByGroup, end]);
            currentGroup.count += indicesByGroup.length;
        }
    }
    getCurrentGroup(subsetID, groupIndex) {
        const geometry = this.subsets[subsetID].mesh.geometry;
        return geometry.groups[groupIndex];
    }
    resetGroups(geometry) {
        geometry.groups.forEach((group) => {
            group.start = 0;
            group.count = 0;
        });
    }
}
//# sourceMappingURL=subset-creator.js.map