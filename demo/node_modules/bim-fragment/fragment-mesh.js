import { InstancedMesh } from 'three';
import { BufferAttribute } from 'three/src/core/BufferAttribute';
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter';
export class FragmentMesh extends InstancedMesh {
    constructor(geometry, material, count) {
        super(geometry, material, count);
        this.elementCount = 0;
        this.exportOptions = {
            trs: false,
            onlyVisible: false,
            truncateDrawRange: true,
            binary: true,
            maxTextureSize: 0
        };
        this.exporter = new GLTFExporter();
        this.material = FragmentMesh.newMaterialArray(material);
        this.geometry = this.newFragmentGeometry(geometry);
    }
    export() {
        const mesh = this;
        return new Promise((resolve) => {
            this.exporter.parse(mesh, (geometry) => resolve(geometry), this.exportOptions);
        });
    }
    newFragmentGeometry(geometry) {
        if (!geometry.index) {
            throw new Error('The geometry must be indexed!');
        }
        if (!geometry.attributes.blockID) {
            const vertexSize = geometry.attributes.position.count;
            const array = new Uint16Array(vertexSize);
            array.fill(this.elementCount++);
            geometry.attributes.blockID = new BufferAttribute(array, 1);
        }
        const size = geometry.index.count;
        FragmentMesh.initializeGroups(geometry, size);
        return geometry;
    }
    static initializeGroups(geometry, size) {
        if (!geometry.groups.length) {
            geometry.groups.push({
                start: 0,
                count: size,
                materialIndex: 0
            });
        }
    }
    static newMaterialArray(material) {
        if (!Array.isArray(material))
            material = [material];
        return material;
    }
}
//# sourceMappingURL=fragment-mesh.js.map